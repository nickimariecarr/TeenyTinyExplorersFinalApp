{"ast":null,"code":"\"use strict\";\n\nconst s = require(\"lodash\"),\n      r = s.cloneDeep(require(\"validator\")),\n      o = require(\"moment\"),\n      u = {\n  extend(t, e) {\n    return this[t] = e, this;\n  },\n\n  notEmpty(t) {\n    return !t.match(/^[\\s\\t\\r\\n]*$/);\n  },\n\n  len(t, e, n) {\n    return this.isLength(t, e, n);\n  },\n\n  isUrl(t) {\n    return this.isURL(t);\n  },\n\n  isIPv6(t) {\n    return this.isIP(t, 6);\n  },\n\n  isIPv4(t) {\n    return this.isIP(t, 4);\n  },\n\n  notIn(t, e) {\n    return !this.isIn(t, e);\n  },\n\n  regex(t, e, n) {\n    return t += \"\", Object.prototype.toString.call(e).slice(8, -1) !== \"RegExp\" && (e = new RegExp(e, n)), t.match(e);\n  },\n\n  notRegex(t, e, n) {\n    return !this.regex(t, e, n);\n  },\n\n  isDecimal(t) {\n    return t !== \"\" && !!t.match(/^(?:-?(?:[0-9]+))?(?:\\.[0-9]*)?(?:[eE][+-]?(?:[0-9]+))?$/);\n  },\n\n  min(t, e) {\n    const n = parseFloat(t);\n    return isNaN(n) || n >= e;\n  },\n\n  max(t, e) {\n    const n = parseFloat(t);\n    return isNaN(n) || n <= e;\n  },\n\n  not(t, e, n) {\n    return this.notRegex(t, e, n);\n  },\n\n  contains(t, e) {\n    return !!e && t.includes(e);\n  },\n\n  notContains(t, e) {\n    return !this.contains(t, e);\n  },\n\n  is(t, e, n) {\n    return this.regex(t, e, n);\n  }\n\n};\n\nexports.extensions = u, r.isImmutable = function (t, e, n, i) {\n  return i.isNewRecord || i.dataValues[n] === i._previousDataValues[n];\n}, r.notNull = function (t) {\n  return t != null;\n}, s.forEach(u, (t, e) => {\n  r[e] = t;\n}), r.isNull = r.isEmpty, r.isDate = function (t) {\n  const e = Date.parse(t);\n  if (isNaN(e)) return !1;\n  const n = new Date(e);\n  return o(n.toISOString()).isValid();\n}, exports.validator = r;","map":{"version":3,"sources":["../../../lib/utils/validator-extras.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst validator = _.cloneDeep(require('validator'));\nconst moment = require('moment');\n\nconst extensions = {\n  extend(name, fn) {\n    this[name] = fn;\n\n    return this;\n  },\n  notEmpty(str) {\n    return !str.match(/^[\\s\\t\\r\\n]*$/);\n  },\n  len(str, min, max) {\n    return this.isLength(str, min, max);\n  },\n  isUrl(str) {\n    return this.isURL(str);\n  },\n  isIPv6(str) {\n    return this.isIP(str, 6);\n  },\n  isIPv4(str) {\n    return this.isIP(str, 4);\n  },\n  notIn(str, values) {\n    return !this.isIn(str, values);\n  },\n  regex(str, pattern, modifiers) {\n    str += '';\n    if (Object.prototype.toString.call(pattern).slice(8, -1) !== 'RegExp') {\n      pattern = new RegExp(pattern, modifiers);\n    }\n    return str.match(pattern);\n  },\n  notRegex(str, pattern, modifiers) {\n    return !this.regex(str, pattern, modifiers);\n  },\n  isDecimal(str) {\n    return str !== '' && !!str.match(/^(?:-?(?:[0-9]+))?(?:\\.[0-9]*)?(?:[eE][+-]?(?:[0-9]+))?$/);\n  },\n  min(str, val) {\n    const number = parseFloat(str);\n    return isNaN(number) || number >= val;\n  },\n  max(str, val) {\n    const number = parseFloat(str);\n    return isNaN(number) || number <= val;\n  },\n  not(str, pattern, modifiers) {\n    return this.notRegex(str, pattern, modifiers);\n  },\n  contains(str, elem) {\n    return !!elem && str.includes(elem);\n  },\n  notContains(str, elem) {\n    return !this.contains(str, elem);\n  },\n  is(str, pattern, modifiers) {\n    return this.regex(str, pattern, modifiers);\n  }\n};\nexports.extensions = extensions;\n\n// instance based validators\nvalidator.isImmutable = function(value, validatorArgs, field, modelInstance) {\n  return modelInstance.isNewRecord || modelInstance.dataValues[field] === modelInstance._previousDataValues[field];\n};\n\n// extra validators\nvalidator.notNull = function(val) {\n  return val !== null && val !== undefined;\n};\n\n// https://github.com/chriso/validator.js/blob/6.2.0/validator.js\n_.forEach(extensions, (extend, key) => {\n  validator[key] = extend;\n});\n\n// map isNull to isEmpty\n// https://github.com/chriso/validator.js/commit/e33d38a26ee2f9666b319adb67c7fc0d3dea7125\nvalidator.isNull = validator.isEmpty;\n\n// isDate removed in 7.0.0\n// https://github.com/chriso/validator.js/commit/095509fc707a4dc0e99f85131df1176ad6389fc9\nvalidator.isDate = function(dateString) {\n  // avoid http://momentjs.com/guides/#/warnings/js-date/\n  // by doing a preliminary check on `dateString`\n  const parsed = Date.parse(dateString);\n  if (isNaN(parsed)) {\n    // fail if we can't parse it\n    return false;\n  }\n  // otherwise convert to ISO 8601 as moment prefers\n  // http://momentjs.com/docs/#/parsing/string/\n  const date = new Date(parsed);\n  return moment(date.toISOString()).isValid();\n};\n\nexports.validator = validator;\n"]},"metadata":{},"sourceType":"script"}