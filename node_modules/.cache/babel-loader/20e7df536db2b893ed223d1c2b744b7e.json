{"ast":null,"code":"\"use strict\";\n\nvar m = Object.defineProperty,\n    M = Object.defineProperties;\nvar F = Object.getOwnPropertyDescriptors;\nvar b = Object.getOwnPropertySymbols;\nvar j = Object.prototype.hasOwnProperty,\n    $ = Object.prototype.propertyIsEnumerable;\n\nvar w = (o, t, e) => t in o ? m(o, t, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: e\n}) : o[t] = e,\n    u = (o, t) => {\n  for (var e in t || (t = {})) j.call(t, e) && w(o, e, t[e]);\n\n  if (b) for (var e of b(t)) $.call(t, e) && w(o, e, t[e]);\n  return o;\n},\n    y = (o, t) => M(o, F(t));\n\nvar O = (o, t) => m(o, \"name\", {\n  value: t,\n  configurable: !0\n});\n\nconst f = require(\"./../utils\"),\n      A = require(\"./helpers\"),\n      g = require(\"lodash\"),\n      q = require(\"./base\"),\n      d = require(\"../operators\");\n\nclass p extends q {\n  constructor(t, e, i) {\n    super(t, e, i);\n    if (this.associationType = \"HasMany\", this.targetAssociation = null, this.sequelize = t.sequelize, this.isMultiAssociation = !0, this.foreignKeyAttribute = {}, this.options.through) throw new Error(\"N:M associations are not supported with hasMany. Use belongsToMany instead\");\n    this.isSelfAssociation && (this.targetAssociation = this), this.as ? (this.isAliased = !0, g.isPlainObject(this.as) ? (this.options.name = this.as, this.as = this.as.plural) : this.options.name = {\n      plural: this.as,\n      singular: f.singularize(this.as)\n    }) : (this.as = this.target.options.name.plural, this.options.name = this.target.options.name), g.isObject(this.options.foreignKey) ? (this.foreignKeyAttribute = this.options.foreignKey, this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName) : this.options.foreignKey && (this.foreignKey = this.options.foreignKey), this.foreignKey || (this.foreignKey = f.camelize([this.source.options.name.singular, this.source.primaryKeyAttribute].join(\"_\"))), this.target.rawAttributes[this.foreignKey] && (this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey, this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey), this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute, this.source.rawAttributes[this.sourceKey] ? (this.sourceKeyAttribute = this.sourceKey, this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey) : (this.sourceKeyAttribute = this.source.primaryKeyAttribute, this.sourceKeyField = this.source.primaryKeyField);\n    const s = g.upperFirst(this.options.name.plural),\n          r = g.upperFirst(this.options.name.singular);\n    this.associationAccessor = this.as, this.accessors = {\n      get: `get${s}`,\n      set: `set${s}`,\n      addMultiple: `add${s}`,\n      add: `add${r}`,\n      create: `create${r}`,\n      remove: `remove${r}`,\n      removeMultiple: `remove${s}`,\n      hasSingle: `has${r}`,\n      hasAll: `has${s}`,\n      count: `count${s}`\n    };\n  }\n\n  _injectAttributes() {\n    const t = {\n      [this.foreignKey]: u({\n        type: this.options.keyType || this.source.rawAttributes[this.sourceKeyAttribute].type,\n        allowNull: !0\n      }, this.foreignKeyAttribute)\n    },\n          e = u({}, this.options);\n\n    if (this.options.constraints !== !1) {\n      const i = this.target.rawAttributes[this.foreignKey] || t[this.foreignKey];\n      e.onDelete = e.onDelete || (i.allowNull ? \"SET NULL\" : \"CASCADE\"), e.onUpdate = e.onUpdate || \"CASCADE\";\n    }\n\n    return A.addForeignKeyConstraints(t[this.foreignKey], this.source, this.target, e, this.sourceKeyField), f.mergeDefaults(this.target.rawAttributes, t), this.target.refreshAttributes(), this.source.refreshAttributes(), this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey, this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey, this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey, A.checkNamingCollision(this), this;\n  }\n\n  mixin(t) {\n    const e = [\"get\", \"count\", \"hasSingle\", \"hasAll\", \"set\", \"add\", \"addMultiple\", \"remove\", \"removeMultiple\", \"create\"],\n          i = {\n      hasSingle: \"has\",\n      hasAll: \"has\",\n      addMultiple: \"add\",\n      removeMultiple: \"remove\"\n    };\n    A.mixinMethods(this, t, e, i);\n  }\n\n  async get(t) {\n    let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const i = {};\n    let s = this.target,\n        r,\n        h;\n    Array.isArray(t) || (r = t, t = void 0), e = u({}, e), this.scope && Object.assign(i, this.scope), t ? (h = t.map(a => a.get(this.sourceKey, {\n      raw: !0\n    })), e.limit && t.length > 1 ? (e.groupedLimit = {\n      limit: e.limit,\n      on: this,\n      values: h\n    }, delete e.limit) : (i[this.foreignKey] = {\n      [d.in]: h\n    }, delete e.groupedLimit)) : i[this.foreignKey] = r.get(this.sourceKey, {\n      raw: !0\n    }), e.where = e.where ? {\n      [d.and]: [i, e.where]\n    } : i, Object.prototype.hasOwnProperty.call(e, \"scope\") && (e.scope ? s = s.scope(e.scope) : s = s.unscoped()), Object.prototype.hasOwnProperty.call(e, \"schema\") && (s = s.schema(e.schema, e.schemaDelimiter));\n    const c = await s.findAll(e);\n    if (r) return c;\n    const l = {};\n\n    for (const a of t) l[a.get(this.sourceKey, {\n      raw: !0\n    })] = [];\n\n    for (const a of c) l[a.get(this.foreignKey, {\n      raw: !0\n    })].push(a);\n\n    return l;\n  }\n\n  async count(t, e) {\n    e = f.cloneDeep(e), e.attributes = [[this.sequelize.fn(\"COUNT\", this.sequelize.col(`${this.target.name}.${this.target.primaryKeyField}`)), \"count\"]], e.raw = !0, e.plain = !0;\n    const i = await this.get(t, e);\n    return parseInt(i.count, 10);\n  }\n\n  async has(t, e, i) {\n    const s = {};\n    return Array.isArray(e) || (e = [e]), i = y(u({}, i), {\n      scope: !1,\n      attributes: [this.target.primaryKeyAttribute],\n      raw: !0\n    }), s[d.or] = e.map(h => h instanceof this.target ? h.where() : {\n      [this.target.primaryKeyAttribute]: h\n    }), i.where = {\n      [d.and]: [s, i.where]\n    }, (await this.get(t, i)).length === e.length;\n  }\n\n  async set(t, e, i) {\n    e === null ? e = [] : e = this.toInstanceArray(e);\n    const s = await this.get(t, y(u({}, i), {\n      scope: !1,\n      raw: !0\n    })),\n          r = [],\n          h = s.filter(n => !e.find(K => K[this.target.primaryKeyAttribute] === n[this.target.primaryKeyAttribute])),\n          c = e.filter(n => !s.find(K => n[this.target.primaryKeyAttribute] === K[this.target.primaryKeyAttribute]));\n    let l, a;\n    return h.length > 0 && (a = {}, a[this.foreignKey] = null, l = {\n      [this.target.primaryKeyAttribute]: h.map(n => n[this.target.primaryKeyAttribute])\n    }, r.push(this.target.unscoped().update(a, y(u({}, i), {\n      where: l\n    })))), c.length > 0 && (l = {}, a = {}, a[this.foreignKey] = t.get(this.sourceKey), Object.assign(a, this.scope), l[this.target.primaryKeyAttribute] = c.map(n => n[this.target.primaryKeyAttribute]), r.push(this.target.unscoped().update(a, y(u({}, i), {\n      where: l\n    })))), await Promise.all(r), t;\n  }\n\n  async add(t, e) {\n    let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!e) return Promise.resolve();\n    e = this.toInstanceArray(e);\n    const s = u({\n      [this.foreignKey]: t.get(this.sourceKey)\n    }, this.scope),\n          r = {\n      [this.target.primaryKeyAttribute]: e.map(h => h.get(this.target.primaryKeyAttribute))\n    };\n    return await this.target.unscoped().update(s, y(u({}, i), {\n      where: r\n    })), t;\n  }\n\n  async remove(t, e) {\n    let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const s = {\n      [this.foreignKey]: null\n    };\n    e = this.toInstanceArray(e);\n    const r = {\n      [this.foreignKey]: t.get(this.sourceKey),\n      [this.target.primaryKeyAttribute]: e.map(h => h.get(this.target.primaryKeyAttribute))\n    };\n    return await this.target.unscoped().update(s, y(u({}, i), {\n      where: r\n    })), this;\n  }\n\n  async create(t, e) {\n    let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (Array.isArray(i) && (i = {\n      fields: i\n    }), e === void 0 && (e = {}), this.scope) for (const s of Object.keys(this.scope)) e[s] = this.scope[s], i.fields && i.fields.push(s);\n    return e[this.foreignKey] = t.get(this.sourceKey), i.fields && i.fields.push(this.foreignKey), await this.target.create(e, i);\n  }\n\n  verifyAssociationAlias(t) {\n    return typeof t == \"string\" ? this.as === t : t && t.plural ? this.as === t.plural : !this.isAliased;\n  }\n\n}\n\nO(p, \"HasMany\"), module.exports = p, module.exports.HasMany = p, module.exports.default = p;","map":{"version":3,"sources":["../../../lib/associations/has-many.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\nconst Op = require('../operators');\n\n/**\n * One-to-many association\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.hasMany(Project)` the getter will be `user.getProjects()`.\n * If the association is aliased, use the alias instead, e.g. `User.hasMany(Project, { as: 'jobs' })` will be `user.getJobs()`.\n *\n * @see {@link Model.hasMany}\n */\nclass HasMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    this.associationType = 'HasMany';\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.isMultiAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.options.through) {\n      throw new Error('N:M associations are not supported with hasMany. Use belongsToMany instead');\n    }\n\n    /*\n    * If self association, this is the target association\n    */\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n\n    if (this.as) {\n      this.isAliased = true;\n\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n\n    /*\n     * Foreign key setup\n     */\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize(\n        [\n          this.source.options.name.singular,\n          this.source.primaryKeyAttribute\n        ].join('_')\n      );\n    }\n\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n      this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    }\n\n    /*\n     * Source key setup\n     */\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n\n    if (this.source.rawAttributes[this.sourceKey]) {\n      this.sourceKeyAttribute = this.sourceKey;\n      this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    } else {\n      this.sourceKeyAttribute = this.source.primaryKeyAttribute;\n      this.sourceKeyField = this.source.primaryKeyField;\n    }\n\n    // Get singular and plural names\n    // try to uppercase the first letter, unless the model forbids it\n    const plural = _.upperFirst(this.options.name.plural);\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.associationAccessor = this.as;\n    this.accessors = {\n      get: `get${plural}`,\n      set: `set${plural}`,\n      addMultiple: `add${plural}`,\n      add: `add${singular}`,\n      create: `create${singular}`,\n      remove: `remove${singular}`,\n      removeMultiple: `remove${plural}`,\n      hasSingle: `has${singular}`,\n      hasAll: `has${plural}`,\n      count: `count${plural}`\n    };\n  }\n\n  // the id is in the target table\n  // or in an extra table which connects two tables\n  _injectAttributes() {\n    const newAttributes = {\n      [this.foreignKey]: {\n        type: this.options.keyType || this.source.rawAttributes[this.sourceKeyAttribute].type,\n        allowNull: true,\n        ...this.foreignKeyAttribute\n      }\n    };\n\n    // Create a new options object for use with addForeignKeyConstraints, to avoid polluting this.options in case it is later used for a n:m\n    const constraintOptions = { ...this.options };\n\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      constraintOptions.onDelete = constraintOptions.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');\n      constraintOptions.onUpdate = constraintOptions.onUpdate || 'CASCADE';\n    }\n\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, constraintOptions, this.sourceKeyField);\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n\n    this.target.refreshAttributes();\n    this.source.refreshAttributes();\n\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];\n    const aliases = {\n      hasSingle: 'has',\n      hasAll: 'has',\n      addMultiple: 'add',\n      removeMultiple: 'remove'\n    };\n\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n\n  /**\n   * Get everything currently associated with this, using an optional where clause.\n   *\n   * @param {Model|Array<Model>} instances source instances\n   * @param {object} [options] find options\n   * @param {object} [options.where] An optional where clause to limit the associated models\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {string} [options.schema] Apply a schema on the related model\n   *\n   * @see\n   * {@link Model.findAll}  for a full explanation of options\n   *\n   * @returns {Promise<Array<Model>>}\n   */\n  async get(instances, options = {}) {\n    const where = {};\n\n    let Model = this.target;\n    let instance;\n    let values;\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = undefined;\n    }\n\n    options = { ...options };\n\n    if (this.scope) {\n      Object.assign(where, this.scope);\n    }\n\n    if (instances) {\n      values = instances.map(_instance => _instance.get(this.sourceKey, { raw: true }));\n\n      if (options.limit && instances.length > 1) {\n        options.groupedLimit = {\n          limit: options.limit,\n          on: this, // association\n          values\n        };\n\n        delete options.limit;\n      } else {\n        where[this.foreignKey] = {\n          [Op.in]: values\n        };\n        delete options.groupedLimit;\n      }\n    } else {\n      where[this.foreignKey] = instance.get(this.sourceKey, { raw: true });\n    }\n\n    options.where = options.where ?\n      { [Op.and]: [where, options.where] } :\n      where;\n\n    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n      if (!options.scope) {\n        Model = Model.unscoped();\n      } else {\n        Model = Model.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n      Model = Model.schema(options.schema, options.schemaDelimiter);\n    }\n\n    const results = await Model.findAll(options);\n    if (instance) return results;\n\n    const result = {};\n    for (const _instance of instances) {\n      result[_instance.get(this.sourceKey, { raw: true })] = [];\n    }\n\n    for (const _instance of results) {\n      result[_instance.get(this.foreignKey, { raw: true })].push(_instance);\n    }\n\n    return result;\n  }\n\n  /**\n   * Count everything currently associated with this, using an optional where clause.\n   *\n   * @param {Model}        instance the source instance\n   * @param {object}         [options] find & count options\n   * @param {object}         [options.where] An optional where clause to limit the associated models\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   *\n   * @returns {Promise<number>}\n   */\n  async count(instance, options) {\n    options = Utils.cloneDeep(options);\n\n    options.attributes = [\n      [\n        this.sequelize.fn(\n          'COUNT',\n          this.sequelize.col(`${this.target.name}.${this.target.primaryKeyField}`)\n        ),\n        'count'\n      ]\n    ];\n    options.raw = true;\n    options.plain = true;\n\n    const result = await this.get(instance, options);\n\n    return parseInt(result.count, 10);\n  }\n\n  /**\n   * Check if one or more rows are associated with `this`.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] Can be an array of instances or their primary keys\n   * @param {object} [options] Options passed to getAssociations\n   *\n   * @returns {Promise}\n   */\n  async has(sourceInstance, targetInstances, options) {\n    const where = {};\n\n    if (!Array.isArray(targetInstances)) {\n      targetInstances = [targetInstances];\n    }\n\n    options = {\n      ...options,\n      scope: false,\n      attributes: [this.target.primaryKeyAttribute],\n      raw: true\n    };\n\n    where[Op.or] = targetInstances.map(instance => {\n      if (instance instanceof this.target) {\n        return instance.where();\n      }\n      return {\n        [this.target.primaryKeyAttribute]: instance\n      };\n    });\n\n    options.where = {\n      [Op.and]: [\n        where,\n        options.where\n      ]\n    };\n\n    const associatedObjects = await this.get(sourceInstance, options);\n\n    return associatedObjects.length === targetInstances.length;\n  }\n\n  /**\n   * Set the associated models by passing an array of persisted instances or their primary keys. Everything that is not in the passed array will be un-associated\n   *\n   * @param {Model} sourceInstance source instance to associate new instances with\n   * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] An array of persisted instances or primary key of instances to associate with this. Pass `null` or `undefined` to remove all associations.\n   * @param {object} [options] Options passed to `target.findAll` and `update`.\n   * @param {object} [options.validate] Run validation for the join model\n   *\n   * @returns {Promise}\n   */\n  async set(sourceInstance, targetInstances, options) {\n    if (targetInstances === null) {\n      targetInstances = [];\n    } else {\n      targetInstances = this.toInstanceArray(targetInstances);\n    }\n\n    const oldAssociations = await this.get(sourceInstance, { ...options, scope: false, raw: true });\n    const promises = [];\n    const obsoleteAssociations = oldAssociations.filter(old =>\n      !targetInstances.find(obj =>\n        obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]\n      )\n    );\n    const unassociatedObjects = targetInstances.filter(obj =>\n      !oldAssociations.find(old =>\n        obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]\n      )\n    );\n    let updateWhere;\n    let update;\n\n    if (obsoleteAssociations.length > 0) {\n      update = {};\n      update[this.foreignKey] = null;\n\n      updateWhere = {\n        [this.target.primaryKeyAttribute]: obsoleteAssociations.map(associatedObject =>\n          associatedObject[this.target.primaryKeyAttribute]\n        )\n      };\n\n\n      promises.push(this.target.unscoped().update(\n        update,\n        {\n          ...options,\n          where: updateWhere\n        }\n      ));\n    }\n\n    if (unassociatedObjects.length > 0) {\n      updateWhere = {};\n\n      update = {};\n      update[this.foreignKey] = sourceInstance.get(this.sourceKey);\n\n      Object.assign(update, this.scope);\n      updateWhere[this.target.primaryKeyAttribute] = unassociatedObjects.map(unassociatedObject =>\n        unassociatedObject[this.target.primaryKeyAttribute]\n      );\n\n      promises.push(this.target.unscoped().update(\n        update,\n        {\n          ...options,\n          where: updateWhere\n        }\n      ));\n    }\n\n    await Promise.all(promises);\n\n    return sourceInstance;\n  }\n\n  /**\n   * Associate one or more target rows with `this`. This method accepts a Model / string / number to associate a single row,\n   * or a mixed array of Model / string / numbers to associate multiple rows.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] A single instance or primary key, or a mixed array of persisted instances or primary keys\n   * @param {object} [options] Options passed to `target.update`.\n   *\n   * @returns {Promise}\n   */\n  async add(sourceInstance, targetInstances, options = {}) {\n    if (!targetInstances) return Promise.resolve();\n\n\n    targetInstances = this.toInstanceArray(targetInstances);\n\n    const update = {\n      [this.foreignKey]: sourceInstance.get(this.sourceKey),\n      ...this.scope\n    };\n\n    const where = {\n      [this.target.primaryKeyAttribute]: targetInstances.map(unassociatedObject =>\n        unassociatedObject.get(this.target.primaryKeyAttribute)\n      )\n    };\n\n    await this.target.unscoped().update(update, { ...options, where });\n\n    return sourceInstance;\n  }\n\n  /**\n   * Un-associate one or several target rows.\n   *\n   * @param {Model} sourceInstance instance to un associate instances with\n   * @param {Model|Model[]|string|string[]|number|number[]} [targetInstances] Can be an Instance or its primary key, or a mixed array of instances and primary keys\n   * @param {object} [options] Options passed to `target.update`\n   *\n   * @returns {Promise}\n   */\n  async remove(sourceInstance, targetInstances, options = {}) {\n    const update = {\n      [this.foreignKey]: null\n    };\n\n    targetInstances = this.toInstanceArray(targetInstances);\n\n    const where = {\n      [this.foreignKey]: sourceInstance.get(this.sourceKey),\n      [this.target.primaryKeyAttribute]: targetInstances.map(targetInstance =>\n        targetInstance.get(this.target.primaryKeyAttribute)\n      )\n    };\n\n    await this.target.unscoped().update(update, { ...options, where });\n\n    return this;\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Model} sourceInstance source instance\n   * @param {object} [values] values for target model instance\n   * @param {object} [options] Options passed to `target.create`\n   *\n   * @returns {Promise}\n   */\n  async create(sourceInstance, values, options = {}) {\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n\n    if (values === undefined) {\n      values = {};\n    }\n\n    if (this.scope) {\n      for (const attribute of Object.keys(this.scope)) {\n        values[attribute] = this.scope[attribute];\n        if (options.fields) options.fields.push(attribute);\n      }\n    }\n\n    values[this.foreignKey] = sourceInstance.get(this.sourceKey);\n    if (options.fields) options.fields.push(this.foreignKey);\n    return await this.target.create(values, options);\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === 'string') {\n      return this.as === alias;\n    }\n\n    if (alias && alias.plural) {\n      return this.as === alias.plural;\n    }\n\n    return !this.isAliased;\n  }\n}\n\nmodule.exports = HasMany;\nmodule.exports.HasMany = HasMany;\nmodule.exports.default = HasMany;\n"]},"metadata":{},"sourceType":"script"}