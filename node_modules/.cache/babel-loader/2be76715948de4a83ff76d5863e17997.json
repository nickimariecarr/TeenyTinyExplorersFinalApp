{"ast":null,"code":"\"use strict\";\n\nvar b = Object.defineProperty;\nvar S = Object.getOwnPropertySymbols;\nvar C = Object.prototype.hasOwnProperty,\n    W = Object.prototype.propertyIsEnumerable;\n\nvar I = (e, r, n) => r in e ? b(e, r, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: n\n}) : e[r] = n,\n    q = (e, r) => {\n  for (var n in r || (r = {})) C.call(r, n) && I(e, n, r[n]);\n\n  if (S) for (var n of S(r)) W.call(r, n) && I(e, n, r[n]);\n  return e;\n};\n\nvar i = (e, r) => b(e, \"name\", {\n  value: r,\n  configurable: !0\n});\n\nconst u = require(\"./data-types\"),\n      N = require(\"./sql-string\"),\n      f = require(\"lodash\"),\n      x = require(\"lodash/_baseIsNative\"),\n      U = require(\"uuid\").v1,\n      $ = require(\"uuid\").v4,\n      K = require(\"./operators\"),\n      V = new Set(Object.values(K));\n\nlet l = require(\"inflection\");\n\nexports.classToInvokable = require(\"./utils/class-to-invokable\").classToInvokable, exports.joinSQLFragments = require(\"./utils/join-sql-fragments\").joinSQLFragments;\n\nfunction H(e) {\n  l = e;\n}\n\ni(H, \"useInflection\"), exports.useInflection = H;\n\nfunction L(e, r) {\n  let n = e;\n  return r && (n = p(e)), n;\n}\n\ni(L, \"camelizeIf\"), exports.camelizeIf = L;\n\nfunction R(e, r) {\n  let n = e;\n  return r && (n = h(e)), n;\n}\n\ni(R, \"underscoredIf\"), exports.underscoredIf = R;\n\nfunction J(e) {\n  const r = typeof e;\n  return r === \"string\" || r === \"number\" || r === \"boolean\";\n}\n\ni(J, \"isPrimitive\"), exports.isPrimitive = J;\n\nfunction Q(e, r) {\n  return f.mergeWith(e, r, (n, t) => {\n    if (!f.isPlainObject(n) && n !== void 0) return f.isFunction(n) && x(n) && t || n;\n  });\n}\n\ni(Q, \"mergeDefaults\"), exports.mergeDefaults = Q;\n\nfunction T() {\n  const e = {};\n\n  for (const r of arguments) f.forOwn(r, (n, t) => {\n    n !== void 0 && (e[t] ? f.isPlainObject(n) && f.isPlainObject(e[t]) ? e[t] = T(e[t], n) : Array.isArray(n) && Array.isArray(e[t]) ? e[t] = n.concat(e[t]) : e[t] = n : e[t] = n);\n  });\n\n  return e;\n}\n\ni(T, \"merge\"), exports.merge = T;\n\nfunction Z(e, r, n, t) {\n  return e.slice(0, r) + t + e.slice(r + n);\n}\n\ni(Z, \"spliceStr\"), exports.spliceStr = Z;\n\nfunction p(e) {\n  return e.trim().replace(/[-_\\s]+(.)?/g, (r, n) => n.toUpperCase());\n}\n\ni(p, \"camelize\"), exports.camelize = p;\n\nfunction h(e) {\n  return l.underscore(e);\n}\n\ni(h, \"underscore\"), exports.underscore = h;\n\nfunction B(e) {\n  return l.singularize(e);\n}\n\ni(B, \"singularize\"), exports.singularize = B;\n\nfunction G(e) {\n  return l.pluralize(e);\n}\n\ni(G, \"pluralize\"), exports.pluralize = G;\n\nfunction X(e, r) {\n  const n = null;\n  return N.format(e[0], e.slice(1), n, r);\n}\n\ni(X, \"format\"), exports.format = X;\n\nfunction Y(e, r, n) {\n  const t = null;\n  return N.formatNamedParameters(e, r, t, n);\n}\n\ni(Y, \"formatNamedParameters\"), exports.formatNamedParameters = Y;\n\nfunction j(e, r) {\n  return e = e || {}, f.cloneDeepWith(e, n => {\n    if (!(Array.isArray(n) || f.isPlainObject(n))) {\n      if (r || typeof n == \"object\") return n;\n      if (n && typeof n.clone == \"function\") return n.clone();\n    }\n  });\n}\n\ni(j, \"cloneDeep\"), exports.cloneDeep = j;\n\nfunction v(e, r) {\n  return e.attributes && Array.isArray(e.attributes) && (e.attributes = r._injectDependentVirtualAttributes(e.attributes), e.attributes = e.attributes.filter(n => !r._virtualAttributes.has(n))), O(e, r), e;\n}\n\ni(v, \"mapFinderOptions\"), exports.mapFinderOptions = v;\n\nfunction O(e, r) {\n  return Array.isArray(e.attributes) && (e.attributes = e.attributes.map(n => typeof n != \"string\" ? n : r.rawAttributes[n] && n !== r.rawAttributes[n].field ? [r.rawAttributes[n].field, n] : n)), e.where && f.isPlainObject(e.where) && (e.where = g(e.where, r)), e;\n}\n\ni(O, \"mapOptionFieldNames\"), exports.mapOptionFieldNames = O;\n\nfunction g(e, r) {\n  return e && (e = j(e), d(e).forEach(n => {\n    const t = r.rawAttributes[n];\n    t && t.field !== t.fieldName && (e[t.field] = e[n], delete e[n]), f.isPlainObject(e[n]) && !(t && (t.type instanceof u.HSTORE || t.type instanceof u.JSON)) && (e[n] = O({\n      where: e[n]\n    }, r).where), Array.isArray(e[n]) && e[n].forEach((s, c) => {\n      f.isPlainObject(s) && (e[n][c] = g(s, r));\n    });\n  })), e;\n}\n\ni(g, \"mapWhereFieldNames\"), exports.mapWhereFieldNames = g;\n\nfunction M(e, r, n) {\n  const t = {};\n\n  for (const s of r) e[s] !== void 0 && !n._virtualAttributes.has(s) && (n.rawAttributes[s] && n.rawAttributes[s].field && n.rawAttributes[s].field !== s ? t[n.rawAttributes[s].field] = e[s] : t[s] = e[s]);\n\n  return t;\n}\n\ni(M, \"mapValueFieldNames\"), exports.mapValueFieldNames = M;\n\nfunction k(e) {\n  return typeof e == \"string\" && e[0] === \"$\" && e[e.length - 1] === \"$\";\n}\n\ni(k, \"isColString\"), exports.isColString = k;\n\nfunction ee(e) {\n  return e.some(r => f.isPlainObject(r) || r instanceof w);\n}\n\ni(ee, \"canTreatArrayAsAnd\"), exports.canTreatArrayAsAnd = ee;\n\nfunction ne(e, r) {\n  return e.toLowerCase() < r.toLowerCase() ? e + r : r + e;\n}\n\ni(ne, \"combineTableNames\"), exports.combineTableNames = ne;\n\nfunction re(e, r) {\n  if (typeof e == \"function\") {\n    const n = e();\n    return n instanceof u.ABSTRACT ? n.toSql() : n;\n  }\n\n  return e instanceof u.UUIDV1 ? U() : e instanceof u.UUIDV4 ? $() : e instanceof u.NOW ? D(r) : Array.isArray(e) ? e.slice() : f.isPlainObject(e) ? q({}, e) : e;\n}\n\ni(re, \"toDefaultValue\"), exports.toDefaultValue = re;\n\nfunction te(e) {\n  return e === void 0 || e instanceof u.NOW || e instanceof u.UUIDV1 || e instanceof u.UUIDV4 ? !1 : typeof e != \"function\";\n}\n\ni(te, \"defaultValueSchemable\"), exports.defaultValueSchemable = te;\n\nfunction ie(e, r, n) {\n  let t = e;\n\n  if (n = n || {}, n.allowNull = n.allowNull || [], r) {\n    const s = {};\n    f.forIn(e, (c, o) => {\n      (n.allowNull.includes(o) || o.endsWith(\"Id\") || c != null) && (s[o] = c);\n    }), t = s;\n  }\n\n  return t;\n}\n\ni(ie, \"removeNullValuesFromHash\"), exports.removeNullValuesFromHash = ie;\nconst se = new Set([\"mariadb\", \"mysql\", \"postgres\", \"sqlite\", \"mssql\"]);\n\nfunction D(e) {\n  const r = new Date();\n  return se.has(e) || r.setMilliseconds(0), r;\n}\n\ni(D, \"now\"), exports.now = D;\nconst A = \"`\";\nexports.TICK_CHAR = A;\n\nfunction fe(e, r) {\n  return r = r || A, r + P(e, r) + r;\n}\n\ni(fe, \"addTicks\"), exports.addTicks = fe;\n\nfunction P(e, r) {\n  return r = r || A, e.replace(new RegExp(r, \"g\"), \"\");\n}\n\ni(P, \"removeTicks\"), exports.removeTicks = P;\n\nfunction ce(e) {\n  if (!f.isPlainObject(e)) return e;\n  const r = {};\n\n  function n(t, s) {\n    return Object.keys(t).forEach(c => {\n      const o = s ? `${s}.${c}` : c;\n      typeof t[c] == \"object\" && t[c] !== null ? n(t[c], o) : r[o] = f.get(t, c);\n    }), r;\n  }\n\n  return i(n, \"flattenObject\"), n(e, void 0);\n}\n\ni(ce, \"flattenObjectDeep\"), exports.flattenObjectDeep = ce;\n\nclass a {}\n\ni(a, \"SequelizeMethod\"), exports.SequelizeMethod = a;\n\nclass m extends a {\n  constructor(r, n) {\n    super();\n    this.fn = r, this.args = n;\n  }\n\n  clone() {\n    return new m(this.fn, this.args);\n  }\n\n}\n\ni(m, \"Fn\"), exports.Fn = m;\n\nclass z extends a {\n  constructor(r) {\n    super();\n\n    for (var _len = arguments.length, n = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      n[_key - 1] = arguments[_key];\n    }\n\n    n.length > 0 && (r = n), this.col = r;\n  }\n\n}\n\ni(z, \"Col\"), exports.Col = z;\n\nclass E extends a {\n  constructor(r, n, t) {\n    super();\n    this.val = r, this.type = (n || \"\").trim(), this.json = t || !1;\n  }\n\n}\n\ni(E, \"Cast\"), exports.Cast = E;\n\nclass F extends a {\n  constructor(r) {\n    super();\n    this.val = r;\n  }\n\n}\n\ni(F, \"Literal\"), exports.Literal = F;\n\nclass _ extends a {\n  constructor(r, n) {\n    super();\n    f.isObject(r) ? this.conditions = r : (this.path = r, n && (this.value = n));\n  }\n\n}\n\ni(_, \"Json\"), exports.Json = _;\n\nclass w extends a {\n  constructor(r, n, t) {\n    super();\n    t === void 0 && (t = n, n = \"=\"), this.attribute = r, this.comparator = n, this.logic = t;\n  }\n\n}\n\ni(w, \"Where\"), exports.Where = w;\n\nfunction y(e) {\n  return Object.getOwnPropertySymbols(e).filter(r => V.has(r));\n}\n\ni(y, \"getOperators\"), exports.getOperators = y;\n\nfunction d(e) {\n  return y(e).concat(Object.keys(e));\n}\n\ni(d, \"getComplexKeys\"), exports.getComplexKeys = d;\n\nfunction ue(e) {\n  return Array.isArray(e) ? e.length : d(e).length;\n}\n\ni(ue, \"getComplexSize\"), exports.getComplexSize = ue;\n\nfunction ae(e) {\n  return !!e && f.isEmpty(e) && y(e).length === 0;\n}\n\ni(ae, \"isWhereEmpty\"), exports.isWhereEmpty = ae;\n\nfunction oe(e, r) {\n  return `enum_${e}_${r}`;\n}\n\ni(oe, \"generateEnumName\"), exports.generateEnumName = oe;\n\nfunction le(e) {\n  const r = new Object();\n  return Object.keys(e).forEach(n => {\n    r[p(n)] = e[n];\n  }), r;\n}\n\ni(le, \"camelizeObjectKeys\"), exports.camelizeObjectKeys = le;\n\nfunction me(e) {\n  for (var _len2 = arguments.length, r = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    r[_key2 - 1] = arguments[_key2];\n  }\n\n  return e = Object(e), r.forEach(n => {\n    n && (n = Object(n), d(n).forEach(t => {\n      const s = e[t];\n      (s === void 0 || f.eq(s, Object.prototype[t]) && !Object.prototype.hasOwnProperty.call(e, t)) && (e[t] = n[t]);\n    }));\n  }), e;\n}\n\ni(me, \"defaults\"), exports.defaults = me;\n\nfunction de(e, r) {\n  if (r.tableName && (r = r.tableName), !Object.prototype.hasOwnProperty.call(e, \"name\")) {\n    const n = e.fields.map(t => typeof t == \"string\" ? t : t.name || t.attribute);\n    e.name = h(`${r}_${n.join(\"_\")}`);\n  }\n\n  return e;\n}\n\ni(de, \"nameIndex\"), exports.nameIndex = de;\n\nfunction pe(e, r) {\n  return e.some(n => r.includes(n));\n}\n\ni(pe, \"intersects\"), exports.intersects = pe;","map":{"version":3,"sources":["../../lib/utils.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst DataTypes = require('./data-types');\nconst SqlString = require('./sql-string');\nconst _ = require('lodash');\nconst baseIsNative = require('lodash/_baseIsNative');\nconst uuidv1 = require('uuid').v1;\nconst uuidv4 = require('uuid').v4;\nconst operators = require('./operators');\nconst operatorsSet = new Set(Object.values(operators));\n\nlet inflection = require('inflection');\n\nexports.classToInvokable = require('./utils/class-to-invokable').classToInvokable;\nexports.joinSQLFragments = require('./utils/join-sql-fragments').joinSQLFragments;\n\nfunction useInflection(_inflection) {\n  inflection = _inflection;\n}\nexports.useInflection = useInflection;\n\nfunction camelizeIf(str, condition) {\n  let result = str;\n\n  if (condition) {\n    result = camelize(str);\n  }\n\n  return result;\n}\nexports.camelizeIf = camelizeIf;\n\nfunction underscoredIf(str, condition) {\n  let result = str;\n\n  if (condition) {\n    result = underscore(str);\n  }\n\n  return result;\n}\nexports.underscoredIf = underscoredIf;\n\nfunction isPrimitive(val) {\n  const type = typeof val;\n  return type === 'string' || type === 'number' || type === 'boolean';\n}\nexports.isPrimitive = isPrimitive;\n\n// Same concept as _.merge, but don't overwrite properties that have already been assigned\nfunction mergeDefaults(a, b) {\n  return _.mergeWith(a, b, (objectValue, sourceValue) => {\n    // If it's an object, let _ handle it this time, we will be called again for each property\n    if (!_.isPlainObject(objectValue) && objectValue !== undefined) {\n      // _.isNative includes a check for core-js and throws an error if present.\n      // Depending on _baseIsNative bypasses the core-js check.\n      if (_.isFunction(objectValue) && baseIsNative(objectValue)) {\n        return sourceValue || objectValue;\n      }\n      return objectValue;\n    }\n  });\n}\nexports.mergeDefaults = mergeDefaults;\n\n// An alternative to _.merge, which doesn't clone its arguments\n// Cloning is a bad idea because options arguments may contain references to sequelize\n// models - which again reference database libs which don't like to be cloned (in particular pg-native)\nfunction merge() {\n  const result = {};\n\n  for (const obj of arguments) {\n    _.forOwn(obj, (value, key) => {\n      if (value !== undefined) {\n        if (!result[key]) {\n          result[key] = value;\n        } else if (_.isPlainObject(value) && _.isPlainObject(result[key])) {\n          result[key] = merge(result[key], value);\n        } else if (Array.isArray(value) && Array.isArray(result[key])) {\n          result[key] = value.concat(result[key]);\n        } else {\n          result[key] = value;\n        }\n      }\n    });\n  }\n\n  return result;\n}\nexports.merge = merge;\n\nfunction spliceStr(str, index, count, add) {\n  return str.slice(0, index) + add + str.slice(index + count);\n}\nexports.spliceStr = spliceStr;\n\nfunction camelize(str) {\n  return str.trim().replace(/[-_\\s]+(.)?/g, (match, c) => c.toUpperCase());\n}\nexports.camelize = camelize;\n\nfunction underscore(str) {\n  return inflection.underscore(str);\n}\nexports.underscore = underscore;\n\nfunction singularize(str) {\n  return inflection.singularize(str);\n}\nexports.singularize = singularize;\n\nfunction pluralize(str) {\n  return inflection.pluralize(str);\n}\nexports.pluralize = pluralize;\n\nfunction format(arr, dialect) {\n  const timeZone = null;\n  // Make a clone of the array beacuse format modifies the passed args\n  return SqlString.format(arr[0], arr.slice(1), timeZone, dialect);\n}\nexports.format = format;\n\nfunction formatNamedParameters(sql, parameters, dialect) {\n  const timeZone = null;\n  return SqlString.formatNamedParameters(sql, parameters, timeZone, dialect);\n}\nexports.formatNamedParameters = formatNamedParameters;\n\nfunction cloneDeep(obj, onlyPlain) {\n  obj = obj || {};\n  return _.cloneDeepWith(obj, elem => {\n    // Do not try to customize cloning of arrays or POJOs\n    if (Array.isArray(elem) || _.isPlainObject(elem)) {\n      return undefined;\n    }\n\n    // If we specified to clone only plain objects & arrays, we ignore everyhing else\n    // In any case, don't clone stuff that's an object, but not a plain one - fx example sequelize models and instances\n    if (onlyPlain || typeof elem === 'object') {\n      return elem;\n    }\n\n    // Preserve special data-types like `fn` across clones. _.get() is used for checking up the prototype chain\n    if (elem && typeof elem.clone === 'function') {\n      return elem.clone();\n    }\n  });\n}\nexports.cloneDeep = cloneDeep;\n\n/* Expand and normalize finder options */\nfunction mapFinderOptions(options, Model) {\n  if (options.attributes && Array.isArray(options.attributes)) {\n    options.attributes = Model._injectDependentVirtualAttributes(options.attributes);\n    options.attributes = options.attributes.filter(v => !Model._virtualAttributes.has(v));\n  }\n\n  mapOptionFieldNames(options, Model);\n\n  return options;\n}\nexports.mapFinderOptions = mapFinderOptions;\n\n/* Used to map field names in attributes and where conditions */\nfunction mapOptionFieldNames(options, Model) {\n  if (Array.isArray(options.attributes)) {\n    options.attributes = options.attributes.map(attr => {\n      // Object lookups will force any variable to strings, we don't want that for special objects etc\n      if (typeof attr !== 'string') return attr;\n      // Map attributes to aliased syntax attributes\n      if (Model.rawAttributes[attr] && attr !== Model.rawAttributes[attr].field) {\n        return [Model.rawAttributes[attr].field, attr];\n      }\n      return attr;\n    });\n  }\n\n  if (options.where && _.isPlainObject(options.where)) {\n    options.where = mapWhereFieldNames(options.where, Model);\n  }\n\n  return options;\n}\nexports.mapOptionFieldNames = mapOptionFieldNames;\n\nfunction mapWhereFieldNames(attributes, Model) {\n  if (attributes) {\n    attributes = cloneDeep(attributes);\n    getComplexKeys(attributes).forEach(attribute => {\n      const rawAttribute = Model.rawAttributes[attribute];\n\n      if (rawAttribute && rawAttribute.field !== rawAttribute.fieldName) {\n        attributes[rawAttribute.field] = attributes[attribute];\n        delete attributes[attribute];\n      }\n\n      if (_.isPlainObject(attributes[attribute])\n        && !(rawAttribute && (\n          rawAttribute.type instanceof DataTypes.HSTORE\n          || rawAttribute.type instanceof DataTypes.JSON))) { // Prevent renaming of HSTORE & JSON fields\n        attributes[attribute] = mapOptionFieldNames({\n          where: attributes[attribute]\n        }, Model).where;\n      }\n\n      if (Array.isArray(attributes[attribute])) {\n        attributes[attribute].forEach((where, index) => {\n          if (_.isPlainObject(where)) {\n            attributes[attribute][index] = mapWhereFieldNames(where, Model);\n          }\n        });\n      }\n\n    });\n  }\n\n  return attributes;\n}\nexports.mapWhereFieldNames = mapWhereFieldNames;\n\n/* Used to map field names in values */\nfunction mapValueFieldNames(dataValues, fields, Model) {\n  const values = {};\n\n  for (const attr of fields) {\n    if (dataValues[attr] !== undefined && !Model._virtualAttributes.has(attr)) {\n      // Field name mapping\n      if (Model.rawAttributes[attr] && Model.rawAttributes[attr].field && Model.rawAttributes[attr].field !== attr) {\n        values[Model.rawAttributes[attr].field] = dataValues[attr];\n      } else {\n        values[attr] = dataValues[attr];\n      }\n    }\n  }\n\n  return values;\n}\nexports.mapValueFieldNames = mapValueFieldNames;\n\nfunction isColString(value) {\n  return typeof value === 'string' && value[0] === '$' && value[value.length - 1] === '$';\n}\nexports.isColString = isColString;\n\nfunction canTreatArrayAsAnd(arr) {\n  return arr.some(arg => _.isPlainObject(arg) || arg instanceof Where);\n}\nexports.canTreatArrayAsAnd = canTreatArrayAsAnd;\n\nfunction combineTableNames(tableName1, tableName2) {\n  return tableName1.toLowerCase() < tableName2.toLowerCase() ? tableName1 + tableName2 : tableName2 + tableName1;\n}\nexports.combineTableNames = combineTableNames;\n\nfunction toDefaultValue(value, dialect) {\n  if (typeof value === 'function') {\n    const tmp = value();\n    if (tmp instanceof DataTypes.ABSTRACT) {\n      return tmp.toSql();\n    }\n    return tmp;\n  }\n  if (value instanceof DataTypes.UUIDV1) {\n    return uuidv1();\n  }\n  if (value instanceof DataTypes.UUIDV4) {\n    return uuidv4();\n  }\n  if (value instanceof DataTypes.NOW) {\n    return now(dialect);\n  }\n  if (Array.isArray(value)) {\n    return value.slice();\n  }\n  if (_.isPlainObject(value)) {\n    return { ...value };\n  }\n  return value;\n}\nexports.toDefaultValue = toDefaultValue;\n\n/**\n * Determine if the default value provided exists and can be described\n * in a db schema using the DEFAULT directive.\n *\n * @param  {*} value Any default value.\n * @returns {boolean} yes / no.\n * @private\n */\nfunction defaultValueSchemable(value) {\n  if (value === undefined) { return false; }\n\n  // TODO this will be schemable when all supported db\n  // have been normalized for this case\n  if (value instanceof DataTypes.NOW) { return false; }\n\n  if (value instanceof DataTypes.UUIDV1 || value instanceof DataTypes.UUIDV4) { return false; }\n\n  return typeof value !== 'function';\n}\nexports.defaultValueSchemable = defaultValueSchemable;\n\nfunction removeNullValuesFromHash(hash, omitNull, options) {\n  let result = hash;\n\n  options = options || {};\n  options.allowNull = options.allowNull || [];\n\n  if (omitNull) {\n    const _hash = {};\n\n    _.forIn(hash, (val, key) => {\n      if (options.allowNull.includes(key) || key.endsWith('Id') || val !== null && val !== undefined) {\n        _hash[key] = val;\n      }\n    });\n\n    result = _hash;\n  }\n\n  return result;\n}\nexports.removeNullValuesFromHash = removeNullValuesFromHash;\n\nconst dialects = new Set(['mariadb', 'mysql', 'postgres', 'sqlite', 'mssql']);\n\nfunction now(dialect) {\n  const d = new Date();\n  if (!dialects.has(dialect)) {\n    d.setMilliseconds(0);\n  }\n  return d;\n}\nexports.now = now;\n\n// Note: Use the `quoteIdentifier()` and `escape()` methods on the\n// `QueryInterface` instead for more portable code.\n\nconst TICK_CHAR = '`';\nexports.TICK_CHAR = TICK_CHAR;\n\nfunction addTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return tickChar + removeTicks(s, tickChar) + tickChar;\n}\nexports.addTicks = addTicks;\n\nfunction removeTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return s.replace(new RegExp(tickChar, 'g'), '');\n}\nexports.removeTicks = removeTicks;\n\n/**\n * Receives a tree-like object and returns a plain object which depth is 1.\n *\n * - Input:\n *\n *  {\n *    name: 'John',\n *    address: {\n *      street: 'Fake St. 123',\n *      coordinates: {\n *        longitude: 55.6779627,\n *        latitude: 12.5964313\n *      }\n *    }\n *  }\n *\n * - Output:\n *\n *  {\n *    name: 'John',\n *    address.street: 'Fake St. 123',\n *    address.coordinates.latitude: 55.6779627,\n *    address.coordinates.longitude: 12.5964313\n *  }\n *\n * @param {object} value an Object\n * @returns {object} a flattened object\n * @private\n */\nfunction flattenObjectDeep(value) {\n  if (!_.isPlainObject(value)) return value;\n  const flattenedObj = {};\n\n  function flattenObject(obj, subPath) {\n    Object.keys(obj).forEach(key => {\n      const pathToProperty = subPath ? `${subPath}.${key}` : key;\n      if (typeof obj[key] === 'object' && obj[key] !== null) {\n        flattenObject(obj[key], pathToProperty);\n      } else {\n        flattenedObj[pathToProperty] = _.get(obj, key);\n      }\n    });\n    return flattenedObj;\n  }\n\n  return flattenObject(value, undefined);\n}\nexports.flattenObjectDeep = flattenObjectDeep;\n\n/**\n * Utility functions for representing SQL functions, and columns that should be escaped.\n * Please do not use these functions directly, use Sequelize.fn and Sequelize.col instead.\n *\n * @private\n */\nclass SequelizeMethod {}\nexports.SequelizeMethod = SequelizeMethod;\n\nclass Fn extends SequelizeMethod {\n  constructor(fn, args) {\n    super();\n    this.fn = fn;\n    this.args = args;\n  }\n  clone() {\n    return new Fn(this.fn, this.args);\n  }\n}\nexports.Fn = Fn;\n\nclass Col extends SequelizeMethod {\n  constructor(col, ...args) {\n    super();\n    if (args.length > 0) {\n      col = args;\n    }\n    this.col = col;\n  }\n}\nexports.Col = Col;\n\nclass Cast extends SequelizeMethod {\n  constructor(val, type, json) {\n    super();\n    this.val = val;\n    this.type = (type || '').trim();\n    this.json = json || false;\n  }\n}\nexports.Cast = Cast;\n\nclass Literal extends SequelizeMethod {\n  constructor(val) {\n    super();\n    this.val = val;\n  }\n}\nexports.Literal = Literal;\n\nclass Json extends SequelizeMethod {\n  constructor(conditionsOrPath, value) {\n    super();\n    if (_.isObject(conditionsOrPath)) {\n      this.conditions = conditionsOrPath;\n    } else {\n      this.path = conditionsOrPath;\n      if (value) {\n        this.value = value;\n      }\n    }\n  }\n}\nexports.Json = Json;\n\nclass Where extends SequelizeMethod {\n  constructor(attribute, comparator, logic) {\n    super();\n    if (logic === undefined) {\n      logic = comparator;\n      comparator = '=';\n    }\n\n    this.attribute = attribute;\n    this.comparator = comparator;\n    this.logic = logic;\n  }\n}\nexports.Where = Where;\n\n//Collection of helper methods to make it easier to work with symbol operators\n\n/**\n * getOperators\n *\n * @param  {object} obj\n * @returns {Array<symbol>} All operators properties of obj\n * @private\n */\nfunction getOperators(obj) {\n  return Object.getOwnPropertySymbols(obj).filter(s => operatorsSet.has(s));\n}\nexports.getOperators = getOperators;\n\n/**\n * getComplexKeys\n *\n * @param  {object} obj\n * @returns {Array<string|symbol>} All keys including operators\n * @private\n */\nfunction getComplexKeys(obj) {\n  return getOperators(obj).concat(Object.keys(obj));\n}\nexports.getComplexKeys = getComplexKeys;\n\n/**\n * getComplexSize\n *\n * @param  {object|Array} obj\n * @returns {number}      Length of object properties including operators if obj is array returns its length\n * @private\n */\nfunction getComplexSize(obj) {\n  return Array.isArray(obj) ? obj.length : getComplexKeys(obj).length;\n}\nexports.getComplexSize = getComplexSize;\n\n/**\n * Returns true if a where clause is empty, even with Symbols\n *\n * @param  {object} obj\n * @returns {boolean}\n * @private\n */\nfunction isWhereEmpty(obj) {\n  return !!obj && _.isEmpty(obj) && getOperators(obj).length === 0;\n}\nexports.isWhereEmpty = isWhereEmpty;\n\n/**\n * Returns ENUM name by joining table and column name\n *\n * @param {string} tableName\n * @param {string} columnName\n * @returns {string}\n * @private\n */\nfunction generateEnumName(tableName, columnName) {\n  return `enum_${tableName}_${columnName}`;\n}\nexports.generateEnumName = generateEnumName;\n\n/**\n * Returns an new Object which keys are camelized\n *\n * @param {object} obj\n * @returns {string}\n * @private\n */\nfunction camelizeObjectKeys(obj) {\n  const newObj = new Object();\n  Object.keys(obj).forEach(key => {\n    newObj[camelize(key)] = obj[key];\n  });\n  return newObj;\n}\nexports.camelizeObjectKeys = camelizeObjectKeys;\n\n/**\n * Assigns own and inherited enumerable string and symbol keyed properties of source\n * objects to the destination object.\n *\n * https://lodash.com/docs/4.17.4#defaults\n *\n * **Note:** This method mutates `object`.\n *\n * @param {object} object The destination object.\n * @param {...object} [sources] The source objects.\n * @returns {object} Returns `object`.\n * @private\n */\nfunction defaults(object, ...sources) {\n  object = Object(object);\n\n  sources.forEach(source => {\n    if (source) {\n      source = Object(source);\n\n      getComplexKeys(source).forEach(key => {\n        const value = object[key];\n        if (\n          value === undefined ||\n            _.eq(value, Object.prototype[key]) &&\n            !Object.prototype.hasOwnProperty.call(object, key)\n\n        ) {\n          object[key] = source[key];\n        }\n      });\n    }\n  });\n\n  return object;\n}\nexports.defaults = defaults;\n\n/**\n *\n * @param {object} index\n * @param {Array}  index.fields\n * @param {string} [index.name]\n * @param {string|object} tableName\n *\n * @returns {object}\n * @private\n */\nfunction nameIndex(index, tableName) {\n  if (tableName.tableName) tableName = tableName.tableName;\n\n  if (!Object.prototype.hasOwnProperty.call(index, 'name')) {\n    const fields = index.fields.map(\n      field => typeof field === 'string' ? field : field.name || field.attribute\n    );\n    index.name = underscore(`${tableName}_${fields.join('_')}`);\n  }\n\n  return index;\n}\nexports.nameIndex = nameIndex;\n\n/**\n * Checks if 2 arrays intersect.\n *\n * @param {Array} arr1\n * @param {Array} arr2\n * @private\n */\nfunction intersects(arr1, arr2) {\n  return arr1.some(v => arr2.includes(v));\n}\nexports.intersects = intersects;\n"]},"metadata":{},"sourceType":"script"}