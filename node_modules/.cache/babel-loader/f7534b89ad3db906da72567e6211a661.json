{"ast":null,"code":"\"use strict\";\n\nvar et = Object.defineProperty;\n\nvar s = (e, t) => et(e, \"name\", {\n  value: t,\n  configurable: !0\n});\n\nconst o = require(\"util\"),\n      c = require(\"lodash\"),\n      y = require(\"wkx\"),\n      n = require(\"./errors\"),\n      f = require(\"./utils/validator-extras\").validator,\n      _ = require(\"moment-timezone\"),\n      S = require(\"moment\"),\n      {\n  logger: st\n} = require(\"./utils/logger\"),\n      D = {},\n      {\n  classToInvokable: it\n} = require(\"./utils/class-to-invokable\"),\n      {\n  joinSQLFragments: T\n} = require(\"./utils/join-sql-fragments\");\n\nclass i {\n  toString(t) {\n    return this.toSql(t);\n  }\n\n  toSql() {\n    return this.key;\n  }\n\n  stringify(t, r) {\n    return this._stringify ? this._stringify(t, r) : t;\n  }\n\n  bindParam(t, r) {\n    return this._bindParam ? this._bindParam(t, r) : r.bindParam(this.stringify(t, r));\n  }\n\n  static toString() {\n    return this.name;\n  }\n\n  static warn(t, r) {\n    D[r] || (D[r] = !0, st.warn(`${r} \n>> Check: ${t}`));\n  }\n\n  static extend(t) {\n    return new this(t.options);\n  }\n\n}\n\ns(i, \"ABSTRACT\"), i.prototype.dialectTypes = \"\";\n\nclass b extends i {\n  constructor(t, r) {\n    super();\n    const a = typeof t == \"object\" && t || {\n      length: t,\n      binary: r\n    };\n    this.options = a, this._binary = a.binary, this._length = a.length || 255;\n  }\n\n  toSql() {\n    return T([`VARCHAR(${this._length})`, this._binary && \"BINARY\"]);\n  }\n\n  validate(t) {\n    if (Object.prototype.toString.call(t) !== \"[object String]\") {\n      if (this.options.binary && Buffer.isBuffer(t) || typeof t == \"number\") return !0;\n      throw new n.ValidationError(o.format(\"%j is not a valid string\", t));\n    }\n\n    return !0;\n  }\n\n  get BINARY() {\n    return this._binary = !0, this.options.binary = !0, this;\n  }\n\n  static get BINARY() {\n    return new this().BINARY;\n  }\n\n}\n\ns(b, \"STRING\");\n\nclass A extends b {\n  constructor(t, r) {\n    super(typeof t == \"object\" && t || {\n      length: t,\n      binary: r\n    });\n  }\n\n  toSql() {\n    return T([`CHAR(${this._length})`, this._binary && \"BINARY\"]);\n  }\n\n}\n\ns(A, \"CHAR\");\n\nclass B extends i {\n  constructor(t) {\n    super();\n    const r = typeof t == \"object\" && t || {\n      length: t\n    };\n    this.options = r, this._length = r.length || \"\";\n  }\n\n  toSql() {\n    switch (this._length.toLowerCase()) {\n      case \"tiny\":\n        return \"TINYTEXT\";\n\n      case \"medium\":\n        return \"MEDIUMTEXT\";\n\n      case \"long\":\n        return \"LONGTEXT\";\n\n      default:\n        return this.key;\n    }\n  }\n\n  validate(t) {\n    if (typeof t != \"string\") throw new n.ValidationError(o.format(\"%j is not a valid string\", t));\n    return !0;\n  }\n\n}\n\ns(B, \"TEXT\");\n\nclass k extends i {\n  toSql() {\n    return \"CITEXT\";\n  }\n\n  validate(t) {\n    if (typeof t != \"string\") throw new n.ValidationError(o.format(\"%j is not a valid string\", t));\n    return !0;\n  }\n\n}\n\ns(k, \"CITEXT\");\n\nclass u extends i {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    typeof t == \"number\" && (t = {\n      length: t\n    }), this.options = t, this._length = t.length, this._zerofill = t.zerofill, this._decimals = t.decimals, this._precision = t.precision, this._scale = t.scale, this._unsigned = t.unsigned;\n  }\n\n  toSql() {\n    let t = this.key;\n    return this._length && (t += `(${this._length}`, typeof this._decimals == \"number\" && (t += `,${this._decimals}`), t += \")\"), this._unsigned && (t += \" UNSIGNED\"), this._zerofill && (t += \" ZEROFILL\"), t;\n  }\n\n  validate(t) {\n    if (!f.isFloat(String(t))) throw new n.ValidationError(o.format(`%j is not a valid ${this.key.toLowerCase()}`, t));\n    return !0;\n  }\n\n  _stringify(t) {\n    return typeof t == \"number\" || typeof t == \"boolean\" || t === null || t === void 0 ? t : typeof t.toString == \"function\" ? t.toString() : t;\n  }\n\n  get UNSIGNED() {\n    return this._unsigned = !0, this.options.unsigned = !0, this;\n  }\n\n  get ZEROFILL() {\n    return this._zerofill = !0, this.options.zerofill = !0, this;\n  }\n\n  static get UNSIGNED() {\n    return new this().UNSIGNED;\n  }\n\n  static get ZEROFILL() {\n    return new this().ZEROFILL;\n  }\n\n}\n\ns(u, \"NUMBER\");\n\nclass l extends u {\n  validate(t) {\n    if (!f.isInt(String(t))) throw new n.ValidationError(o.format(`%j is not a valid ${this.key.toLowerCase()}`, t));\n    return !0;\n  }\n\n}\n\ns(l, \"INTEGER\");\n\nclass L extends l {}\n\ns(L, \"TINYINT\");\n\nclass z extends l {}\n\ns(z, \"SMALLINT\");\n\nclass P extends l {}\n\ns(P, \"MEDIUMINT\");\n\nclass Y extends l {}\n\ns(Y, \"BIGINT\");\n\nclass x extends u {\n  constructor(t, r) {\n    super(typeof t == \"object\" && t || {\n      length: t,\n      decimals: r\n    });\n  }\n\n  validate(t) {\n    if (!f.isFloat(String(t))) throw new n.ValidationError(o.format(\"%j is not a valid float\", t));\n    return !0;\n  }\n\n}\n\ns(x, \"FLOAT\");\n\nclass E extends u {\n  constructor(t, r) {\n    super(typeof t == \"object\" && t || {\n      length: t,\n      decimals: r\n    });\n  }\n\n}\n\ns(E, \"REAL\");\n\nclass p extends u {\n  constructor(t, r) {\n    super(typeof t == \"object\" && t || {\n      length: t,\n      decimals: r\n    });\n  }\n\n}\n\ns(p, \"DOUBLE\");\n\nclass j extends u {\n  constructor(t, r) {\n    super(typeof t == \"object\" && t || {\n      precision: t,\n      scale: r\n    });\n  }\n\n  toSql() {\n    return this._precision || this._scale ? `DECIMAL(${[this._precision, this._scale].filter(c.identity).join(\",\")})` : \"DECIMAL\";\n  }\n\n  validate(t) {\n    if (!f.isDecimal(String(t))) throw new n.ValidationError(o.format(\"%j is not a valid decimal\", t));\n    return !0;\n  }\n\n}\n\ns(j, \"DECIMAL\");\nconst nt = {\n  escape: !1,\n\n  _value(e) {\n    return isNaN(e) ? \"NaN\" : isFinite(e) ? e : `${e < 0 ? \"-\" : \"\"}Infinity`;\n  },\n\n  _stringify(e) {\n    return `'${this._value(e)}'`;\n  },\n\n  _bindParam(e, t) {\n    return t.bindParam(this._value(e));\n  }\n\n};\n\nfor (const e of [x, p, E]) Object.assign(e.prototype, nt);\n\nclass m extends i {\n  toSql() {\n    return \"TINYINT(1)\";\n  }\n\n  validate(t) {\n    if (!f.isBoolean(String(t))) throw new n.ValidationError(o.format(\"%j is not a valid boolean\", t));\n    return !0;\n  }\n\n  _sanitize(t) {\n    if (t != null) {\n      Buffer.isBuffer(t) && t.length === 1 && (t = t[0]);\n      const r = typeof t;\n      if (r === \"string\") return t === \"true\" ? !0 : t === \"false\" ? !1 : t;\n      if (r === \"number\") return t === 1 ? !0 : t === 0 ? !1 : t;\n    }\n\n    return t;\n  }\n\n}\n\ns(m, \"BOOLEAN\"), m.parse = m.prototype._sanitize;\n\nclass G extends i {\n  toSql() {\n    return \"TIME\";\n  }\n\n}\n\ns(G, \"TIME\");\n\nclass M extends i {\n  constructor(t) {\n    super();\n    const r = typeof t == \"object\" && t || {\n      length: t\n    };\n    this.options = r, this._length = r.length || \"\";\n  }\n\n  toSql() {\n    return \"DATETIME\";\n  }\n\n  validate(t) {\n    if (!f.isDate(String(t))) throw new n.ValidationError(o.format(\"%j is not a valid date\", t));\n    return !0;\n  }\n\n  _sanitize(t, r) {\n    return (!r || r && !r.raw) && !(t instanceof Date) && !!t ? new Date(t) : t;\n  }\n\n  _isChanged(t, r) {\n    return !(r && !!t && (t === r || t instanceof Date && r instanceof Date && t.getTime() === r.getTime()) || !r && !t && r === t);\n  }\n\n  _applyTimezone(t, r) {\n    return r.timezone ? _.tz.zone(r.timezone) ? _(t).tz(r.timezone) : t = S(t).utcOffset(r.timezone) : _(t);\n  }\n\n  _stringify(t, r) {\n    return t = this._applyTimezone(t, r), t.format(\"YYYY-MM-DD HH:mm:ss.SSS Z\");\n  }\n\n}\n\ns(M, \"DATE\");\n\nclass C extends i {\n  toSql() {\n    return \"DATE\";\n  }\n\n  _stringify(t) {\n    return S(t).format(\"YYYY-MM-DD\");\n  }\n\n  _sanitize(t, r) {\n    return (!r || r && !r.raw) && !!t ? S(t).format(\"YYYY-MM-DD\") : t;\n  }\n\n  _isChanged(t, r) {\n    return !(r && !!t && r === t || !r && !t && r === t);\n  }\n\n}\n\ns(C, \"DATEONLY\");\n\nclass $ extends i {\n  validate(t) {\n    if (!c.isPlainObject(t)) throw new n.ValidationError(o.format(\"%j is not a valid hstore\", t));\n    return !0;\n  }\n\n}\n\ns($, \"HSTORE\");\n\nclass q extends i {\n  validate() {\n    return !0;\n  }\n\n  _stringify(t) {\n    return JSON.stringify(t);\n  }\n\n}\n\ns(q, \"JSONTYPE\");\n\nclass V extends q {}\n\ns(V, \"JSONB\");\n\nclass U extends i {}\n\ns(U, \"NOW\");\n\nclass I extends i {\n  constructor(t) {\n    super();\n    const r = typeof t == \"object\" && t || {\n      length: t\n    };\n    this.options = r, this._length = r.length || \"\";\n  }\n\n  toSql() {\n    switch (this._length.toLowerCase()) {\n      case \"tiny\":\n        return \"TINYBLOB\";\n\n      case \"medium\":\n        return \"MEDIUMBLOB\";\n\n      case \"long\":\n        return \"LONGBLOB\";\n\n      default:\n        return this.key;\n    }\n  }\n\n  validate(t) {\n    if (typeof t != \"string\" && !Buffer.isBuffer(t)) throw new n.ValidationError(o.format(\"%j is not a valid blob\", t));\n    return !0;\n  }\n\n  _stringify(t) {\n    Buffer.isBuffer(t) || (Array.isArray(t) ? t = Buffer.from(t) : t = Buffer.from(t.toString()));\n    const r = t.toString(\"hex\");\n    return this._hexify(r);\n  }\n\n  _hexify(t) {\n    return `X'${t}'`;\n  }\n\n  _bindParam(t, r) {\n    return Buffer.isBuffer(t) || (Array.isArray(t) ? t = Buffer.from(t) : t = Buffer.from(t.toString())), r.bindParam(t);\n  }\n\n}\n\ns(I, \"BLOB\"), I.prototype.escape = !1;\n\nclass F extends i {\n  constructor(t) {\n    super();\n    const r = c.isPlainObject(t) ? t : {\n      subtype: t\n    };\n    r.subtype || (r.subtype = new l()), typeof r.subtype == \"function\" && (r.subtype = new r.subtype()), this._subtype = r.subtype.key, this.options = r;\n  }\n\n  validate(t) {\n    if (!Array.isArray(t)) throw new n.ValidationError(o.format(\"%j is not a valid range\", t));\n    if (t.length !== 2) throw new n.ValidationError(\"A range must be an array with two elements\");\n    return !0;\n  }\n\n}\n\ns(F, \"RANGE\");\n\nclass R extends i {\n  validate(t, r) {\n    if (typeof t != \"string\" || !f.isUUID(t) && (!r || !r.acceptStrings)) throw new n.ValidationError(o.format(\"%j is not a valid uuid\", t));\n    return !0;\n  }\n\n}\n\ns(R, \"UUID\");\n\nclass J extends i {\n  validate(t, r) {\n    if (typeof t != \"string\" || !f.isUUID(t) && (!r || !r.acceptStrings)) throw new n.ValidationError(o.format(\"%j is not a valid uuid\", t));\n    return !0;\n  }\n\n}\n\ns(J, \"UUIDV1\");\n\nclass X extends i {\n  validate(t, r) {\n    if (typeof t != \"string\" || !f.isUUID(t, 4) && (!r || !r.acceptStrings)) throw new n.ValidationError(o.format(\"%j is not a valid uuidv4\", t));\n    return !0;\n  }\n\n}\n\ns(X, \"UUIDV4\");\n\nclass Z extends i {\n  constructor(t, r) {\n    super();\n    typeof t == \"function\" && (t = new t()), this.returnType = t, this.fields = r;\n  }\n\n}\n\ns(Z, \"VIRTUAL\");\n\nclass H extends i {\n  constructor() {\n    super();\n\n    for (var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++) {\n      t[_key] = arguments[_key];\n    }\n\n    const r = t[0],\n          a = typeof r == \"object\" && !Array.isArray(r) && r || {\n      values: t.reduce((rt, w) => rt.concat(Array.isArray(w) ? w : [w]), [])\n    };\n    this.values = a.values, this.options = a;\n  }\n\n  validate(t) {\n    if (!this.values.includes(t)) throw new n.ValidationError(o.format(\"%j is not a valid choice in %j\", t, this.values));\n    return !0;\n  }\n\n}\n\ns(H, \"ENUM\");\n\nclass g extends i {\n  constructor(t) {\n    super();\n    const r = c.isPlainObject(t) ? t : {\n      type: t\n    };\n    this.options = r, this.type = typeof r.type == \"function\" ? new r.type() : r.type;\n  }\n\n  toSql() {\n    return `${this.type.toSql()}[]`;\n  }\n\n  validate(t) {\n    if (!Array.isArray(t)) throw new n.ValidationError(o.format(\"%j is not a valid array\", t));\n    return !0;\n  }\n\n  static is(t, r) {\n    return t instanceof g && t.type instanceof r;\n  }\n\n}\n\ns(g, \"ARRAY\");\n\nclass N extends i {\n  constructor(t, r) {\n    super();\n    const a = c.isPlainObject(t) ? t : {\n      type: t,\n      srid: r\n    };\n    this.options = a, this.type = a.type, this.srid = a.srid;\n  }\n\n  _stringify(t, r) {\n    return `ST_GeomFromText(${r.escape(y.Geometry.parseGeoJSON(t).toWkt())})`;\n  }\n\n  _bindParam(t, r) {\n    return `ST_GeomFromText(${r.bindParam(y.Geometry.parseGeoJSON(t).toWkt())})`;\n  }\n\n}\n\ns(N, \"GEOMETRY\"), N.prototype.escape = !1;\n\nclass O extends i {\n  constructor(t, r) {\n    super();\n    const a = c.isPlainObject(t) ? t : {\n      type: t,\n      srid: r\n    };\n    this.options = a, this.type = a.type, this.srid = a.srid;\n  }\n\n  _stringify(t, r) {\n    return `ST_GeomFromText(${r.escape(y.Geometry.parseGeoJSON(t).toWkt())})`;\n  }\n\n  _bindParam(t, r) {\n    return `ST_GeomFromText(${r.bindParam(y.Geometry.parseGeoJSON(t).toWkt())})`;\n  }\n\n}\n\ns(O, \"GEOGRAPHY\"), O.prototype.escape = !1;\n\nclass W extends i {\n  validate(t) {\n    if (typeof t != \"string\" || !f.isIPRange(t)) throw new n.ValidationError(o.format(\"%j is not a valid CIDR\", t));\n    return !0;\n  }\n\n}\n\ns(W, \"CIDR\");\n\nclass Q extends i {\n  validate(t) {\n    if (typeof t != \"string\" || !f.isIP(t)) throw new n.ValidationError(o.format(\"%j is not a valid INET\", t));\n    return !0;\n  }\n\n}\n\ns(Q, \"INET\");\n\nclass K extends i {\n  validate(t) {\n    if (typeof t != \"string\" || !f.isMACAddress(t)) throw new n.ValidationError(o.format(\"%j is not a valid MACADDR\", t));\n    return !0;\n  }\n\n}\n\ns(K, \"MACADDR\");\n\nclass v extends i {\n  validate(t) {\n    if (typeof t != \"string\") throw new n.ValidationError(o.format(\"%j is not a valid string\", t));\n    return !0;\n  }\n\n}\n\ns(v, \"TSVECTOR\");\nconst d = module.exports = {\n  ABSTRACT: i,\n  STRING: b,\n  CHAR: A,\n  TEXT: B,\n  NUMBER: u,\n  TINYINT: L,\n  SMALLINT: z,\n  MEDIUMINT: P,\n  INTEGER: l,\n  BIGINT: Y,\n  FLOAT: x,\n  TIME: G,\n  DATE: M,\n  DATEONLY: C,\n  BOOLEAN: m,\n  NOW: U,\n  BLOB: I,\n  DECIMAL: j,\n  NUMERIC: j,\n  UUID: R,\n  UUIDV1: J,\n  UUIDV4: X,\n  HSTORE: $,\n  JSON: q,\n  JSONB: V,\n  VIRTUAL: Z,\n  ARRAY: g,\n  ENUM: H,\n  RANGE: F,\n  REAL: E,\n  \"DOUBLE PRECISION\": p,\n  DOUBLE: p,\n  GEOMETRY: N,\n  GEOGRAPHY: O,\n  CIDR: W,\n  INET: Q,\n  MACADDR: K,\n  CITEXT: k,\n  TSVECTOR: v\n};\nc.each(d, (e, t) => {\n  Object.prototype.hasOwnProperty.call(e, \"key\") || (e.types = {}, e.key = e.prototype.key = t);\n});\nconst h = {};\nh.postgres = require(\"./dialects/postgres/data-types\")(d), h.mysql = require(\"./dialects/mysql/data-types\")(d), h.mariadb = require(\"./dialects/mariadb/data-types\")(d), h.sqlite = require(\"./dialects/sqlite/data-types\")(d), h.mssql = require(\"./dialects/mssql/data-types\")(d);\nconst tt = Object.values(h);\n\nfor (const e of tt) c.each(e, (t, r) => {\n  t.key || (t.key = t.prototype.key = r);\n});\n\nfor (const e of [d, ...tt]) c.each(e, (t, r) => {\n  e[r] = it(t);\n});\n\nObject.assign(d, h);","map":{"version":3,"sources":["../../lib/data-types.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst util = require('util');\nconst _ = require('lodash');\nconst wkx = require('wkx');\nconst sequelizeErrors = require('./errors');\nconst Validator = require('./utils/validator-extras').validator;\nconst momentTz = require('moment-timezone');\nconst moment = require('moment');\nconst { logger } = require('./utils/logger');\nconst warnings = {};\nconst { classToInvokable } = require('./utils/class-to-invokable');\nconst { joinSQLFragments } = require('./utils/join-sql-fragments');\n\nclass ABSTRACT {\n  toString(options) {\n    return this.toSql(options);\n  }\n  toSql() {\n    return this.key;\n  }\n  stringify(value, options) {\n    if (this._stringify) {\n      return this._stringify(value, options);\n    }\n    return value;\n  }\n  bindParam(value, options) {\n    if (this._bindParam) {\n      return this._bindParam(value, options);\n    }\n    return options.bindParam(this.stringify(value, options));\n  }\n  static toString() {\n    return this.name;\n  }\n  static warn(link, text) {\n    if (!warnings[text]) {\n      warnings[text] = true;\n      logger.warn(`${text} \\n>> Check: ${link}`);\n    }\n  }\n  static extend(oldType) {\n    return new this(oldType.options);\n  }\n}\n\nABSTRACT.prototype.dialectTypes = '';\n\n/**\n * STRING A variable length string\n */\nclass STRING extends ABSTRACT {\n  /**\n   * @param {number} [length=255] length of string\n   * @param {boolean} [binary=false] Is this binary?\n   */\n  constructor(length, binary) {\n    super();\n    const options = typeof length === 'object' && length || { length, binary };\n    this.options = options;\n    this._binary = options.binary;\n    this._length = options.length || 255;\n  }\n  toSql() {\n    return joinSQLFragments([\n      `VARCHAR(${this._length})`,\n      this._binary && 'BINARY'\n    ]);\n  }\n  validate(value) {\n    if (Object.prototype.toString.call(value) !== '[object String]') {\n      if (this.options.binary && Buffer.isBuffer(value) || typeof value === 'number') {\n        return true;\n      }\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));\n    }\n    return true;\n  }\n\n  get BINARY() {\n    this._binary = true;\n    this.options.binary = true;\n    return this;\n  }\n\n  static get BINARY() {\n    return new this().BINARY;\n  }\n}\n\n/**\n * CHAR A fixed length string\n */\nclass CHAR extends STRING {\n  /**\n   * @param {number} [length=255] length of string\n   * @param {boolean} [binary=false] Is this binary?\n   */\n  constructor(length, binary) {\n    super(typeof length === 'object' && length || { length, binary });\n  }\n  toSql() {\n    return joinSQLFragments([\n      `CHAR(${this._length})`,\n      this._binary && 'BINARY'\n    ]);\n  }\n}\n\n/**\n * Unlimited length TEXT column\n */\nclass TEXT extends ABSTRACT {\n  /**\n   * @param {string} [length=''] could be tiny, medium, long.\n   */\n  constructor(length) {\n    super();\n    const options = typeof length === 'object' && length || { length };\n    this.options = options;\n    this._length = options.length || '';\n  }\n  toSql() {\n    switch (this._length.toLowerCase()) {\n      case 'tiny':\n        return 'TINYTEXT';\n      case 'medium':\n        return 'MEDIUMTEXT';\n      case 'long':\n        return 'LONGTEXT';\n      default:\n        return this.key;\n    }\n  }\n  validate(value) {\n    if (typeof value !== 'string') {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));\n    }\n    return true;\n  }\n}\n\n/**\n * An unlimited length case-insensitive text column.\n * Original case is preserved but acts case-insensitive when comparing values (such as when finding or unique constraints).\n * Only available in Postgres and SQLite.\n *\n */\nclass CITEXT extends ABSTRACT {\n  toSql() {\n    return 'CITEXT';\n  }\n  validate(value) {\n    if (typeof value !== 'string') {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));\n    }\n    return true;\n  }\n}\n\n/**\n * Base number type which is used to build other types\n */\nclass NUMBER extends ABSTRACT {\n  /**\n   * @param {object} options type options\n   * @param {string|number} [options.length] length of type, like `INT(4)`\n   * @param {boolean} [options.zerofill] Is zero filled?\n   * @param {boolean} [options.unsigned] Is unsigned?\n   * @param {string|number} [options.decimals] number of decimal points, used with length `FLOAT(5, 4)`\n   * @param {string|number} [options.precision] defines precision for decimal type\n   * @param {string|number} [options.scale] defines scale for decimal type\n   */\n  constructor(options = {}) {\n    super();\n    if (typeof options === 'number') {\n      options = {\n        length: options\n      };\n    }\n    this.options = options;\n    this._length = options.length;\n    this._zerofill = options.zerofill;\n    this._decimals = options.decimals;\n    this._precision = options.precision;\n    this._scale = options.scale;\n    this._unsigned = options.unsigned;\n  }\n  toSql() {\n    let result = this.key;\n    if (this._length) {\n      result += `(${this._length}`;\n      if (typeof this._decimals === 'number') {\n        result += `,${this._decimals}`;\n      }\n      result += ')';\n    }\n    if (this._unsigned) {\n      result += ' UNSIGNED';\n    }\n    if (this._zerofill) {\n      result += ' ZEROFILL';\n    }\n    return result;\n  }\n  validate(value) {\n    if (!Validator.isFloat(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));\n    }\n    return true;\n  }\n  _stringify(number) {\n    if (typeof number === 'number' || typeof number === 'boolean' || number === null || number === undefined) {\n      return number;\n    }\n    if (typeof number.toString === 'function') {\n      return number.toString();\n    }\n    return number;\n  }\n\n  get UNSIGNED() {\n    this._unsigned = true;\n    this.options.unsigned = true;\n    return this;\n  }\n\n  get ZEROFILL() {\n    this._zerofill = true;\n    this.options.zerofill = true;\n    return this;\n  }\n\n  static get UNSIGNED() {\n    return new this().UNSIGNED;\n  }\n\n  static get ZEROFILL() {\n    return new this().ZEROFILL;\n  }\n}\n\n/**\n * A 32 bit integer\n */\nclass INTEGER extends NUMBER {\n  validate(value) {\n    if (!Validator.isInt(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));\n    }\n    return true;\n  }\n}\n\n/**\n * A 8 bit integer\n */\nclass TINYINT extends INTEGER {\n}\n\n/**\n * A 16 bit integer\n */\nclass SMALLINT extends INTEGER {\n}\n\n/**\n * A 24 bit integer\n */\nclass MEDIUMINT extends INTEGER {\n}\n\n/**\n * A 64 bit integer\n */\nclass BIGINT extends INTEGER {\n}\n\n/**\n * Floating point number (4-byte precision).\n */\nclass FLOAT extends NUMBER {\n  /**\n   * @param {string|number} [length] length of type, like `FLOAT(4)`\n   * @param {string|number} [decimals] number of decimal points, used with length `FLOAT(5, 4)`\n   */\n  constructor(length, decimals) {\n    super(typeof length === 'object' && length || { length, decimals });\n  }\n  validate(value) {\n    if (!Validator.isFloat(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid float', value));\n    }\n    return true;\n  }\n}\n\n/**\n * Floating point number (4-byte precision).\n */\nclass REAL extends NUMBER {\n  /**\n   * @param {string|number} [length] length of type, like `REAL(4)`\n   * @param {string|number} [decimals] number of decimal points, used with length `REAL(5, 4)`\n   */\n  constructor(length, decimals) {\n    super(typeof length === 'object' && length || { length, decimals });\n  }\n}\n\n/**\n * Floating point number (8-byte precision).\n */\nclass DOUBLE extends NUMBER {\n  /**\n   * @param {string|number} [length] length of type, like `DOUBLE PRECISION(25)`\n   * @param {string|number} [decimals] number of decimal points, used with length `DOUBLE PRECISION(25, 10)`\n   */\n  constructor(length, decimals) {\n    super(typeof length === 'object' && length || { length, decimals });\n  }\n}\n\n/**\n * Decimal type, variable precision, take length as specified by user\n */\nclass DECIMAL extends NUMBER {\n  /**\n   * @param {string|number} [precision] defines precision\n   * @param {string|number} [scale] defines scale\n   */\n  constructor(precision, scale) {\n    super(typeof precision === 'object' && precision || { precision, scale });\n  }\n  toSql() {\n    if (this._precision || this._scale) {\n      return `DECIMAL(${[this._precision, this._scale].filter(_.identity).join(',')})`;\n    }\n    return 'DECIMAL';\n  }\n  validate(value) {\n    if (!Validator.isDecimal(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid decimal', value));\n    }\n    return true;\n  }\n}\n\n// TODO: Create intermediate class\nconst protoExtensions = {\n  escape: false,\n  _value(value) {\n    if (isNaN(value)) {\n      return 'NaN';\n    }\n    if (!isFinite(value)) {\n      const sign = value < 0 ? '-' : '';\n      return `${sign}Infinity`;\n    }\n\n    return value;\n  },\n  _stringify(value) {\n    return `'${this._value(value)}'`;\n  },\n  _bindParam(value, options) {\n    return options.bindParam(this._value(value));\n  }\n};\n\nfor (const floating of [FLOAT, DOUBLE, REAL]) {\n  Object.assign(floating.prototype, protoExtensions);\n}\n\n/**\n * A boolean / tinyint column, depending on dialect\n */\nclass BOOLEAN extends ABSTRACT {\n  toSql() {\n    return 'TINYINT(1)';\n  }\n  validate(value) {\n    if (!Validator.isBoolean(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid boolean', value));\n    }\n    return true;\n  }\n  _sanitize(value) {\n    if (value !== null && value !== undefined) {\n      if (Buffer.isBuffer(value) && value.length === 1) {\n        // Bit fields are returned as buffers\n        value = value[0];\n      }\n      const type = typeof value;\n      if (type === 'string') {\n        // Only take action on valid boolean strings.\n        return value === 'true' ? true : value === 'false' ? false : value;\n      }\n      if (type === 'number') {\n        // Only take action on valid boolean integers.\n        return value === 1 ? true : value === 0 ? false : value;\n      }\n    }\n    return value;\n  }\n}\n\n\nBOOLEAN.parse = BOOLEAN.prototype._sanitize;\n\n/**\n * A time column\n *\n */\nclass TIME extends ABSTRACT {\n  toSql() {\n    return 'TIME';\n  }\n}\n\n/**\n * Date column with timezone, default is UTC\n */\nclass DATE extends ABSTRACT {\n  /**\n   * @param {string|number} [length] precision to allow storing milliseconds\n   */\n  constructor(length) {\n    super();\n    const options = typeof length === 'object' && length || { length };\n    this.options = options;\n    this._length = options.length || '';\n  }\n  toSql() {\n    return 'DATETIME';\n  }\n  validate(value) {\n    if (!Validator.isDate(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid date', value));\n    }\n    return true;\n  }\n  _sanitize(value, options) {\n    if ((!options || options && !options.raw) && !(value instanceof Date) && !!value) {\n      return new Date(value);\n    }\n    return value;\n  }\n  _isChanged(value, originalValue) {\n    if (originalValue && !!value &&\n      (value === originalValue ||\n        value instanceof Date && originalValue instanceof Date && value.getTime() === originalValue.getTime())) {\n      return false;\n    }\n    // not changed when set to same empty value\n    if (!originalValue && !value && originalValue === value) {\n      return false;\n    }\n    return true;\n  }\n  _applyTimezone(date, options) {\n    if (options.timezone) {\n      if (momentTz.tz.zone(options.timezone)) {\n        return momentTz(date).tz(options.timezone);\n      }\n      return date = moment(date).utcOffset(options.timezone);\n    }\n    return momentTz(date);\n  }\n  _stringify(date, options) {\n    date = this._applyTimezone(date, options);\n    // Z here means current timezone, _not_ UTC\n    return date.format('YYYY-MM-DD HH:mm:ss.SSS Z');\n  }\n}\n\n/**\n * A date only column (no timestamp)\n */\nclass DATEONLY extends ABSTRACT {\n  toSql() {\n    return 'DATE';\n  }\n  _stringify(date) {\n    return moment(date).format('YYYY-MM-DD');\n  }\n  _sanitize(value, options) {\n    if ((!options || options && !options.raw) && !!value) {\n      return moment(value).format('YYYY-MM-DD');\n    }\n    return value;\n  }\n  _isChanged(value, originalValue) {\n    if (originalValue && !!value && originalValue === value) {\n      return false;\n    }\n    // not changed when set to same empty value\n    if (!originalValue && !value && originalValue === value) {\n      return false;\n    }\n    return true;\n  }\n}\n\n/**\n * A key / value store column. Only available in Postgres.\n */\nclass HSTORE extends ABSTRACT {\n  validate(value) {\n    if (!_.isPlainObject(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid hstore', value));\n    }\n    return true;\n  }\n}\n\n/**\n * A JSON string column. Available in MySQL, Postgres and SQLite\n */\nclass JSONTYPE extends ABSTRACT {\n  validate() {\n    return true;\n  }\n  _stringify(value) {\n    return JSON.stringify(value);\n  }\n}\n\n/**\n * A binary storage JSON column. Only available in Postgres.\n */\nclass JSONB extends JSONTYPE {\n}\n\n/**\n * A default value of the current timestamp\n */\nclass NOW extends ABSTRACT {\n}\n\n/**\n * Binary storage\n */\nclass BLOB extends ABSTRACT {\n  /**\n   * @param {string} [length=''] could be tiny, medium, long.\n   */\n  constructor(length) {\n    super();\n    const options = typeof length === 'object' && length || { length };\n    this.options = options;\n    this._length = options.length || '';\n  }\n  toSql() {\n    switch (this._length.toLowerCase()) {\n      case 'tiny':\n        return 'TINYBLOB';\n      case 'medium':\n        return 'MEDIUMBLOB';\n      case 'long':\n        return 'LONGBLOB';\n      default:\n        return this.key;\n    }\n  }\n  validate(value) {\n    if (typeof value !== 'string' && !Buffer.isBuffer(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid blob', value));\n    }\n    return true;\n  }\n  _stringify(value) {\n    if (!Buffer.isBuffer(value)) {\n      if (Array.isArray(value)) {\n        value = Buffer.from(value);\n      }\n      else {\n        value = Buffer.from(value.toString());\n      }\n    }\n    const hex = value.toString('hex');\n    return this._hexify(hex);\n  }\n  _hexify(hex) {\n    return `X'${hex}'`;\n  }\n  _bindParam(value, options) {\n    if (!Buffer.isBuffer(value)) {\n      if (Array.isArray(value)) {\n        value = Buffer.from(value);\n      }\n      else {\n        value = Buffer.from(value.toString());\n      }\n    }\n    return options.bindParam(value);\n  }\n}\n\n\nBLOB.prototype.escape = false;\n\n/**\n * Range types are data types representing a range of values of some element type (called the range's subtype).\n * Only available in Postgres. See [the Postgres documentation](http://www.postgresql.org/docs/9.4/static/rangetypes.html) for more details\n */\nclass RANGE extends ABSTRACT {\n  /**\n   * @param {ABSTRACT} subtype A subtype for range, like RANGE(DATE)\n   */\n  constructor(subtype) {\n    super();\n    const options = _.isPlainObject(subtype) ? subtype : { subtype };\n    if (!options.subtype)\n      options.subtype = new INTEGER();\n    if (typeof options.subtype === 'function') {\n      options.subtype = new options.subtype();\n    }\n    this._subtype = options.subtype.key;\n    this.options = options;\n  }\n  validate(value) {\n    if (!Array.isArray(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid range', value));\n    }\n    if (value.length !== 2) {\n      throw new sequelizeErrors.ValidationError('A range must be an array with two elements');\n    }\n    return true;\n  }\n}\n\n/**\n * A column storing a unique universal identifier.\n * Use with `UUIDV1` or `UUIDV4` for default values.\n */\nclass UUID extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== 'string' || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuid', value));\n    }\n    return true;\n  }\n}\n\n/**\n * A default unique universal identifier generated following the UUID v1 standard\n */\nclass UUIDV1 extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== 'string' || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuid', value));\n    }\n    return true;\n  }\n}\n\n/**\n * A default unique universal identifier generated following the UUID v4 standard\n */\nclass UUIDV4 extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== 'string' || !Validator.isUUID(value, 4) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuidv4', value));\n    }\n    return true;\n  }\n}\n\n/**\n * A virtual value that is not stored in the DB. This could for example be useful if you want to provide a default value in your model that is returned to the user but not stored in the DB.\n *\n * You could also use it to validate a value before permuting and storing it. VIRTUAL also takes a return type and dependency fields as arguments\n * If a virtual attribute is present in `attributes` it will automatically pull in the extra fields as well.\n * Return type is mostly useful for setups that rely on types like GraphQL.\n *\n * @example <caption>Checking password length before hashing it</caption>\n * sequelize.define('user', {\n *   password_hash: DataTypes.STRING,\n *   password: {\n *     type: DataTypes.VIRTUAL,\n *     set: function (val) {\n *        // Remember to set the data value, otherwise it won't be validated\n *        this.setDataValue('password', val);\n *        this.setDataValue('password_hash', this.salt + val);\n *      },\n *      validate: {\n *         isLongEnough: function (val) {\n *           if (val.length < 7) {\n *             throw new Error(\"Please choose a longer password\")\n *          }\n *       }\n *     }\n *   }\n * })\n *\n * # In the above code the password is stored plainly in the password field so it can be validated, but is never stored in the DB.\n *\n * @example <caption>Virtual with dependency fields</caption>\n * {\n *   active: {\n *     type: new DataTypes.VIRTUAL(DataTypes.BOOLEAN, ['createdAt']),\n *     get: function() {\n *       return this.get('createdAt') > Date.now() - (7 * 24 * 60 * 60 * 1000)\n *     }\n *   }\n * }\n *\n */\nclass VIRTUAL extends ABSTRACT {\n  /**\n   * @param {ABSTRACT} [ReturnType] return type for virtual type\n   * @param {Array} [fields] array of fields this virtual type is dependent on\n   */\n  constructor(ReturnType, fields) {\n    super();\n    if (typeof ReturnType === 'function')\n      ReturnType = new ReturnType();\n    this.returnType = ReturnType;\n    this.fields = fields;\n  }\n}\n\n/**\n * An enumeration, Postgres Only\n *\n * @example\n * DataTypes.ENUM('value', 'another value')\n * DataTypes.ENUM(['value', 'another value'])\n * DataTypes.ENUM({\n *   values: ['value', 'another value']\n * })\n */\nclass ENUM extends ABSTRACT {\n  /**\n   * @param {...any|{ values: any[] }|any[]} args either array of values or options object with values array. It also supports variadic values\n   */\n  constructor(...args) {\n    super();\n    const value = args[0];\n    const options = typeof value === 'object' && !Array.isArray(value) && value || {\n      values: args.reduce((result, element) => {\n        return result.concat(Array.isArray(element) ? element : [element]);\n      }, [])\n    };\n    this.values = options.values;\n    this.options = options;\n  }\n  validate(value) {\n    if (!this.values.includes(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid choice in %j', value, this.values));\n    }\n    return true;\n  }\n}\n\n/**\n * An array of `type`. Only available in Postgres.\n *\n * @example\n * DataTypes.ARRAY(DataTypes.DECIMAL)\n */\nclass ARRAY extends ABSTRACT {\n  /**\n   * @param {ABSTRACT} type type of array values\n   */\n  constructor(type) {\n    super();\n    const options = _.isPlainObject(type) ? type : { type };\n    this.options = options;\n    this.type = typeof options.type === 'function' ? new options.type() : options.type;\n  }\n  toSql() {\n    return `${this.type.toSql()}[]`;\n  }\n  validate(value) {\n    if (!Array.isArray(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid array', value));\n    }\n    return true;\n  }\n  static is(obj, type) {\n    return obj instanceof ARRAY && obj.type instanceof type;\n  }\n}\n\n/**\n * A column storing Geometry information.\n * It is only available in PostgreSQL (with PostGIS), MariaDB or MySQL.\n *\n * GeoJSON is accepted as input and returned as output.\n *\n * In PostGIS, the GeoJSON is parsed using the PostGIS function `ST_GeomFromGeoJSON`.\n * In MySQL it is parsed using the function `ST_GeomFromText`.\n *\n * Therefore, one can just follow the [GeoJSON spec](https://tools.ietf.org/html/rfc7946) for handling geometry objects.  See the following examples:\n *\n * @example <caption>Defining a Geometry type attribute</caption>\n * DataTypes.GEOMETRY\n * DataTypes.GEOMETRY('POINT')\n * DataTypes.GEOMETRY('POINT', 4326)\n *\n * @example <caption>Create a new point</caption>\n * const point = { type: 'Point', coordinates: [39.807222,-76.984722]};\n *\n * User.create({username: 'username', geometry: point });\n *\n * @example <caption>Create a new linestring</caption>\n * const line = { type: 'LineString', 'coordinates': [ [100.0, 0.0], [101.0, 1.0] ] };\n *\n * User.create({username: 'username', geometry: line });\n *\n * @example <caption>Create a new polygon</caption>\n * const polygon = { type: 'Polygon', coordinates: [\n *                 [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],\n *                   [100.0, 1.0], [100.0, 0.0] ]\n *                 ]};\n *\n * User.create({username: 'username', geometry: polygon });\n *\n * @example <caption>Create a new point with a custom SRID</caption>\n * const point = {\n *   type: 'Point',\n *   coordinates: [39.807222,-76.984722],\n *   crs: { type: 'name', properties: { name: 'EPSG:4326'} }\n * };\n *\n * User.create({username: 'username', geometry: point })\n *\n *\n * @see {@link DataTypes.GEOGRAPHY}\n */\nclass GEOMETRY extends ABSTRACT {\n  /**\n   * @param {string} [type] Type of geometry data\n   * @param {string} [srid] SRID of type\n   */\n  constructor(type, srid) {\n    super();\n    const options = _.isPlainObject(type) ? type : { type, srid };\n    this.options = options;\n    this.type = options.type;\n    this.srid = options.srid;\n  }\n  _stringify(value, options) {\n    return `ST_GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n  _bindParam(value, options) {\n    return `ST_GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n}\n\nGEOMETRY.prototype.escape = false;\n\n/**\n * A geography datatype represents two dimensional spacial objects in an elliptic coord system.\n *\n * __The difference from geometry and geography type:__\n *\n * PostGIS 1.5 introduced a new spatial type called geography, which uses geodetic measurement instead of Cartesian measurement.\n * Coordinate points in the geography type are always represented in WGS 84 lon lat degrees (SRID 4326),\n * but measurement functions and relationships ST_Distance, ST_DWithin, ST_Length, and ST_Area always return answers in meters or assume inputs in meters.\n *\n * __What is best to use? It depends:__\n *\n * When choosing between the geometry and geography type for data storage, you should consider what youll be using it for.\n * If all you do are simple measurements and relationship checks on your data, and your data covers a fairly large area, then most likely youll be better off storing your data using the new geography type.\n * Although the new geography data type can cover the globe, the geometry type is far from obsolete.\n * The geometry type has a much richer set of functions than geography, relationship checks are generally faster, and it has wider support currently across desktop and web-mapping tools\n *\n * @example <caption>Defining a Geography type attribute</caption>\n * DataTypes.GEOGRAPHY\n * DataTypes.GEOGRAPHY('POINT')\n * DataTypes.GEOGRAPHY('POINT', 4326)\n */\nclass GEOGRAPHY extends ABSTRACT {\n  /**\n   * @param {string} [type] Type of geography data\n   * @param {string} [srid] SRID of type\n   */\n  constructor(type, srid) {\n    super();\n    const options = _.isPlainObject(type) ? type : { type, srid };\n    this.options = options;\n    this.type = options.type;\n    this.srid = options.srid;\n  }\n  _stringify(value, options) {\n    return `ST_GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n  _bindParam(value, options) {\n    return `ST_GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n}\n\n\nGEOGRAPHY.prototype.escape = false;\n\n/**\n * The cidr type holds an IPv4 or IPv6 network specification. Takes 7 or 19 bytes.\n *\n * Only available for Postgres\n */\nclass CIDR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== 'string' || !Validator.isIPRange(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid CIDR', value));\n    }\n    return true;\n  }\n}\n\n/**\n * The INET type holds an IPv4 or IPv6 host address, and optionally its subnet. Takes 7 or 19 bytes\n *\n * Only available for Postgres\n */\nclass INET extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== 'string' || !Validator.isIP(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid INET', value));\n    }\n    return true;\n  }\n}\n\n/**\n * The MACADDR type stores MAC addresses. Takes 6 bytes\n *\n * Only available for Postgres\n *\n */\nclass MACADDR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== 'string' || !Validator.isMACAddress(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid MACADDR', value));\n    }\n    return true;\n  }\n}\n\n/**\n * The TSVECTOR type stores text search vectors.\n *\n * Only available for Postgres\n *\n */\nclass TSVECTOR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== 'string') {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));\n    }\n    return true;\n  }\n}\n\n/**\n * A convenience class holding commonly used data types. The data types are used when defining a new model using `Sequelize.define`, like this:\n * ```js\n * sequelize.define('model', {\n *   column: DataTypes.INTEGER\n * })\n * ```\n * When defining a model you can just as easily pass a string as type, but often using the types defined here is beneficial. For example, using `DataTypes.BLOB`, mean\n * that that column will be returned as an instance of `Buffer` when being fetched by sequelize.\n *\n * To provide a length for the data type, you can invoke it like a function: `INTEGER(2)`\n *\n * Some data types have special properties that can be accessed in order to change the data type.\n * For example, to get an unsigned integer with zerofill you can do `DataTypes.INTEGER.UNSIGNED.ZEROFILL`.\n * The order you access the properties in do not matter, so `DataTypes.INTEGER.ZEROFILL.UNSIGNED` is fine as well.\n *\n * * All number types (`INTEGER`, `BIGINT`, `FLOAT`, `DOUBLE`, `REAL`, `DECIMAL`) expose the properties `UNSIGNED` and `ZEROFILL`\n * * The `CHAR` and `STRING` types expose the `BINARY` property\n *\n * Three of the values provided here (`NOW`, `UUIDV1` and `UUIDV4`) are special default values, that should not be used to define types. Instead they are used as shorthands for\n * defining default values. For example, to get a uuid field with a default value generated following v1 of the UUID standard:\n * ```js\n * sequelize.define('model', {\n *   uuid: {\n *     type: DataTypes.UUID,\n *     defaultValue: DataTypes.UUIDV1,\n *     primaryKey: true\n *   }\n * })\n * ```\n * There may be times when you want to generate your own UUID conforming to some other algorithm. This is accomplished\n * using the defaultValue property as well, but instead of specifying one of the supplied UUID types, you return a value\n * from a function.\n * ```js\n * sequelize.define('model', {\n *   uuid: {\n *     type: DataTypes.UUID,\n *     defaultValue: function() {\n *       return generateMyId()\n *     },\n *     primaryKey: true\n *   }\n * })\n * ```\n */\nconst DataTypes = module.exports = {\n  ABSTRACT,\n  STRING,\n  CHAR,\n  TEXT,\n  NUMBER,\n  TINYINT,\n  SMALLINT,\n  MEDIUMINT,\n  INTEGER,\n  BIGINT,\n  FLOAT,\n  TIME,\n  DATE,\n  DATEONLY,\n  BOOLEAN,\n  NOW,\n  BLOB,\n  DECIMAL,\n  NUMERIC: DECIMAL,\n  UUID,\n  UUIDV1,\n  UUIDV4,\n  HSTORE,\n  JSON: JSONTYPE,\n  JSONB,\n  VIRTUAL,\n  ARRAY,\n  ENUM,\n  RANGE,\n  REAL,\n  'DOUBLE PRECISION': DOUBLE,\n  DOUBLE,\n  GEOMETRY,\n  GEOGRAPHY,\n  CIDR,\n  INET,\n  MACADDR,\n  CITEXT,\n  TSVECTOR\n};\n\n_.each(DataTypes, (dataType, name) => {\n  // guard for aliases\n  if (!Object.prototype.hasOwnProperty.call(dataType, 'key')) {\n    dataType.types = {};\n    dataType.key = dataType.prototype.key = name;\n  }\n});\n\nconst dialectMap = {};\ndialectMap.postgres = require('./dialects/postgres/data-types')(DataTypes);\ndialectMap.mysql = require('./dialects/mysql/data-types')(DataTypes);\ndialectMap.mariadb = require('./dialects/mariadb/data-types')(DataTypes);\ndialectMap.sqlite = require('./dialects/sqlite/data-types')(DataTypes);\ndialectMap.mssql = require('./dialects/mssql/data-types')(DataTypes);\n\nconst dialectList = Object.values(dialectMap);\n\nfor (const dataTypes of dialectList) {\n  _.each(dataTypes, (DataType, key) => {\n    if (!DataType.key) {\n      DataType.key = DataType.prototype.key = key;\n    }\n  });\n}\n\n// Wrap all data types to not require `new`\nfor (const dataTypes of [DataTypes, ...dialectList]) {\n  _.each(dataTypes, (DataType, key) => {\n    dataTypes[key] = classToInvokable(DataType);\n  });\n}\n\nObject.assign(DataTypes, dialectMap);\n"]},"metadata":{},"sourceType":"script"}