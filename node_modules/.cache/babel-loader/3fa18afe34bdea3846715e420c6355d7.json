{"ast":null,"code":"\"use strict\";\n\nvar s = Object.defineProperty;\n\nvar i = (e, t) => s(e, \"name\", {\n  value: t,\n  configurable: !0\n});\n\nfunction u(e) {\n  return /^[;,)]/.test(e);\n}\n\ni(u, \"doesNotWantLeadingSpace\");\n\nfunction c(e) {\n  return /\\($/.test(e);\n}\n\ni(c, \"doesNotWantTrailingSpace\");\n\nfunction f(e) {\n  return e.reduce((_ref, o) => {\n    let {\n      skipNextLeadingSpace: t,\n      result: n\n    } = _ref;\n    return t || u(o) ? n += o.trim() : n += ` ${o.trim()}`, {\n      skipNextLeadingSpace: c(o),\n      result: n\n    };\n  }, {\n    skipNextLeadingSpace: !0,\n    result: \"\"\n  }).result;\n}\n\ni(f, \"singleSpaceJoinHelper\");\n\nfunction r(e) {\n  if (e.length === 0) return \"\";\n  e = e.filter(t => t), e = e.map(t => Array.isArray(t) ? r(t) : t);\n\n  for (const t of e) if (t && typeof t != \"string\") {\n    const n = new TypeError(`Tried to construct a SQL string with a non-string, non-falsy fragment (${t}).`);\n    throw n.args = e, n.fragment = t, n;\n  }\n\n  return e = e.map(t => t.trim()), e = e.filter(t => t !== \"\"), f(e);\n}\n\ni(r, \"joinSQLFragments\"), exports.joinSQLFragments = r;","map":{"version":3,"sources":["../../../lib/utils/join-sql-fragments.js"],"names":[],"mappings":";;;;;;;;;AAEA,SAAA,CAAA,CAAiC,CAAjC,EAAsC;AACpC,SAAO,SAAS,IAAT,CAAc,CAAd,CAAP;AADO;;AAAA,CAAA,CAAA,CAAA,EAAA,yBAAA,CAAA;;AAGT,SAAA,CAAA,CAAkC,CAAlC,EAAuC;AACrC,SAAO,MAAM,IAAN,CAAW,CAAX,CAAP;AADO;;AAAA,CAAA,CAAA,CAAA,EAAA,0BAAA,CAAA;;AAeT,SAAA,CAAA,CAA+B,CAA/B,EAAsC;AACpC,SAAO,CAAA,CAAM,MAAN,CAAa,OAAmC,CAAnC;AAAA,QAAC;AAAE,MAAA,oBAAA,EAAA,CAAF;AAAwB,MAAA,MAAA,EAAA;AAAxB,KAAD;AAAA,WACd,CAAA,IAAwB,CAAA,CAAwB,CAAxB,CAAxB,GACF,CAAA,IAAU,CAAA,CAAK,IAAL,EADR,GAGF,CAAA,IAAU,IAAI,CAAA,CAAK,IAAL,EAAK,EAHjB,EAKG;AACL,MAAA,oBAAA,EAAsB,CAAA,CAAyB,CAAzB,CADjB;AAEL,MAAA,MAAA,EAAA;AAFK,KANW;AAAA,GAAb,EAUJ;AACD,IAAA,oBAAA,EAAsB,CAAA,CADrB;AAED,IAAA,MAAA,EAAQ;AAFP,GAVI,EAaJ,MAbH;AADO;;AAAA,CAAA,CAAA,CAAA,EAAA,uBAAA,CAAA;;AA8BT,SAAA,CAAA,CAA0B,CAA1B,EAAiC;AAC/B,MAAI,CAAA,CAAM,MAAN,KAAiB,CAArB,EAAwB,OAAO,EAAP;AAGxB,EAAA,CAAA,GAAQ,CAAA,CAAM,MAAN,CAAa,CAAA,IAAK,CAAlB,CAAR,EAGA,CAAA,GAAQ,CAAA,CAAM,GAAN,CAAU,CAAA,IACZ,KAAA,CAAM,OAAN,CAAc,CAAd,IACK,CAAA,CAAiB,CAAjB,CADL,GAGG,CAJD,CAHR;;AAWA,OAAA,MAAW,CAAX,IAAuB,CAAvB,EACE,IAAI,CAAA,IAAY,OAAO,CAAP,IAAoB,QAApC,EAA8C;AAC5C,UAAM,CAAA,GAAQ,IAAI,SAAJ,CAAc,0EAA0E,CAAA,IAAxF,CAAd;AACA,UAAA,CAAA,CAAM,IAAN,GAAa,CAAb,EACA,CAAA,CAAM,QAAN,GAAiB,CADjB,EAEM,CAFN;AAOJ;;AAAA,SAAA,CAAA,GAAQ,CAAA,CAAM,GAAN,CAAU,CAAA,IAAK,CAAA,CAAE,IAAF,EAAf,CAAR,EAGA,CAAA,GAAQ,CAAA,CAAM,MAAN,CAAa,CAAA,IAAK,CAAA,KAAM,EAAxB,CAHR,EAKO,CAAA,CAAsB,CAAtB,CALP;AAzBO;;AAAA,CAAA,CAAA,CAAA,EAAA,kBAAA,CAAA,EAgCT,OAAA,CAAQ,gBAAR,GAA2B,CAhClB","sourcesContent":["'use strict';\n\nfunction doesNotWantLeadingSpace(str) {\n  return /^[;,)]/.test(str);\n}\nfunction doesNotWantTrailingSpace(str) {\n  return /\\($/.test(str);\n}\n\n/**\n * Joins an array of strings with a single space between them,\n * except for:\n * \n * - Strings starting with ';', ',' and ')', which do not get a leading space.\n * - Strings ending with '(', which do not get a trailing space.\n * \n * @param {string[]} parts\n * @returns {string}\n * @private\n */\nfunction singleSpaceJoinHelper(parts) {\n  return parts.reduce(({ skipNextLeadingSpace, result }, part) => {\n    if (skipNextLeadingSpace || doesNotWantLeadingSpace(part)) {\n      result += part.trim();\n    } else {\n      result += ` ${part.trim()}`;\n    }\n    return {\n      skipNextLeadingSpace: doesNotWantTrailingSpace(part),\n      result\n    };\n  }, {\n    skipNextLeadingSpace: true,\n    result: ''\n  }).result;\n}\n\n/**\n * Joins an array with a single space, auto trimming when needed.\n * \n * Certain elements do not get leading/trailing spaces.\n * \n * @param {any[]} array The array to be joined. Falsy values are skipped. If an\n * element is another array, this function will be called recursively on that array.\n * Otherwise, if a non-string, non-falsy value is present, a TypeError will be thrown.\n * \n * @returns {string} The joined string.\n * \n * @private\n */\nfunction joinSQLFragments(array) {\n  if (array.length === 0) return '';\n\n  // Skip falsy fragments\n  array = array.filter(x => x);\n\n  // Resolve recursive calls\n  array = array.map(fragment => {\n    if (Array.isArray(fragment)) {\n      return joinSQLFragments(fragment);\n    }\n    return fragment;\n  });\n\n  // Ensure strings\n  for (const fragment of array) {\n    if (fragment && typeof fragment !== 'string') {\n      const error = new TypeError(`Tried to construct a SQL string with a non-string, non-falsy fragment (${fragment}).`);\n      error.args = array;\n      error.fragment = fragment;\n      throw error;\n    }\n  }\n\n  // Trim fragments\n  array = array.map(x => x.trim());\n\n  // Skip full-whitespace fragments (empty after the above trim)\n  array = array.filter(x => x !== '');\n\n  return singleSpaceJoinHelper(array);\n}\nexports.joinSQLFragments = joinSQLFragments;\n"]},"metadata":{},"sourceType":"script"}