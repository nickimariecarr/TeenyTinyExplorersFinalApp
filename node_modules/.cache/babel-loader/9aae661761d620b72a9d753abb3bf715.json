{"ast":null,"code":"\"use strict\";\n\nvar Y = Object.defineProperty;\n\nvar n = (r, f) => Y(r, \"name\", {\n  value: f,\n  configurable: !0\n});\n\nconst D = require(\"lodash\"),\n      C = require(\"wkx\");\n\nmodule.exports = r => {\n  const f = r.ABSTRACT.warn.bind(void 0, \"http://www.postgresql.org/docs/9.4/static/datatype.html\");\n\n  function d(e) {\n    (e._length || e.options.length || e._unsigned || e._zerofill) && (f(`PostgresSQL does not support '${e.key}' with LENGTH, UNSIGNED or ZEROFILL. Plain '${e.key}' will be used instead.`), e._length = void 0, e.options.length = void 0, e._unsigned = void 0, e._zerofill = void 0);\n  }\n\n  n(d, \"removeUnsupportedIntegerOptions\"), r.UUID.types.postgres = [\"uuid\"], r.CIDR.types.postgres = [\"cidr\"], r.INET.types.postgres = [\"inet\"], r.MACADDR.types.postgres = [\"macaddr\"], r.TSVECTOR.types.postgres = [\"tsvector\"], r.JSON.types.postgres = [\"json\"], r.JSONB.types.postgres = [\"jsonb\"], r.TIME.types.postgres = [\"time\"];\n\n  class a extends r.DATEONLY {\n    _stringify(t, i) {\n      return t === 1 / 0 ? \"Infinity\" : t === -1 / 0 ? \"-Infinity\" : super._stringify(t, i);\n    }\n\n    _sanitize(t, i) {\n      if ((!i || i && !i.raw) && t !== 1 / 0 && t !== -1 / 0) {\n        if (typeof t == \"string\") {\n          const s = t.toLowerCase();\n          if (s === \"infinity\") return 1 / 0;\n          if (s === \"-infinity\") return -1 / 0;\n        }\n\n        return super._sanitize(t);\n      }\n\n      return t;\n    }\n\n    static parse(t) {\n      return t === \"infinity\" ? 1 / 0 : t === \"-infinity\" ? -1 / 0 : t;\n    }\n\n  }\n\n  n(a, \"DATEONLY\"), r.DATEONLY.types.postgres = [\"date\"];\n\n  class E extends r.DECIMAL {\n    static parse(t) {\n      return t;\n    }\n\n  }\n\n  n(E, \"DECIMAL\"), r.DECIMAL.types.postgres = [\"numeric\"];\n\n  class _ extends r.STRING {\n    toSql() {\n      return this._binary ? \"BYTEA\" : super.toSql();\n    }\n\n  }\n\n  n(_, \"STRING\"), r.STRING.types.postgres = [\"varchar\"];\n\n  class I extends r.TEXT {\n    toSql() {\n      return this._length && (f(\"PostgreSQL does not support TEXT with options. Plain `TEXT` will be used instead.\"), this._length = void 0), \"TEXT\";\n    }\n\n  }\n\n  n(I, \"TEXT\"), r.TEXT.types.postgres = [\"text\"];\n\n  class A extends r.CITEXT {\n    static parse(t) {\n      return t;\n    }\n\n  }\n\n  n(A, \"CITEXT\"), r.CITEXT.types.postgres = [\"citext\"];\n\n  class m extends r.CHAR {\n    toSql() {\n      return this._binary ? \"BYTEA\" : super.toSql();\n    }\n\n  }\n\n  n(m, \"CHAR\"), r.CHAR.types.postgres = [\"char\", \"bpchar\"];\n\n  class p extends r.BOOLEAN {\n    toSql() {\n      return \"BOOLEAN\";\n    }\n\n    _sanitize(t) {\n      if (t != null) {\n        if (Buffer.isBuffer(t) && t.length === 1 && (t = t[0]), typeof t == \"string\") return t === \"true\" || t === \"t\" ? !0 : t === \"false\" || t === \"f\" ? !1 : t;\n        if (typeof t == \"number\") return t === 1 ? !0 : t === 0 ? !1 : t;\n      }\n\n      return t;\n    }\n\n  }\n\n  n(p, \"BOOLEAN\"), p.parse = p.prototype._sanitize, r.BOOLEAN.types.postgres = [\"bool\"];\n\n  class O extends r.DATE {\n    toSql() {\n      return \"TIMESTAMP WITH TIME ZONE\";\n    }\n\n    validate(t) {\n      return t !== 1 / 0 && t !== -1 / 0 ? super.validate(t) : !0;\n    }\n\n    _stringify(t, i) {\n      return t === 1 / 0 ? \"Infinity\" : t === -1 / 0 ? \"-Infinity\" : super._stringify(t, i);\n    }\n\n    _sanitize(t, i) {\n      if ((!i || i && !i.raw) && !(t instanceof Date) && !!t && t !== 1 / 0 && t !== -1 / 0) {\n        if (typeof t == \"string\") {\n          const s = t.toLowerCase();\n          if (s === \"infinity\") return 1 / 0;\n          if (s === \"-infinity\") return -1 / 0;\n        }\n\n        return new Date(t);\n      }\n\n      return t;\n    }\n\n  }\n\n  n(O, \"DATE\"), r.DATE.types.postgres = [\"timestamptz\"];\n\n  class S extends r.TINYINT {\n    constructor(t) {\n      super(t);\n      d(this);\n    }\n\n  }\n\n  n(S, \"TINYINT\"), r.TINYINT.types.postgres = [\"int2\"];\n\n  class N extends r.SMALLINT {\n    constructor(t) {\n      super(t);\n      d(this);\n    }\n\n  }\n\n  n(N, \"SMALLINT\"), r.SMALLINT.types.postgres = [\"int2\"];\n\n  class g extends r.INTEGER {\n    constructor(t) {\n      super(t);\n      d(this);\n    }\n\n  }\n\n  n(g, \"INTEGER\"), g.parse = n(function (t) {\n    return parseInt(t, 10);\n  }, \"parse\"), r.INTEGER.types.postgres = [\"int4\"];\n\n  class b extends r.BIGINT {\n    constructor(t) {\n      super(t);\n      d(this);\n    }\n\n  }\n\n  n(b, \"BIGINT\"), r.BIGINT.types.postgres = [\"int8\"];\n\n  class L extends r.REAL {\n    constructor(t) {\n      super(t);\n      d(this);\n    }\n\n  }\n\n  n(L, \"REAL\"), r.REAL.types.postgres = [\"float4\"];\n\n  class R extends r.DOUBLE {\n    constructor(t) {\n      super(t);\n      d(this);\n    }\n\n  }\n\n  n(R, \"DOUBLE\"), r.DOUBLE.types.postgres = [\"float8\"];\n\n  class h extends r.FLOAT {\n    constructor(t, i) {\n      super(t, i);\n      this._decimals && (f(\"PostgreSQL does not support FLOAT with decimals. Plain `FLOAT` will be used instead.\"), this._length = void 0, this.options.length = void 0, this._decimals = void 0), this._unsigned && (f(\"PostgreSQL does not support FLOAT unsigned. `UNSIGNED` was removed.\"), this._unsigned = void 0), this._zerofill && (f(\"PostgreSQL does not support FLOAT zerofill. `ZEROFILL` was removed.\"), this._zerofill = void 0);\n    }\n\n  }\n\n  n(h, \"FLOAT\"), delete h.parse;\n\n  class G extends r.BLOB {\n    toSql() {\n      return this._length && (f(\"PostgreSQL does not support BLOB (BYTEA) with options. Plain `BYTEA` will be used instead.\"), this._length = void 0), \"BYTEA\";\n    }\n\n    _hexify(t) {\n      return `E'\\\\\\\\x${t}'`;\n    }\n\n  }\n\n  n(G, \"BLOB\"), r.BLOB.types.postgres = [\"bytea\"];\n\n  class x extends r.GEOMETRY {\n    toSql() {\n      let t = this.key;\n      return this.type && (t += `(${this.type}`, this.srid && (t += `,${this.srid}`), t += \")\"), t;\n    }\n\n    static parse(t) {\n      const i = Buffer.from(t, \"hex\");\n      return C.Geometry.parse(i).toGeoJSON({\n        shortCrs: !0\n      });\n    }\n\n    _stringify(t, i) {\n      return `ST_GeomFromGeoJSON(${i.escape(JSON.stringify(t))})`;\n    }\n\n    _bindParam(t, i) {\n      return `ST_GeomFromGeoJSON(${i.bindParam(t)})`;\n    }\n\n  }\n\n  n(x, \"GEOMETRY\"), r.GEOMETRY.types.postgres = [\"geometry\"];\n\n  class P extends r.GEOGRAPHY {\n    toSql() {\n      let t = \"GEOGRAPHY\";\n      return this.type && (t += `(${this.type}`, this.srid && (t += `,${this.srid}`), t += \")\"), t;\n    }\n\n    static parse(t) {\n      const i = Buffer.from(t, \"hex\");\n      return C.Geometry.parse(i).toGeoJSON({\n        shortCrs: !0\n      });\n    }\n\n    _stringify(t, i) {\n      return `ST_GeomFromGeoJSON(${i.escape(JSON.stringify(t))})`;\n    }\n\n    bindParam(t, i) {\n      return `ST_GeomFromGeoJSON(${i.bindParam(t)})`;\n    }\n\n  }\n\n  n(P, \"GEOGRAPHY\"), r.GEOGRAPHY.types.postgres = [\"geography\"];\n  let u;\n\n  class l extends r.HSTORE {\n    constructor() {\n      super();\n      u || (u = require(\"./hstore\"));\n    }\n\n    _value(t) {\n      return u || (u = require(\"./hstore\")), u.stringify(t);\n    }\n\n    _stringify(t) {\n      return `'${this._value(t)}'`;\n    }\n\n    _bindParam(t, i) {\n      return i.bindParam(this._value(t));\n    }\n\n    static parse(t) {\n      return u || (u = require(\"./hstore\")), u.parse(t);\n    }\n\n  }\n\n  n(l, \"HSTORE\"), l.prototype.escape = !1, r.HSTORE.types.postgres = [\"hstore\"];\n\n  class y extends r.RANGE {\n    _value(t, i) {\n      if (!Array.isArray(t)) return this.options.subtype.stringify(t, i);\n      const s = [!0, !1],\n            c = t.map((o, $) => (D.isObject(o) && Object.prototype.hasOwnProperty.call(o, \"value\") && (Object.prototype.hasOwnProperty.call(o, \"inclusive\") && (s[$] = o.inclusive), o = o.value), o === null || o === -1 / 0 || o === 1 / 0 ? o : this.options.subtype.stringify ? this.options.subtype.stringify(o, i) : i.escape(o)));\n      return c.inclusive = s, w.stringify(c);\n    }\n\n    _stringify(t, i) {\n      const s = this._value(t, i);\n\n      return Array.isArray(t) ? `'${s}'` : `'${s}'::${this.toCastType()}`;\n    }\n\n    _bindParam(t, i) {\n      const s = this._value(t, i);\n\n      return Array.isArray(t) ? i.bindParam(s) : `${i.bindParam(s)}::${this.toCastType()}`;\n    }\n\n    toSql() {\n      return r.RANGE.types.postgres.subtypes[this._subtype.toLowerCase()];\n    }\n\n    toCastType() {\n      return r.RANGE.types.postgres.castTypes[this._subtype.toLowerCase()];\n    }\n\n    static parse(t) {\n      let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        parser: s => s\n      };\n      return w.parse(t, i.parser);\n    }\n\n  }\n\n  n(y, \"RANGE\");\n\n  const w = require(\"./range\");\n\n  y.prototype.escape = !1, r.RANGE.types.postgres = {\n    subtypes: {\n      integer: \"int4range\",\n      decimal: \"numrange\",\n      date: \"tstzrange\",\n      dateonly: \"daterange\",\n      bigint: \"int8range\"\n    },\n    castTypes: {\n      integer: \"int4\",\n      decimal: \"numeric\",\n      date: \"timestamptz\",\n      dateonly: \"date\",\n      bigint: \"int8\"\n    }\n  }, r.ARRAY.prototype.escape = !1, r.ARRAY.prototype._value = n(function (t, i) {\n    return t.map(s => i && i.bindParam && this.type && this.type._value ? this.type._value(s, i) : this.type && this.type.stringify && (s = this.type.stringify(s, i), this.type.escape === !1) ? s : i.escape(s), this);\n  }, \"_value\"), r.ARRAY.prototype._stringify = n(function (t, i) {\n    let s = `ARRAY[${this._value(t, i).join(\",\")}]`;\n\n    if (this.type) {\n      const c = require(\"../../utils\");\n\n      let o = this.toSql();\n      this.type instanceof r.ENUM && (o = `${c.addTicks(c.generateEnumName(i.field.Model.getTableName(), i.field.field), '\"')}[]`), s += `::${o}`;\n    }\n\n    return s;\n  }, \"_stringify\"), r.ARRAY.prototype._bindParam = n(function (t, i) {\n    return i.bindParam(this._value(t, i));\n  }, \"_bindParam\");\n\n  class q extends r.ENUM {\n    static parse(t) {\n      return t;\n    }\n\n  }\n\n  return n(q, \"ENUM\"), r.ENUM.types.postgres = [null], {\n    DECIMAL: E,\n    BLOB: G,\n    STRING: _,\n    CHAR: m,\n    TEXT: I,\n    CITEXT: A,\n    TINYINT: S,\n    SMALLINT: N,\n    INTEGER: g,\n    BIGINT: b,\n    BOOLEAN: p,\n    DATE: O,\n    DATEONLY: a,\n    REAL: L,\n    \"DOUBLE PRECISION\": R,\n    FLOAT: h,\n    GEOMETRY: x,\n    GEOGRAPHY: P,\n    HSTORE: l,\n    RANGE: y,\n    ENUM: q\n  };\n};","map":{"version":3,"sources":["../../../../lib/dialects/postgres/data-types.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst wkx = require('wkx');\n\nmodule.exports = BaseTypes => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'http://www.postgresql.org/docs/9.4/static/datatype.html');\n\n  /**\n   * Removes unsupported Postgres options, i.e., LENGTH, UNSIGNED and ZEROFILL, for the integer data types.\n   *\n   * @param {object} dataType The base integer data type.\n   * @private\n   */\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {\n      warn(`PostgresSQL does not support '${dataType.key}' with LENGTH, UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);\n      dataType._length = undefined;\n      dataType.options.length = undefined;\n      dataType._unsigned = undefined;\n      dataType._zerofill = undefined;\n    }\n  }\n\n  /**\n   * types:\n   * {\n   *   oids: [oid],\n   *   array_oids: [oid]\n   * }\n   *\n   * @see oid here https://github.com/lib/pq/blob/master/oid/types.go\n   */\n\n  BaseTypes.UUID.types.postgres = ['uuid'];\n  BaseTypes.CIDR.types.postgres = ['cidr'];\n  BaseTypes.INET.types.postgres = ['inet'];\n  BaseTypes.MACADDR.types.postgres = ['macaddr'];\n  BaseTypes.TSVECTOR.types.postgres = ['tsvector'];\n  BaseTypes.JSON.types.postgres = ['json'];\n  BaseTypes.JSONB.types.postgres = ['jsonb'];\n  BaseTypes.TIME.types.postgres = ['time'];\n\n  class DATEONLY extends BaseTypes.DATEONLY {\n    _stringify(value, options) {\n      if (value === Infinity) {\n        return 'Infinity';\n      }\n      if (value === -Infinity) {\n        return '-Infinity';\n      }\n      return super._stringify(value, options);\n    }\n    _sanitize(value, options) {\n      if ((!options || options && !options.raw) && value !== Infinity && value !== -Infinity) {\n        if (typeof value === 'string') {\n          const lower = value.toLowerCase();\n          if (lower === 'infinity') {\n            return Infinity;\n          }\n          if (lower === '-infinity') {\n            return -Infinity;\n          }\n        }\n        return super._sanitize(value);\n      }\n      return value;\n    }\n    static parse(value) {\n      if (value === 'infinity') {\n        return Infinity;\n      }\n      if (value === '-infinity') {\n        return -Infinity;\n      }\n      return value;\n    }\n  }\n\n  BaseTypes.DATEONLY.types.postgres = ['date'];\n\n  class DECIMAL extends BaseTypes.DECIMAL {\n    static parse(value) {\n      return value;\n    }\n  }\n\n  // numeric\n  BaseTypes.DECIMAL.types.postgres = ['numeric'];\n\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this._binary) {\n        return 'BYTEA';\n      }\n      return super.toSql();\n    }\n  }\n\n  BaseTypes.STRING.types.postgres = ['varchar'];\n\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      if (this._length) {\n        warn('PostgreSQL does not support TEXT with options. Plain `TEXT` will be used instead.');\n        this._length = undefined;\n      }\n      return 'TEXT';\n    }\n  }\n\n  BaseTypes.TEXT.types.postgres = ['text'];\n\n  class CITEXT extends BaseTypes.CITEXT {\n    static parse(value) {\n      return value;\n    }\n  }\n\n  BaseTypes.CITEXT.types.postgres = ['citext'];\n\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        return 'BYTEA';\n      }\n      return super.toSql();\n    }\n  }\n\n  BaseTypes.CHAR.types.postgres = ['char', 'bpchar'];\n\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return 'BOOLEAN';\n    }\n    _sanitize(value) {\n      if (value !== null && value !== undefined) {\n        if (Buffer.isBuffer(value) && value.length === 1) {\n          // Bit fields are returned as buffers\n          value = value[0];\n        }\n        if (typeof value === 'string') {\n          // Only take action on valid boolean strings.\n          return value === 'true' || value === 't' ? true : value === 'false' || value === 'f' ? false : value;\n        }\n        if (typeof value === 'number') {\n          // Only take action on valid boolean integers.\n          return value === 1 ? true : value === 0 ? false : value;\n        }\n      }\n      return value;\n    }\n  }\n\n  BOOLEAN.parse = BOOLEAN.prototype._sanitize;\n\n  BaseTypes.BOOLEAN.types.postgres = ['bool'];\n\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return 'TIMESTAMP WITH TIME ZONE';\n    }\n    validate(value) {\n      if (value !== Infinity && value !== -Infinity) {\n        return super.validate(value);\n      }\n      return true;\n    }\n    _stringify(value, options) {\n      if (value === Infinity) {\n        return 'Infinity';\n      }\n      if (value === -Infinity) {\n        return '-Infinity';\n      }\n      return super._stringify(value, options);\n    }\n    _sanitize(value, options) {\n      if ((!options || options && !options.raw) && !(value instanceof Date) && !!value && value !== Infinity && value !== -Infinity) {\n        if (typeof value === 'string') {\n          const lower = value.toLowerCase();\n          if (lower === 'infinity') {\n            return Infinity;\n          }\n          if (lower === '-infinity') {\n            return -Infinity;\n          }\n        }\n        return new Date(value);\n      }\n      return value;\n    }\n  }\n\n  BaseTypes.DATE.types.postgres = ['timestamptz'];\n\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // int2\n  BaseTypes.TINYINT.types.postgres = ['int2'];\n\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // int2\n  BaseTypes.SMALLINT.types.postgres = ['int2'];\n\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  INTEGER.parse = function parse(value) {\n    return parseInt(value, 10);\n  };\n\n  // int4\n  BaseTypes.INTEGER.types.postgres = ['int4'];\n\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // int8\n  BaseTypes.BIGINT.types.postgres = ['int8'];\n\n  class REAL extends BaseTypes.REAL {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // float4\n  BaseTypes.REAL.types.postgres = ['float4'];\n\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // float8\n  BaseTypes.DOUBLE.types.postgres = ['float8'];\n\n  class FLOAT extends BaseTypes.FLOAT {\n    constructor(length, decimals) {\n      super(length, decimals);\n      // POSTGRES does only support lengths as parameter.\n      // Values between 1-24 result in REAL\n      // Values between 25-53 result in DOUBLE PRECISION\n      // If decimals are provided remove these and print a warning\n      if (this._decimals) {\n        warn('PostgreSQL does not support FLOAT with decimals. Plain `FLOAT` will be used instead.');\n        this._length = undefined;\n        this.options.length = undefined;\n        this._decimals = undefined;\n      }\n      if (this._unsigned) {\n        warn('PostgreSQL does not support FLOAT unsigned. `UNSIGNED` was removed.');\n        this._unsigned = undefined;\n      }\n      if (this._zerofill) {\n        warn('PostgreSQL does not support FLOAT zerofill. `ZEROFILL` was removed.');\n        this._zerofill = undefined;\n      }\n    }\n  }\n  delete FLOAT.parse; // Float has no separate type in PG\n\n  class BLOB extends BaseTypes.BLOB {\n    toSql() {\n      if (this._length) {\n        warn('PostgreSQL does not support BLOB (BYTEA) with options. Plain `BYTEA` will be used instead.');\n        this._length = undefined;\n      }\n      return 'BYTEA';\n    }\n    _hexify(hex) {\n      // bytea hex format http://www.postgresql.org/docs/current/static/datatype-binary.html\n      return `E'\\\\\\\\x${hex}'`;\n    }\n  }\n\n  BaseTypes.BLOB.types.postgres = ['bytea'];\n\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    toSql() {\n      let result = this.key;\n      if (this.type) {\n        result += `(${this.type}`;\n        if (this.srid) {\n          result += `,${this.srid}`;\n        }\n        result += ')';\n      }\n      return result;\n    }\n    static parse(value) {\n      const b = Buffer.from(value, 'hex');\n      return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });\n    }\n    _stringify(value, options) {\n      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;\n    }\n    _bindParam(value, options) {\n      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n    }\n  }\n\n  BaseTypes.GEOMETRY.types.postgres = ['geometry'];\n\n\n  class GEOGRAPHY extends BaseTypes.GEOGRAPHY {\n    toSql() {\n      let result = 'GEOGRAPHY';\n      if (this.type) {\n        result += `(${this.type}`;\n        if (this.srid) {\n          result += `,${this.srid}`;\n        }\n        result += ')';\n      }\n      return result;\n    }\n    static parse(value) {\n      const b = Buffer.from(value, 'hex');\n      return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });\n    }\n    _stringify(value, options) {\n      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;\n    }\n    bindParam(value, options) {\n      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n    }\n  }\n\n  BaseTypes.GEOGRAPHY.types.postgres = ['geography'];\n\n  let hstore;\n\n  class HSTORE extends BaseTypes.HSTORE {\n    constructor() {\n      super();\n      if (!hstore) {\n        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n        hstore = require('./hstore');\n      }\n    }\n    _value(value) {\n      if (!hstore) {\n        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n        hstore = require('./hstore');\n      }\n      return hstore.stringify(value);\n    }\n    _stringify(value) {\n      return `'${this._value(value)}'`;\n    }\n    _bindParam(value, options) {\n      return options.bindParam(this._value(value));\n    }\n    static parse(value) {\n      if (!hstore) {\n        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n        hstore = require('./hstore');\n      }\n      return hstore.parse(value);\n    }\n  }\n\n  HSTORE.prototype.escape = false;\n\n  BaseTypes.HSTORE.types.postgres = ['hstore'];\n\n  class RANGE extends BaseTypes.RANGE {\n    _value(values, options) {\n      if (!Array.isArray(values)) {\n        return this.options.subtype.stringify(values, options);\n      }\n      const valueInclusivity = [true, false];\n      const valuesStringified = values.map((value, index) => {\n        if (_.isObject(value) && Object.prototype.hasOwnProperty.call(value, 'value')) {\n          if (Object.prototype.hasOwnProperty.call(value, 'inclusive')) {\n            valueInclusivity[index] = value.inclusive;\n          }\n          value = value.value;\n        }\n        if (value === null || value === -Infinity || value === Infinity) {\n          // Pass through \"unbounded\" bounds unchanged\n          return value;\n        }\n        if (this.options.subtype.stringify) {\n          return this.options.subtype.stringify(value, options);\n        }\n        return options.escape(value);\n      });\n      // Array.map does not preserve extra array properties\n      valuesStringified.inclusive = valueInclusivity;\n      return range.stringify(valuesStringified);\n    }\n    _stringify(values, options) {\n      const value = this._value(values, options);\n      if (!Array.isArray(values)) {\n        return `'${value}'::${this.toCastType()}`;\n      }\n      return `'${value}'`;\n    }\n    _bindParam(values, options) {\n      const value = this._value(values, options);\n      if (!Array.isArray(values)) {\n        return `${options.bindParam(value)}::${this.toCastType()}`;\n      }\n      return options.bindParam(value);\n    }\n    toSql() {\n      return BaseTypes.RANGE.types.postgres.subtypes[this._subtype.toLowerCase()];\n    }\n    toCastType() {\n      return BaseTypes.RANGE.types.postgres.castTypes[this._subtype.toLowerCase()];\n    }\n    static parse(value, options = { parser: val => val }) {\n      return range.parse(value, options.parser);\n    }\n  }\n  const range = require('./range');\n\n  RANGE.prototype.escape = false;\n\n  BaseTypes.RANGE.types.postgres = {\n    subtypes: {\n      integer: 'int4range',\n      decimal: 'numrange',\n      date: 'tstzrange',\n      dateonly: 'daterange',\n      bigint: 'int8range'\n    },\n    castTypes: {\n      integer: 'int4',\n      decimal: 'numeric',\n      date: 'timestamptz',\n      dateonly: 'date',\n      bigint: 'int8'\n    }\n  };\n\n  // TODO: Why are base types being manipulated??\n  BaseTypes.ARRAY.prototype.escape = false;\n  BaseTypes.ARRAY.prototype._value = function _value(values, options) {\n    return values.map(value => {\n      if (options && options.bindParam && this.type && this.type._value) {\n        return this.type._value(value, options);\n      }\n      if (this.type && this.type.stringify) {\n        value = this.type.stringify(value, options);\n\n        if (this.type.escape === false) {\n          return value;\n        }\n      }\n      return options.escape(value);\n    }, this);\n  };\n  BaseTypes.ARRAY.prototype._stringify = function _stringify(values, options) {\n    let str = `ARRAY[${this._value(values, options).join(',')}]`;\n\n    if (this.type) {\n      const Utils = require('../../utils');\n      let castKey = this.toSql();\n\n      if (this.type instanceof BaseTypes.ENUM) {\n        castKey = `${Utils.addTicks(\n          Utils.generateEnumName(options.field.Model.getTableName(), options.field.field),\n          '\"'\n        ) }[]`;\n      }\n\n      str += `::${castKey}`;\n    }\n\n    return str;\n  };\n  BaseTypes.ARRAY.prototype._bindParam = function _bindParam(values, options) {\n    return options.bindParam(this._value(values, options));\n  };\n\n  class ENUM extends BaseTypes.ENUM {\n    static parse(value) {\n      return value;\n    }\n  }\n\n  BaseTypes.ENUM.types.postgres = [null];\n\n  return {\n    DECIMAL,\n    BLOB,\n    STRING,\n    CHAR,\n    TEXT,\n    CITEXT,\n    TINYINT,\n    SMALLINT,\n    INTEGER,\n    BIGINT,\n    BOOLEAN,\n    DATE,\n    DATEONLY,\n    REAL,\n    'DOUBLE PRECISION': DOUBLE,\n    FLOAT,\n    GEOMETRY,\n    GEOGRAPHY,\n    HSTORE,\n    RANGE,\n    ENUM\n  };\n};\n"]},"metadata":{},"sourceType":"script"}