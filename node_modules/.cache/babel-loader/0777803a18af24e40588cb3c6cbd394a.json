{"ast":null,"code":"\"use strict\";\n\nvar E = Object.defineProperty;\n\nvar c = (_, r) => E(_, \"name\", {\n  value: r,\n  configurable: !0\n});\n\nconst l = require(\"lodash\"),\n      M = require(\"../abstract/connection-manager\"),\n      {\n  logger: b\n} = require(\"../../utils/logger\"),\n      u = b.debugContext(\"connection:pg\"),\n      d = require(\"../../errors\"),\n      h = require(\"semver\"),\n      O = require(\"../../data-types\"),\n      T = require(\"moment-timezone\"),\n      {\n  promisify: q\n} = require(\"util\");\n\nclass y extends M {\n  constructor(r, s) {\n    s.config.port = s.config.port || 5432;\n    super(r, s);\n\n    const n = this._loadDialectModule(\"pg\");\n\n    this.lib = this.sequelize.config.native ? n.native : n, this._clearDynamicOIDs(), this._clearTypeParser(), this.refreshTypeParser(O.postgres);\n  }\n\n  _refreshTypeParser(r) {\n    const s = c(e => i => this.lib.types.arrayParser.create(i, e).parse(), \"arrayParserBuilder\"),\n          n = c(e => i => r.parse(i, {\n      parser: e\n    }), \"rangeParserBuilder\");\n\n    if (r.key.toLowerCase() === \"range\") {\n      for (const e in this.nameOidMap) {\n        const i = this.nameOidMap[e];\n        if (!i.rangeOid) continue;\n        const t = n(this.getTypeParser(i.oid)),\n              g = s(t);\n        this.oidParserMap.set(i.rangeOid, t), !!i.arrayRangeOid && this.oidParserMap.set(i.arrayRangeOid, g);\n      }\n\n      return;\n    }\n\n    const a = c(e => r.parse(e), \"parser\"),\n          o = s(a);\n\n    if (r.key.toLowerCase() === \"enum\") {\n      this.enumOids.oids.forEach(e => {\n        this.oidParserMap.set(e, a);\n      }), this.enumOids.arrayOids.forEach(e => {\n        this.oidParserMap.set(e, o);\n      });\n      return;\n    }\n\n    r.types.postgres.forEach(e => {\n      !this.nameOidMap[e] || (this.oidParserMap.set(this.nameOidMap[e].oid, a), !!this.nameOidMap[e].arrayOid && this.oidParserMap.set(this.nameOidMap[e].arrayOid, o));\n    });\n  }\n\n  _clearTypeParser() {\n    this.oidParserMap = new Map();\n  }\n\n  getTypeParser(r) {\n    for (var _len = arguments.length, s = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      s[_key - 1] = arguments[_key];\n    }\n\n    return this.oidParserMap.get(r) ? this.oidParserMap.get(r) : this.lib.types.getTypeParser(r, ...s);\n  }\n\n  async connect(r) {\n    r.user = r.username;\n    const s = l.pick(r, [\"user\", \"password\", \"host\", \"database\", \"port\"]);\n    s.types = {\n      getTypeParser: y.prototype.getTypeParser.bind(this)\n    }, r.dialectOptions && l.merge(s, l.pick(r.dialectOptions, [\"application_name\", \"ssl\", \"client_encoding\", \"binary\", \"keepAlive\", \"statement_timeout\", \"query_timeout\", \"idle_in_transaction_session_timeout\", \"options\"]));\n    const n = await new Promise((o, e) => {\n      let i = !1;\n      const t = new this.lib.Client(s),\n            g = c(p => {\n        switch (p.parameterName) {\n          case \"server_version\":\n            if (this.sequelize.options.databaseVersion === 0) {\n              const f = h.coerce(p.parameterValue).version;\n              this.sequelize.options.databaseVersion = h.valid(f) ? f : this.dialect.defaultVersion;\n            }\n\n            break;\n\n          case \"standard_conforming_strings\":\n            t.standard_conforming_strings = p.parameterValue;\n            break;\n        }\n      }, \"parameterHandler\"),\n            m = c(() => {\n        u(\"connection timeout\"), i || e(new d.ConnectionTimedOutError(new Error(\"Connection timed out\")));\n      }, \"endHandler\");\n      t.once(\"end\", m), this.sequelize.config.native || t.connection.on(\"parameterStatus\", g), t.connect(p => {\n        if (i = !0, this.sequelize.config.native || t.connection.removeListener(\"parameterStatus\", g), p) {\n          if (p.code) switch (p.code) {\n            case \"ECONNREFUSED\":\n              e(new d.ConnectionRefusedError(p));\n              break;\n\n            case \"ENOTFOUND\":\n              e(new d.HostNotFoundError(p));\n              break;\n\n            case \"EHOSTUNREACH\":\n              e(new d.HostNotReachableError(p));\n              break;\n\n            case \"EINVAL\":\n              e(new d.InvalidConnectionError(p));\n              break;\n\n            default:\n              e(new d.ConnectionError(p));\n              break;\n          } else e(new d.ConnectionError(p));\n        } else u(\"connection acquired\"), t.removeListener(\"end\", m), o(t);\n      });\n    });\n    let a = \"\";\n    return this.sequelize.options.standardConformingStrings !== !1 && n.standard_conforming_strings !== \"on\" && (a += \"SET standard_conforming_strings=on;\"), this.sequelize.options.clientMinMessages !== !1 && (a += `SET client_min_messages TO ${this.sequelize.options.clientMinMessages};`), this.sequelize.config.keepDefaultTimezone || (!!T.tz.zone(this.sequelize.options.timezone) ? a += `SET TIME ZONE '${this.sequelize.options.timezone}';` : a += `SET TIME ZONE INTERVAL '${this.sequelize.options.timezone}' HOUR TO MINUTE;`), a && (await n.query(a)), Object.keys(this.nameOidMap).length === 0 && this.enumOids.oids.length === 0 && this.enumOids.arrayOids.length === 0 && (await this._refreshDynamicOIDs(n)), n.on(\"error\", o => {\n      n._invalid = !0, u(`connection error ${o.code || o.message}`), this.pool.destroy(n);\n    }), n;\n  }\n\n  async disconnect(r) {\n    if (r._ending) {\n      u(\"connection tried to disconnect but was already at ENDING state\");\n      return;\n    }\n\n    return await q(s => r.end(s))();\n  }\n\n  validate(r) {\n    return !r._invalid && !r._ending;\n  }\n\n  async _refreshDynamicOIDs(r) {\n    const s = this.sequelize.options.databaseVersion,\n          n = \"8.3.0\";\n    if ((s && h.gte(s, n)) === !1) return;\n    const a = await (r || this.sequelize).query(\"WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));\");\n    let o = Array.isArray(a) ? a.pop() : a;\n    Array.isArray(o) && o[0].command === \"SET\" && (o = o.pop());\n    const e = {},\n          i = {\n      oids: [],\n      arrayOids: []\n    };\n\n    for (const t of o.rows) {\n      if (t.typtype === \"e\") {\n        i.oids.push(t.oid), t.typarray && i.arrayOids.push(t.typarray);\n        continue;\n      }\n\n      e[t.typname] = {\n        oid: t.oid\n      }, t.typarray && (e[t.typname].arrayOid = t.typarray), t.rngtypid && (e[t.typname].rangeOid = t.rngtypid, t.rngtyparray && (e[t.typname].arrayRangeOid = t.rngtyparray));\n    }\n\n    this.nameOidMap = e, this.enumOids = i, this.refreshTypeParser(O.postgres);\n  }\n\n  _clearDynamicOIDs() {\n    this.nameOidMap = {}, this.enumOids = {\n      oids: [],\n      arrayOids: []\n    };\n  }\n\n}\n\nc(y, \"ConnectionManager\"), module.exports = y, module.exports.ConnectionManager = y, module.exports.default = y;","map":{"version":3,"sources":["../../../../lib/dialects/postgres/connection-manager.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst { logger } = require('../../utils/logger');\nconst debug = logger.debugContext('connection:pg');\nconst sequelizeErrors = require('../../errors');\nconst semver = require('semver');\nconst dataTypes = require('../../data-types');\nconst moment = require('moment-timezone');\nconst { promisify } = require('util');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 5432;\n    super(dialect, sequelize);\n\n    const pgLib = this._loadDialectModule('pg');\n    this.lib = this.sequelize.config.native ? pgLib.native : pgLib;\n\n    this._clearDynamicOIDs();\n    this._clearTypeParser();\n    this.refreshTypeParser(dataTypes.postgres);\n  }\n\n  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n  _refreshTypeParser(dataType) {\n    const arrayParserBuilder = parser => {\n      return value => this.lib.types.arrayParser.create(value, parser).parse();\n    };\n    const rangeParserBuilder = parser => {\n      return value => dataType.parse(value, { parser });\n    };\n\n    // Set range parsers\n    if (dataType.key.toLowerCase() === 'range') {\n      for (const name in this.nameOidMap) {\n        const entry = this.nameOidMap[name];\n        if (! entry.rangeOid) continue;\n\n        const rangeParser = rangeParserBuilder(this.getTypeParser(entry.oid));\n        const arrayRangeParser = arrayParserBuilder(rangeParser);\n\n        this.oidParserMap.set(entry.rangeOid, rangeParser);\n        if (! entry.arrayRangeOid) continue;\n        this.oidParserMap.set(entry.arrayRangeOid, arrayRangeParser);\n      }\n      return;\n    }\n\n    // Create parsers for normal or enum data types\n    const parser = value => dataType.parse(value);\n    const arrayParser = arrayParserBuilder(parser);\n\n    // Set enum parsers\n    if (dataType.key.toLowerCase() === 'enum') {\n      this.enumOids.oids.forEach(oid => {\n        this.oidParserMap.set(oid, parser);\n      });\n      this.enumOids.arrayOids.forEach(arrayOid => {\n        this.oidParserMap.set(arrayOid, arrayParser);\n      });\n      return;\n    }\n\n    // Set parsers for normal data types\n    dataType.types.postgres.forEach(name => {\n      if (! this.nameOidMap[name]) return;\n      this.oidParserMap.set(this.nameOidMap[name].oid, parser);\n\n      if (! this.nameOidMap[name].arrayOid) return;\n      this.oidParserMap.set(this.nameOidMap[name].arrayOid, arrayParser);\n    });\n  }\n\n  _clearTypeParser() {\n    this.oidParserMap = new Map();\n  }\n\n  getTypeParser(oid, ...args) {\n    if (this.oidParserMap.get(oid)) return this.oidParserMap.get(oid);\n\n    return this.lib.types.getTypeParser(oid, ...args);\n  }\n\n  async connect(config) {\n    config.user = config.username;\n    const connectionConfig = _.pick(config, [\n      'user', 'password', 'host', 'database', 'port'\n    ]);\n\n    connectionConfig.types = {\n      getTypeParser: ConnectionManager.prototype.getTypeParser.bind(this)\n    };\n\n    if (config.dialectOptions) {\n      _.merge(connectionConfig,\n        _.pick(config.dialectOptions, [\n        // see [http://www.postgresql.org/docs/9.3/static/runtime-config-logging.html#GUC-APPLICATION-NAME]\n          'application_name',\n          // choose the SSL mode with the PGSSLMODE environment variable\n          // object format: [https://github.com/brianc/node-postgres/blob/ee19e74ffa6309c9c5e8e01746261a8f651661f8/lib/connection.js#L79]\n          // see also [http://www.postgresql.org/docs/9.3/static/libpq-ssl.html]\n          'ssl',\n          // In addition to the values accepted by the corresponding server,\n          // you can use \"auto\" to determine the right encoding from the\n          // current locale in the client (LC_CTYPE environment variable on Unix systems)\n          'client_encoding',\n          // !! DO NOT SET THIS TO TRUE !!\n          // (unless you know what you're doing)\n          // see [http://www.postgresql.org/message-id/flat/bc9549a50706040852u27633f41ib1e6b09f8339d845@mail.gmail.com#bc9549a50706040852u27633f41ib1e6b09f8339d845@mail.gmail.com]\n          'binary',\n          // This should help with backends incorrectly considering idle clients to be dead and prematurely disconnecting them.\n          // this feature has been added in pg module v6.0.0, check pg/CHANGELOG.md\n          'keepAlive',\n          // Times out queries after a set time in milliseconds in the database end. Added in pg v7.3\n          'statement_timeout',\n          // Times out queries after a set time in milliseconds in client end, query would be still running in database end.\n          'query_timeout',\n          // Terminate any session with an open transaction that has been idle for longer than the specified duration in milliseconds. Added in pg v7.17.0 only supported in postgres >= 10\n          'idle_in_transaction_session_timeout',\n          // Postgres allows additional session variables to be configured in the connection string in the `options` param.\n          // see [https://www.postgresql.org/docs/14/libpq-connect.html#LIBPQ-CONNECT-OPTIONS]\n          'options'\n        ]));\n    }\n\n    const connection = await new Promise((resolve, reject) => {\n      let responded = false;\n\n      const connection = new this.lib.Client(connectionConfig);\n\n      const parameterHandler = message => {\n        switch (message.parameterName) {\n          case 'server_version':\n            if (this.sequelize.options.databaseVersion === 0) {\n              const version = semver.coerce(message.parameterValue).version;\n              this.sequelize.options.databaseVersion = semver.valid(version)\n                ? version\n                : this.dialect.defaultVersion;\n            }\n            break;\n          case 'standard_conforming_strings':\n            connection['standard_conforming_strings'] = message.parameterValue;\n            break;\n        }\n      };\n\n      const endHandler = () => {\n        debug('connection timeout');\n        if (!responded) {\n          reject(new sequelizeErrors.ConnectionTimedOutError(new Error('Connection timed out')));\n        }\n      };\n\n      // If we didn't ever hear from the client.connect() callback the connection timeout\n      // node-postgres does not treat this as an error since no active query was ever emitted\n      connection.once('end', endHandler);\n\n      if (!this.sequelize.config.native) {\n        // Receive various server parameters for further configuration\n        connection.connection.on('parameterStatus', parameterHandler);\n      }\n\n      connection.connect(err => {\n        responded = true;\n\n        if (!this.sequelize.config.native) {\n          // remove parameter handler\n          connection.connection.removeListener('parameterStatus', parameterHandler);\n        }\n\n        if (err) {\n          if (err.code) {\n            switch (err.code) {\n              case 'ECONNREFUSED':\n                reject(new sequelizeErrors.ConnectionRefusedError(err));\n                break;\n              case 'ENOTFOUND':\n                reject(new sequelizeErrors.HostNotFoundError(err));\n                break;\n              case 'EHOSTUNREACH':\n                reject(new sequelizeErrors.HostNotReachableError(err));\n                break;\n              case 'EINVAL':\n                reject(new sequelizeErrors.InvalidConnectionError(err));\n                break;\n              default:\n                reject(new sequelizeErrors.ConnectionError(err));\n                break;\n            }\n          } else {\n            reject(new sequelizeErrors.ConnectionError(err));\n          }\n        } else {\n          debug('connection acquired');\n          connection.removeListener('end', endHandler);\n          resolve(connection);\n        }\n      });\n    });\n\n    let query = '';\n\n    if (this.sequelize.options.standardConformingStrings !== false && connection['standard_conforming_strings'] !== 'on') {\n      // Disable escape characters in strings\n      // see https://github.com/sequelize/sequelize/issues/3545 (security issue)\n      // see https://www.postgresql.org/docs/current/static/runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS\n      query += 'SET standard_conforming_strings=on;';\n    }\n\n    if (this.sequelize.options.clientMinMessages !== false) {\n      query += `SET client_min_messages TO ${this.sequelize.options.clientMinMessages};`;\n    }\n\n    if (!this.sequelize.config.keepDefaultTimezone) {\n      const isZone = !!moment.tz.zone(this.sequelize.options.timezone);\n      if (isZone) {\n        query += `SET TIME ZONE '${this.sequelize.options.timezone}';`;\n      } else {\n        query += `SET TIME ZONE INTERVAL '${this.sequelize.options.timezone}' HOUR TO MINUTE;`;\n      }\n    }\n\n    if (query) {\n      await connection.query(query);\n    }\n    if (Object.keys(this.nameOidMap).length === 0 &&\n      this.enumOids.oids.length === 0 &&\n      this.enumOids.arrayOids.length === 0) {\n      await this._refreshDynamicOIDs(connection);\n    }\n    // Don't let a Postgres restart (or error) to take down the whole app\n    connection.on('error', error => {\n      connection._invalid = true;\n      debug(`connection error ${error.code || error.message}`);\n      this.pool.destroy(connection);\n    });\n\n    return connection;\n  }\n\n  async disconnect(connection) {\n    if (connection._ending) {\n      debug('connection tried to disconnect but was already at ENDING state');\n      return;\n    }\n\n    return await promisify(callback => connection.end(callback))();\n  }\n\n  validate(connection) {\n    return !connection._invalid && !connection._ending;\n  }\n\n  async _refreshDynamicOIDs(connection) {\n    const databaseVersion = this.sequelize.options.databaseVersion;\n    const supportedVersion = '8.3.0';\n\n    // Check for supported version\n    if ( (databaseVersion && semver.gte(databaseVersion, supportedVersion)) === false) {\n      return;\n    }\n\n    const results = await (connection || this.sequelize).query(\n      'WITH ranges AS (' +\n      '  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,' +\n      '         pg_type.typarray AS rngtyparray, pg_range.rngsubtype' +\n      '    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid' +\n      ')' +\n      'SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,' +\n      '       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray' +\n      '  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype' +\n      ' WHERE (pg_type.typtype IN(\\'b\\', \\'e\\'));'\n    );\n\n    let result = Array.isArray(results) ? results.pop() : results;\n\n    // When searchPath is prepended then two statements are executed and the result is\n    // an array of those two statements. First one is the SET search_path and second is\n    // the SELECT query result.\n    if (Array.isArray(result)) {\n      if (result[0].command === 'SET') {\n        result = result.pop();\n      }\n    }\n\n    const newNameOidMap = {};\n    const newEnumOids = { oids: [], arrayOids: [] };\n\n    for (const row of result.rows) {\n      // Mapping enums, handled separatedly\n      if (row.typtype === 'e') {\n        newEnumOids.oids.push(row.oid);\n        if (row.typarray) newEnumOids.arrayOids.push(row.typarray);\n        continue;\n      }\n\n      // Mapping base types and their arrays\n      newNameOidMap[row.typname] = { oid: row.oid };\n      if (row.typarray) newNameOidMap[row.typname].arrayOid = row.typarray;\n\n      // Mapping ranges(of base types) and their arrays\n      if (row.rngtypid) {\n        newNameOidMap[row.typname].rangeOid = row.rngtypid;\n        if (row.rngtyparray) newNameOidMap[row.typname].arrayRangeOid = row.rngtyparray;\n      }\n    }\n\n    // Replace all OID mappings. Avoids temporary empty OID mappings.\n    this.nameOidMap = newNameOidMap;\n    this.enumOids = newEnumOids;\n\n    this.refreshTypeParser(dataTypes.postgres);\n  }\n\n  _clearDynamicOIDs() {\n    this.nameOidMap = {};\n    this.enumOids = { oids: [], arrayOids: [] };\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}