{"ast":null,"code":"\"use strict\";\n\nvar f = Object.defineProperty;\n\nvar h = (g, s) => f(g, \"name\", {\n  value: s,\n  configurable: !0\n});\n\nconst d = require(\"./base-error\");\n\nclass u extends d {\n  constructor(s, i, t) {\n    super(s);\n    this.name = \"SequelizeValidationError\", this.message = \"Validation Error\", this.errors = i || [], s ? this.message = s : this.errors.length > 0 && this.errors[0].message && (this.message = this.errors.map(e => `${e.type || e.origin}: ${e.message}`).join(`,\n`)), t && t.stack && (this.stack = t.stack);\n  }\n\n  get(s) {\n    return this.errors.reduce((i, t) => (t.path === s && i.push(t), i), []);\n  }\n\n}\n\nh(u, \"ValidationError\");\n\nclass r {\n  constructor(s, i, t, e, o, n, a, c) {\n    if (this.message = s || \"\", this.type = null, this.path = t || null, this.value = e !== void 0 ? e : null, this.origin = null, this.instance = o || null, this.validatorKey = n || null, this.validatorName = a || null, this.validatorArgs = c || [], i) if (r.Origins[i]) this.origin = i;else {\n      const p = `${i}`.toLowerCase().trim(),\n            l = r.TypeStringMap[p];\n      l && r.Origins[l] && (this.origin = l, this.type = i);\n    }\n  }\n\n  getValidatorKey(s, i) {\n    const t = s === void 0 || !!s,\n          e = i === void 0 ? \".\" : i,\n          o = this.origin,\n          n = this.validatorKey || this.validatorName,\n          a = t && o && r.Origins[o];\n    if (a && (typeof e != \"string\" || !e.length)) throw new Error(\"Invalid namespace separator given, must be a non-empty string\");\n    return typeof n == \"string\" && n.length ? (a ? [o, n].join(e) : n).toLowerCase().trim() : \"\";\n  }\n\n}\n\nh(r, \"ValidationErrorItem\"), r.Origins = {\n  CORE: \"CORE\",\n  DB: \"DB\",\n  FUNCTION: \"FUNCTION\"\n}, r.TypeStringMap = {\n  \"notnull violation\": \"CORE\",\n  \"string violation\": \"CORE\",\n  \"unique violation\": \"DB\",\n  \"validation error\": \"FUNCTION\"\n}, module.exports = u, module.exports.ValidationErrorItem = r;","map":{"version":3,"sources":["../../../lib/errors/validation-error.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst BaseError = require('./base-error');\n\n/**\n * Validation Error. Thrown when the sequelize validation has failed. The error contains an `errors` property,\n * which is an array with 1 or more ValidationErrorItems, one for each validation that failed.\n *\n * @param {string} message Error message\n * @param {Array} [errors] Array of ValidationErrorItem objects describing the validation errors\n *\n * @property errors {ValidationErrorItems[]}\n */\nclass ValidationError extends BaseError {\n  constructor(message, errors, options) {\n    super(message);\n    this.name = 'SequelizeValidationError';\n    this.message = 'Validation Error';\n    /**\n     *\n     * @type {ValidationErrorItem[]}\n     */\n    this.errors = errors || [];\n\n    // Use provided error message if available...\n    if (message) {\n      this.message = message;\n\n      // ... otherwise create a concatenated message out of existing errors.\n    } else if (this.errors.length > 0 && this.errors[0].message) {\n      this.message = this.errors.map(err => `${err.type || err.origin}: ${err.message}`).join(',\\n');\n    }\n\n    // Allow overriding the stack if the original stacktrace is uninformative\n    if (options && options.stack) {\n      this.stack = options.stack;\n    }\n  }\n\n  /**\n   * Gets all validation error items for the path / field specified.\n   *\n   * @param {string} path The path to be checked for error items\n   *\n   * @returns {Array<ValidationErrorItem>} Validation error items for the specified path\n   */\n  get(path) {\n    return this.errors.reduce((reduced, error) => {\n      if (error.path === path) {\n        reduced.push(error);\n      }\n      return reduced;\n    }, []);\n  }\n}\n\n/**\n * Validation Error Item\n * Instances of this class are included in the `ValidationError.errors` property.\n */\nclass ValidationErrorItem {\n  /**\n   * Creates a new ValidationError item. Instances of this class are included in the `ValidationError.errors` property.\n   *\n   * @param {string} [message] An error message\n   * @param {string} [type] The type/origin of the validation error\n   * @param {string} [path] The field that triggered the validation error\n   * @param {string} [value] The value that generated the error\n   * @param {Model} [instance] the DAO instance that caused the validation error\n   * @param {string} [validatorKey] a validation \"key\", used for identification\n   * @param {string} [fnName] property name of the BUILT-IN validator function that caused the validation error (e.g. \"in\" or \"len\"), if applicable\n   * @param {Array} [fnArgs] parameters used with the BUILT-IN validator function, if applicable\n   */\n  constructor(message, type, path, value, instance, validatorKey, fnName, fnArgs) {\n    /**\n     * An error message\n     *\n     * @type {string} message\n     */\n    this.message = message || '';\n\n    /**\n     * The type/origin of the validation error\n     *\n     * @type {string | null}\n     */\n    this.type = null;\n\n    /**\n     * The field that triggered the validation error\n     *\n     * @type {string | null}\n     */\n    this.path = path || null;\n\n    /**\n     * The value that generated the error\n     *\n     * @type {string | null}\n     */\n    this.value = value !== undefined ? value : null;\n\n    this.origin = null;\n\n    /**\n     * The DAO instance that caused the validation error\n     *\n     * @type {Model | null}\n     */\n    this.instance = instance || null;\n\n    /**\n     * A validation \"key\", used for identification\n     *\n     * @type {string | null}\n     */\n    this.validatorKey = validatorKey || null;\n\n    /**\n     * Property name of the BUILT-IN validator function that caused the validation error (e.g. \"in\" or \"len\"), if applicable\n     *\n     * @type {string | null}\n     */\n    this.validatorName = fnName || null;\n\n    /**\n     * Parameters used with the BUILT-IN validator function, if applicable\n     *\n     * @type {Array}\n     */\n    this.validatorArgs = fnArgs || [];\n\n    if (type) {\n      if (ValidationErrorItem.Origins[ type ]) {\n        this.origin = type;\n      } else {\n        const lowercaseType = `${type}`.toLowerCase().trim();\n        const realType = ValidationErrorItem.TypeStringMap[ lowercaseType ];\n\n        if (realType && ValidationErrorItem.Origins[ realType ]) {\n          this.origin = realType;\n          this.type = type;\n        }\n      }\n    }\n\n    // This doesn't need captureStackTrace because it's not a subclass of Error\n  }\n\n  /**\n   * return a lowercase, trimmed string \"key\" that identifies the validator.\n   *\n   * Note: the string will be empty if the instance has neither a valid `validatorKey` property nor a valid `validatorName` property\n   *\n   * @param   {boolean} [useTypeAsNS=true]      controls whether the returned value is \"namespace\",\n   *                                            this parameter is ignored if the validator's `type` is not one of ValidationErrorItem.Origins\n   * @param   {string}  [NSSeparator='.']       a separator string for concatenating the namespace, must be not be empty,\n   *                                            defaults to \".\" (fullstop). only used and validated if useTypeAsNS is TRUE.\n   * @throws  {Error}                           thrown if NSSeparator is found to be invalid.\n   * @returns  {string}\n   *\n   * @private\n   */\n  getValidatorKey(useTypeAsNS, NSSeparator) {\n    const useTANS = useTypeAsNS === undefined || !!useTypeAsNS;\n    const NSSep = NSSeparator === undefined ? '.' : NSSeparator;\n\n    const type = this.origin;\n    const key = this.validatorKey || this.validatorName;\n    const useNS = useTANS && type && ValidationErrorItem.Origins[ type ];\n\n    if (useNS && (typeof NSSep !== 'string' || !NSSep.length)) {\n      throw new Error('Invalid namespace separator given, must be a non-empty string');\n    }\n\n    if (!(typeof key === 'string' && key.length)) {\n      return '';\n    }\n\n    return (useNS ? [type, key].join(NSSep) : key).toLowerCase().trim();\n  }\n}\n\n/**\n * An enum that defines valid ValidationErrorItem `origin` values\n *\n * @type {object}\n * @property CORE       {string}  specifies errors that originate from the sequelize \"core\"\n * @property DB         {string}  specifies validation errors that originate from the storage engine\n * @property FUNCTION   {string}  specifies validation errors that originate from validator functions (both built-in and custom) defined for a given attribute\n */\nValidationErrorItem.Origins = {\n  CORE: 'CORE',\n  DB: 'DB',\n  FUNCTION: 'FUNCTION'\n};\n\n/**\n * An object that is used internally by the `ValidationErrorItem` class\n * that maps current `type` strings (as given to ValidationErrorItem.constructor()) to\n * our new `origin` values.\n *\n * @type {object}\n */\nValidationErrorItem.TypeStringMap = {\n  'notnull violation': 'CORE',\n  'string violation': 'CORE',\n  'unique violation': 'DB',\n  'validation error': 'FUNCTION'\n};\n\nmodule.exports = ValidationError;\nmodule.exports.ValidationErrorItem = ValidationErrorItem;\n"]},"metadata":{},"sourceType":"script"}