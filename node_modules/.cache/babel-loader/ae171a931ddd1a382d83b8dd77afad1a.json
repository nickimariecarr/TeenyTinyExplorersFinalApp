{"ast":null,"code":"\"use strict\";\n\nvar b = Object.defineProperty;\n\nvar A = (R, e) => b(R, \"name\", {\n  value: e,\n  configurable: !0\n});\n\nconst m = require(\"lodash\"),\n      I = require(\"../../utils\"),\n      T = require(\"../abstract/query\"),\n      y = require(\"../../query-types\"),\n      E = require(\"../../errors\"),\n      q = require(\"../parserStore\")(\"sqlite\"),\n      {\n  logger: w\n} = require(\"../../utils/logger\"),\n      Q = w.debugContext(\"sql:sqlite\");\n\nclass g extends T {\n  getInsertIdField() {\n    return \"lastID\";\n  }\n\n  static formatBindParameters(e, s, n) {\n    let t;\n    if (Array.isArray(s)) t = {}, s.forEach((l, i) => {\n      t[`$${i + 1}`] = l;\n    }), e = T.formatBindParameters(e, s, n, {\n      skipValueReplace: !0\n    })[0];else {\n      if (t = {}, typeof s == \"object\") for (const l of Object.keys(s)) t[`$${l}`] = s[l];\n      e = T.formatBindParameters(e, s, n, {\n        skipValueReplace: !0\n      })[0];\n    }\n    return [e, t];\n  }\n\n  _collectModels(e, s) {\n    const n = {};\n    if (e) for (const t of e) {\n      let l;\n      s ? l = `${s}.${t.as}` : l = t.as, n[l] = t.model, t.include && m.merge(n, this._collectModels(t.include, l));\n    }\n    return n;\n  }\n\n  _handleQueryResponse(e, s, n, t, l) {\n    if (n) throw n.sql = this.sql, this.formatError(n, l);\n    let i = this.instance;\n    if ((this.isInsertQuery(t, e) || this.isUpsertQuery()) && (this.handleInsertQuery(t, e), !this.instance)) if (e.constructor.name === \"Statement\" && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n      const r = e[this.getInsertIdField()] - e.changes + 1;\n      i = [];\n\n      for (let o = r; o < r + e.changes; o++) i.push({\n        [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: o\n      });\n    } else i = e[this.getInsertIdField()];\n    if (this.isShowTablesQuery()) return t.map(r => r.name);\n    if (this.isShowConstraintsQuery()) return i = t, t && t[0] && t[0].sql && (i = this.parseConstraintsFromSql(t[0].sql)), i;\n\n    if (this.isSelectQuery()) {\n      if (this.options.raw) return this.handleSelectQuery(t);\n\n      const r = this._collectModels(this.options.include);\n\n      return t = t.map(o => m.mapValues(o, (f, c) => {\n        let u;\n\n        if (c.includes(\".\")) {\n          const d = c.lastIndexOf(\".\");\n          u = r[c.substr(0, d)], c = c.substr(d + 1);\n        } else u = this.options.model;\n\n        const a = u.getTableName().toString().replace(/`/g, \"\"),\n              h = s[a] || {};\n        return h && !(c in h) && m.forOwn(u.rawAttributes, (d, p) => {\n          if (c === p && d.field) return c = d.field, !1;\n        }), Object.prototype.hasOwnProperty.call(h, c) ? this.applyParsers(h[c], f) : f;\n      })), this.handleSelectQuery(t);\n    }\n\n    if (this.isShowOrDescribeQuery()) return t;\n    if (this.sql.includes(\"PRAGMA INDEX_LIST\")) return this.handleShowIndexesQuery(t);\n    if (this.sql.includes(\"PRAGMA INDEX_INFO\")) return t;\n\n    if (this.sql.includes(\"PRAGMA TABLE_INFO\")) {\n      i = {};\n      let r;\n\n      for (const o of t) o.dflt_value === null ? r = void 0 : o.dflt_value === \"NULL\" ? r = null : r = o.dflt_value, i[o.name] = {\n        type: o.type,\n        allowNull: o.notnull === 0,\n        defaultValue: r,\n        primaryKey: o.pk !== 0\n      }, i[o.name].type === \"TINYINT(1)\" && (i[o.name].defaultValue = {\n        \"0\": !1,\n        \"1\": !0\n      }[i[o.name].defaultValue]), typeof i[o.name].defaultValue == \"string\" && (i[o.name].defaultValue = i[o.name].defaultValue.replace(/'/g, \"\"));\n\n      return i;\n    }\n\n    return this.sql.includes(\"PRAGMA foreign_keys;\") ? t[0] : this.sql.includes(\"PRAGMA foreign_keys\") || this.sql.includes(\"PRAGMA foreign_key_list\") ? t : [y.BULKUPDATE, y.BULKDELETE].includes(this.options.type) ? e.changes : this.options.type === y.VERSION ? t[0].version : this.options.type === y.RAW ? [t, e] : this.isUpsertQuery() ? [i, null] : this.isUpdateQuery() || this.isInsertQuery() ? [i, e.changes] : i;\n  }\n\n  async run(e, s) {\n    const n = this.connection;\n    this.sql = e;\n\n    const t = this.getDatabaseMethod(),\n          l = this._logQuery(e, Q, s);\n\n    return new Promise((i, r) => n.serialize(async () => {\n      const o = {},\n            f = new Error(),\n            c = A(() => {\n        if (e.startsWith(\"-- \")) return i();\n        const u = this;\n\n        function a(h, d) {\n          try {\n            l(), i(u._handleQueryResponse(this, o, h, d, f.stack));\n            return;\n          } catch (p) {\n            r(p);\n          }\n        }\n\n        return A(a, \"afterExecute\"), s || (s = []), n[t](e, s, a), null;\n      }, \"executeSql\");\n\n      if (this.getDatabaseMethod() === \"all\") {\n        let u = [];\n        if (this.options && this.options.tableNames ? u = this.options.tableNames : /FROM `(.*?)`/i.exec(this.sql) && u.push(/FROM `(.*?)`/i.exec(this.sql)[1]), u = u.filter(a => !(a in o) && a !== \"sqlite_master\"), !u.length) return c();\n        await Promise.all(u.map(a => new Promise(h => {\n          a = a.replace(/`/g, \"\"), o[a] = {}, n.all(`PRAGMA table_info(\\`${a}\\`)`, (d, p) => {\n            if (!d) for (const N of p) o[a][N.name] = N.type;\n            h();\n          });\n        })));\n      }\n\n      return c();\n    }));\n  }\n\n  parseConstraintsFromSql(e) {\n    let s = e.split(\"CONSTRAINT \"),\n        n,\n        t,\n        l,\n        i;\n    return s.splice(0, 1), s = s.map(r => {\n      if (r.includes(\"REFERENCES\")) {\n        l = r.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/), i = r.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/), l && (l = l[1]), i && (i = i[1]);\n        const c = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/,\n              u = r.match(c)[0].split(\" \");\n        n = I.removeTicks(u[1]);\n        let a = u[2];\n        a = a.replace(/\\(|\\)/g, \"\").split(\", \"), t = a.map(h => I.removeTicks(h));\n      }\n\n      const o = r.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n      r = r.replace(/\\(.+\\)/, \"\");\n      const f = r.split(\" \");\n      return (f[1] === \"PRIMARY\" || f[1] === \"FOREIGN\") && (f[1] += \" KEY\"), {\n        constraintName: I.removeTicks(f[0]),\n        constraintType: f[1],\n        updateAction: l,\n        deleteAction: i,\n        sql: e.replace(/\"/g, \"`\"),\n        constraintCondition: o,\n        referenceTableName: n,\n        referenceTableKeys: t\n      };\n    }), s;\n  }\n\n  applyParsers(e, s) {\n    e.includes(\"(\") && (e = e.substr(0, e.indexOf(\"(\"))), e = e.replace(\"UNSIGNED\", \"\").replace(\"ZEROFILL\", \"\"), e = e.trim().toUpperCase();\n    const n = q.get(e);\n    return s !== null && n ? n(s, {\n      timezone: this.sequelize.options.timezone\n    }) : s;\n  }\n\n  formatError(e, s) {\n    switch (e.code) {\n      case \"SQLITE_CONSTRAINT\":\n        {\n          if (e.message.includes(\"FOREIGN KEY constraint failed\")) return new E.ForeignKeyConstraintError({\n            parent: e,\n            stack: s\n          });\n          let n = [],\n              t = e.message.match(/columns (.*?) are/);\n          t !== null && t.length >= 2 ? n = t[1].split(\", \") : (t = e.message.match(/UNIQUE constraint failed: (.*)/), t !== null && t.length >= 2 && (n = t[1].split(\", \").map(r => r.split(\".\")[1])));\n          const l = [];\n          let i = \"Validation error\";\n\n          for (const r of n) l.push(new E.ValidationErrorItem(this.getUniqueConstraintErrorMessage(r), \"unique violation\", r, this.instance && this.instance[r], this.instance, \"not_unique\"));\n\n          return this.model && m.forOwn(this.model.uniqueKeys, r => {\n            if (m.isEqual(r.fields, n) && !!r.msg) return i = r.msg, !1;\n          }), new E.UniqueConstraintError({\n            message: i,\n            errors: l,\n            parent: e,\n            fields: n,\n            stack: s\n          });\n        }\n\n      case \"SQLITE_BUSY\":\n        return new E.TimeoutError(e, {\n          stack: s\n        });\n\n      default:\n        return new E.DatabaseError(e, {\n          stack: s\n        });\n    }\n  }\n\n  async handleShowIndexesQuery(e) {\n    return Promise.all(e.reverse().map(async s => {\n      s.fields = [], s.primary = !1, s.unique = !!s.unique, s.constraintName = s.name;\n      const n = await this.run(`PRAGMA INDEX_INFO(\\`${s.name}\\`)`);\n\n      for (const t of n) s.fields[t.seqno] = {\n        attribute: t.name,\n        length: void 0,\n        order: void 0\n      };\n\n      return s;\n    }));\n  }\n\n  getDatabaseMethod() {\n    return this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes(\"CREATE TEMPORARY TABLE\".toLowerCase()) || this.options.type === y.BULKDELETE ? \"run\" : \"all\";\n  }\n\n}\n\nA(g, \"Query\"), module.exports = g, module.exports.Query = g, module.exports.default = g;","map":{"version":3,"sources":["../../../../lib/dialects/sqlite/query.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst AbstractQuery = require('../abstract/query');\nconst QueryTypes = require('../../query-types');\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('sqlite');\nconst { logger } = require('../../utils/logger');\n\nconst debug = logger.debugContext('sql:sqlite');\n\n\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return 'lastID';\n  }\n\n  /**\n   * rewrite query with parameters.\n   *\n   * @param {string} sql\n   * @param {Array|object} values\n   * @param {string} dialect\n   * @private\n   */\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam;\n    if (Array.isArray(values)) {\n      bindParam = {};\n      values.forEach((v, i) => {\n        bindParam[`$${i + 1}`] = v;\n      });\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    } else {\n      bindParam = {};\n      if (typeof values === 'object') {\n        for (const k of Object.keys(values)) {\n          bindParam[`$${k}`] = values[k];\n        }\n      }\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    }\n    return [sql, bindParam];\n  }\n\n  _collectModels(include, prefix) {\n    const ret = {};\n\n    if (include) {\n      for (const _include of include) {\n        let key;\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = `${prefix}.${_include.as}`;\n        }\n        ret[key] = _include.model;\n\n        if (_include.include) {\n          _.merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  _handleQueryResponse(metaData, columnTypes, err, results, errStack) {\n    if (err) {\n      err.sql = this.sql;\n      throw this.formatError(err, errStack);\n    }\n    let result = this.instance;\n\n    // add the inserted row id to the instance\n    if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {\n      this.handleInsertQuery(results, metaData);\n      if (!this.instance) {\n        // handle bulkCreate AI primary key\n        if (\n          metaData.constructor.name === 'Statement'\n          && this.model\n          && this.model.autoIncrementAttribute\n          && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute\n          && this.model.rawAttributes[this.model.primaryKeyAttribute]\n        ) {\n          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\n          result = [];\n          for (let i = startId; i < startId + metaData.changes; i++) {\n            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });\n          }\n        } else {\n          result = metaData[this.getInsertIdField()];\n        }\n      }\n    }\n\n    if (this.isShowTablesQuery()) {\n      return results.map(row => row.name);\n    }\n    if (this.isShowConstraintsQuery()) {\n      result = results;\n      if (results && results[0] && results[0].sql) {\n        result = this.parseConstraintsFromSql(results[0].sql);\n      }\n      return result;\n    }\n    if (this.isSelectQuery()) {\n      if (this.options.raw) {\n        return this.handleSelectQuery(results);\n      }\n      // This is a map of prefix strings to models, e.g. user.projects -> Project model\n      const prefixes = this._collectModels(this.options.include);\n\n      results = results.map(result => {\n        return _.mapValues(result, (value, name) => {\n          let model;\n          if (name.includes('.')) {\n            const lastind = name.lastIndexOf('.');\n\n            model = prefixes[name.substr(0, lastind)];\n\n            name = name.substr(lastind + 1);\n          } else {\n            model = this.options.model;\n          }\n\n          const tableName = model.getTableName().toString().replace(/`/g, '');\n          const tableTypes = columnTypes[tableName] || {};\n\n          if (tableTypes && !(name in tableTypes)) {\n            // The column is aliased\n            _.forOwn(model.rawAttributes, (attribute, key) => {\n              if (name === key && attribute.field) {\n                name = attribute.field;\n                return false;\n              }\n            });\n          }\n\n          return Object.prototype.hasOwnProperty.call(tableTypes, name)\n            ? this.applyParsers(tableTypes[name], value)\n            : value;\n        });\n      });\n\n      return this.handleSelectQuery(results);\n    }\n    if (this.isShowOrDescribeQuery()) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA INDEX_LIST')) {\n      return this.handleShowIndexesQuery(results);\n    }\n    if (this.sql.includes('PRAGMA INDEX_INFO')) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA TABLE_INFO')) {\n      // this is the sqlite way of getting the metadata of a table\n      result = {};\n\n      let defaultValue;\n      for (const _result of results) {\n        if (_result.dflt_value === null) {\n          // Column schema omits any \"DEFAULT ...\"\n          defaultValue = undefined;\n        } else if (_result.dflt_value === 'NULL') {\n          // Column schema is a \"DEFAULT NULL\"\n          defaultValue = null;\n        } else {\n          defaultValue = _result.dflt_value;\n        }\n\n        result[_result.name] = {\n          type: _result.type,\n          allowNull: _result.notnull === 0,\n          defaultValue,\n          primaryKey: _result.pk !== 0\n        };\n\n        if (result[_result.name].type === 'TINYINT(1)') {\n          result[_result.name].defaultValue = { '0': false, '1': true }[result[_result.name].defaultValue];\n        }\n\n        if (typeof result[_result.name].defaultValue === 'string') {\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, '');\n        }\n      }\n      return result;\n    }\n    if (this.sql.includes('PRAGMA foreign_keys;')) {\n      return results[0];\n    }\n    if (this.sql.includes('PRAGMA foreign_keys')) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA foreign_key_list')) {\n      return results;\n    }\n    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\n      return metaData.changes;\n    }\n    if (this.options.type === QueryTypes.VERSION) {\n      return results[0].version;\n    }\n    if (this.options.type === QueryTypes.RAW) {\n      return [results, metaData];\n    }\n    if (this.isUpsertQuery()) {\n      return [result, null];\n    }\n    if (this.isUpdateQuery() || this.isInsertQuery()) {\n      return [result, metaData.changes];\n    }\n    return result;\n  }\n\n  async run(sql, parameters) {\n    const conn = this.connection;\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n    const complete = this._logQuery(sql, debug, parameters);\n\n    return new Promise((resolve, reject) => conn.serialize(async () => {\n      const columnTypes = {};\n      const errForStack = new Error();\n      const executeSql = () => {\n        if (sql.startsWith('-- ')) {\n          return resolve();\n        }\n        const query = this;\n        // cannot use arrow function here because the function is bound to the statement\n        function afterExecute(executionError, results) {\n          try {\n            complete();\n            // `this` is passed from sqlite, we have no control over this.\n            // eslint-disable-next-line no-invalid-this\n            resolve(query._handleQueryResponse(this, columnTypes, executionError, results, errForStack.stack));\n            return;\n          } catch (error) {\n            reject(error);\n          }\n        }\n\n        if (!parameters) parameters = [];\n        conn[method](sql, parameters, afterExecute);\n\n        return null;\n      };\n\n      if (this.getDatabaseMethod() === 'all') {\n        let tableNames = [];\n        if (this.options && this.options.tableNames) {\n          tableNames = this.options.tableNames;\n        } else if (/FROM `(.*?)`/i.exec(this.sql)) {\n          tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);\n        }\n\n        // If we already have the metadata for the table, there's no need to ask for it again\n        tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== 'sqlite_master');\n\n        if (!tableNames.length) {\n          return executeSql();\n        }\n        await Promise.all(tableNames.map(tableName =>\n          new Promise(resolve => {\n            tableName = tableName.replace(/`/g, '');\n            columnTypes[tableName] = {};\n\n            conn.all(`PRAGMA table_info(\\`${tableName}\\`)`, (err, results) => {\n              if (!err) {\n                for (const result of results) {\n                  columnTypes[tableName][result.name] = result.type;\n                }\n              }\n              resolve();\n            });\n          })));\n      }\n      return executeSql();\n    }));\n  }\n\n  parseConstraintsFromSql(sql) {\n    let constraints = sql.split('CONSTRAINT ');\n    let referenceTableName, referenceTableKeys, updateAction, deleteAction;\n    constraints.splice(0, 1);\n    constraints = constraints.map(constraintSql => {\n      //Parse foreign key snippets\n      if (constraintSql.includes('REFERENCES')) {\n        //Parse out the constraint condition form sql string\n        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n\n        if (updateAction) {\n          updateAction = updateAction[1];\n        }\n\n        if (deleteAction) {\n          deleteAction = deleteAction[1];\n        }\n\n        const referencesRegex = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/;\n        const referenceConditions = constraintSql.match(referencesRegex)[0].split(' ');\n        referenceTableName = Utils.removeTicks(referenceConditions[1]);\n        let columnNames = referenceConditions[2];\n        columnNames = columnNames.replace(/\\(|\\)/g, '').split(', ');\n        referenceTableKeys = columnNames.map(column => Utils.removeTicks(column));\n      }\n\n      const constraintCondition = constraintSql.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n      constraintSql = constraintSql.replace(/\\(.+\\)/, '');\n      const constraint = constraintSql.split(' ');\n\n      if (constraint[1] === 'PRIMARY' || constraint[1] === 'FOREIGN') {\n        constraint[1] += ' KEY';\n      }\n\n      return {\n        constraintName: Utils.removeTicks(constraint[0]),\n        constraintType: constraint[1],\n        updateAction,\n        deleteAction,\n        sql: sql.replace(/\"/g, '`'), //Sqlite returns double quotes for table name\n        constraintCondition,\n        referenceTableName,\n        referenceTableKeys\n      };\n    });\n\n    return constraints;\n  }\n\n  applyParsers(type, value) {\n    if (type.includes('(')) {\n      // Remove the length part\n      type = type.substr(0, type.indexOf('('));\n    }\n    type = type.replace('UNSIGNED', '').replace('ZEROFILL', '');\n    type = type.trim().toUpperCase();\n    const parse = parserStore.get(type);\n\n    if (value !== null && parse) {\n      return parse(value, { timezone: this.sequelize.options.timezone });\n    }\n    return value;\n  }\n\n  formatError(err, errStack) {\n\n    switch (err.code) {\n      case 'SQLITE_CONSTRAINT': {\n        if (err.message.includes('FOREIGN KEY constraint failed')) {\n          return new sequelizeErrors.ForeignKeyConstraintError({\n            parent: err,\n            stack: errStack\n          });\n        }\n\n        let fields = [];\n\n        // Sqlite pre 2.2 behavior - Error: SQLITE_CONSTRAINT: columns x, y are not unique\n        let match = err.message.match(/columns (.*?) are/);\n        if (match !== null && match.length >= 2) {\n          fields = match[1].split(', ');\n        } else {\n\n          // Sqlite post 2.2 behavior - Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: table.x, table.y\n          match = err.message.match(/UNIQUE constraint failed: (.*)/);\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(', ').map(columnWithTable => columnWithTable.split('.')[1]);\n          }\n        }\n\n        const errors = [];\n        let message = 'Validation error';\n\n        for (const field of fields) {\n          errors.push(new sequelizeErrors.ValidationErrorItem(\n            this.getUniqueConstraintErrorMessage(field),\n            'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n            field,\n            this.instance && this.instance[field],\n            this.instance,\n            'not_unique'\n          ));\n        }\n\n        if (this.model) {\n          _.forOwn(this.model.uniqueKeys, constraint => {\n            if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {\n              message = constraint.msg;\n              return false;\n            }\n          });\n        }\n\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n      }\n      case 'SQLITE_BUSY':\n        return new sequelizeErrors.TimeoutError(err, { stack: errStack });\n\n      default:\n        return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n    }\n  }\n\n  async handleShowIndexesQuery(data) {\n    // Sqlite returns indexes so the one that was defined last is returned first. Lets reverse that!\n    return Promise.all(data.reverse().map(async item => {\n      item.fields = [];\n      item.primary = false;\n      item.unique = !!item.unique;\n      item.constraintName = item.name;\n      const columns = await this.run(`PRAGMA INDEX_INFO(\\`${item.name}\\`)`);\n      for (const column of columns) {\n        item.fields[column.seqno] = {\n          attribute: column.name,\n          length: undefined,\n          order: undefined\n        };\n      }\n\n      return item;\n    }));\n  }\n\n  getDatabaseMethod() {\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes('CREATE TEMPORARY TABLE'.toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\n      return 'run';\n    }\n    return 'all';\n  }\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;\n"]},"metadata":{},"sourceType":"script"}