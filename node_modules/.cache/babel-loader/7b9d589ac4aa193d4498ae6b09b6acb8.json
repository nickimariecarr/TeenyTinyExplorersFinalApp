{"ast":null,"code":"\"use strict\";\n\nvar h = Object.defineProperty;\n\nvar a = (d, e) => h(d, \"name\", {\n  value: e,\n  configurable: !0\n});\n\nconst {\n  Pool: l,\n  TimeoutError: w\n} = require(\"sequelize-pool\"),\n      n = require(\"lodash\"),\n      c = require(\"semver\"),\n      m = require(\"../../errors\"),\n      {\n  logger: f\n} = require(\"../../utils/logger\"),\n      q = require(\"../../utils/deprecations\"),\n      r = f.debugContext(\"pool\");\n\nclass s {\n  constructor(e, o) {\n    const i = n.cloneDeep(o.config);\n    if (this.sequelize = o, this.config = i, this.dialect = e, this.versionPromise = null, this.dialectName = this.sequelize.options.dialect, i.pool === !1) throw new Error(\"Support for pool:false was removed in v4.0\");\n    i.pool = n.defaults(i.pool || {}, {\n      max: 5,\n      min: 0,\n      idle: 1e4,\n      acquire: 6e4,\n      evict: 1e3,\n      validate: this._validate.bind(this)\n    }), this.initPools();\n  }\n\n  refreshTypeParser(e) {\n    n.each(e, o => {\n      if (Object.prototype.hasOwnProperty.call(o, \"parse\")) if (o.types[this.dialectName]) this._refreshTypeParser(o);else throw new Error(`Parse function not supported for type ${o.key} in dialect ${this.dialectName}`);\n    });\n  }\n\n  _loadDialectModule(e) {\n    try {\n      return this.sequelize.config.dialectModulePath ? require(this.sequelize.config.dialectModulePath) : this.sequelize.config.dialectModule ? this.sequelize.config.dialectModule : require(e);\n    } catch (o) {\n      throw o.code === \"MODULE_NOT_FOUND\" ? this.sequelize.config.dialectModulePath ? new Error(`Unable to find dialect at ${this.sequelize.config.dialectModulePath}`) : new Error(`Please install ${e} package manually`) : o;\n    }\n  }\n\n  async _onProcessExit() {\n    if (!!this.pool) return await this.pool.drain(), r(\"connection drain due to process exit\"), await this.pool.destroyAllNow();\n  }\n\n  async close() {\n    return this.getConnection = a(async function () {\n      throw new Error(\"ConnectionManager.getConnection was called after the connection manager was closed!\");\n    }, \"getConnection\"), await this._onProcessExit();\n  }\n\n  initPools() {\n    const e = this.config;\n\n    if (!e.replication) {\n      this.pool = new l({\n        name: \"sequelize\",\n        create: () => this._connect(e),\n        destroy: async i => {\n          const t = await this._disconnect(i);\n          return r(\"connection destroy\"), t;\n        },\n        validate: e.pool.validate,\n        max: e.pool.max,\n        min: e.pool.min,\n        acquireTimeoutMillis: e.pool.acquire,\n        idleTimeoutMillis: e.pool.idle,\n        reapIntervalMillis: e.pool.evict,\n        maxUses: e.pool.maxUses\n      }), r(`pool created with max/min: ${e.pool.max}/${e.pool.min}, no replication`);\n      return;\n    }\n\n    Array.isArray(e.replication.read) || (e.replication.read = [e.replication.read]), e.replication.write = n.defaults(e.replication.write, n.omit(e, \"replication\")), e.replication.read = e.replication.read.map(i => n.defaults(i, n.omit(this.config, \"replication\")));\n    let o = 0;\n    this.pool = {\n      release: i => {\n        i.queryType === \"read\" ? this.pool.read.release(i) : this.pool.write.release(i);\n      },\n      acquire: (i, t) => (t = t === void 0 ? !1 : t, i === \"SELECT\" && !t ? this.pool.read.acquire() : this.pool.write.acquire()),\n      destroy: i => {\n        this.pool[i.queryType].destroy(i), r(\"connection destroy\");\n      },\n      destroyAllNow: async () => {\n        await Promise.all([this.pool.read.destroyAllNow(), this.pool.write.destroyAllNow()]), r(\"all connections destroyed\");\n      },\n      drain: async () => Promise.all([this.pool.write.drain(), this.pool.read.drain()]),\n      read: new l({\n        name: \"sequelize:read\",\n        create: async () => {\n          const i = o++ % e.replication.read.length,\n                t = await this._connect(e.replication.read[i]);\n          return t.queryType = \"read\", t;\n        },\n        destroy: i => this._disconnect(i),\n        validate: e.pool.validate,\n        max: e.pool.max,\n        min: e.pool.min,\n        acquireTimeoutMillis: e.pool.acquire,\n        idleTimeoutMillis: e.pool.idle,\n        reapIntervalMillis: e.pool.evict,\n        maxUses: e.pool.maxUses\n      }),\n      write: new l({\n        name: \"sequelize:write\",\n        create: async () => {\n          const i = await this._connect(e.replication.write);\n          return i.queryType = \"write\", i;\n        },\n        destroy: i => this._disconnect(i),\n        validate: e.pool.validate,\n        max: e.pool.max,\n        min: e.pool.min,\n        acquireTimeoutMillis: e.pool.acquire,\n        idleTimeoutMillis: e.pool.idle,\n        reapIntervalMillis: e.pool.evict,\n        maxUses: e.pool.maxUses\n      })\n    }, r(`pool created with max/min: ${e.pool.max}/${e.pool.min}, with replication`);\n  }\n\n  async getConnection(e) {\n    e = e || {}, this.sequelize.options.databaseVersion === 0 && (this.versionPromise || (this.versionPromise = (async () => {\n      try {\n        const i = await this._connect(this.config.replication.write || this.config),\n              t = {};\n\n        if (t.transaction = {\n          connection: i\n        }, t.logging = () => {}, t.logging.__testLoggingFn = !0, this.sequelize.options.databaseVersion === 0) {\n          const u = await this.sequelize.databaseVersion(t),\n                p = n.get(c.coerce(u), \"version\") || u;\n          this.sequelize.options.databaseVersion = c.valid(p) ? p : this.dialect.defaultVersion;\n        }\n\n        return c.lt(this.sequelize.options.databaseVersion, this.dialect.defaultVersion) && (q.unsupportedEngine(), r(`Unsupported database engine version ${this.sequelize.options.databaseVersion}`)), this.versionPromise = null, await this._disconnect(i);\n      } catch (i) {\n        throw this.versionPromise = null, i;\n      }\n    })()), await this.versionPromise);\n    let o;\n\n    try {\n      o = await this.pool.acquire(e.type, e.useMaster);\n    } catch (i) {\n      throw i instanceof w ? new m.ConnectionAcquireTimeoutError(i) : i;\n    }\n\n    return r(\"connection acquired\"), o;\n  }\n\n  async releaseConnection(e) {\n    this.pool.release(e), r(\"connection released\");\n  }\n\n  async _connect(e) {\n    await this.sequelize.runHooks(\"beforeConnect\", e);\n    const o = await this.dialect.connectionManager.connect(e);\n    return await this.sequelize.runHooks(\"afterConnect\", o, e), o;\n  }\n\n  async _disconnect(e) {\n    return await this.sequelize.runHooks(\"beforeDisconnect\", e), await this.dialect.connectionManager.disconnect(e), this.sequelize.runHooks(\"afterDisconnect\", e);\n  }\n\n  _validate(e) {\n    return this.dialect.connectionManager.validate ? this.dialect.connectionManager.validate(e) : !0;\n  }\n\n}\n\na(s, \"ConnectionManager\"), module.exports = s, module.exports.ConnectionManager = s, module.exports.default = s;","map":{"version":3,"sources":["../../../../lib/dialects/abstract/connection-manager.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst { Pool, TimeoutError } = require('sequelize-pool');\nconst _ = require('lodash');\nconst semver = require('semver');\nconst errors = require('../../errors');\nconst { logger } = require('../../utils/logger');\nconst deprecations = require('../../utils/deprecations');\nconst debug = logger.debugContext('pool');\n\n/**\n * Abstract Connection Manager\n *\n * Connection manager which handles pooling & replication.\n * Uses sequelize-pool for pooling\n *\n * @private\n */\nclass ConnectionManager {\n  constructor(dialect, sequelize) {\n    const config = _.cloneDeep(sequelize.config);\n\n    this.sequelize = sequelize;\n    this.config = config;\n    this.dialect = dialect;\n    this.versionPromise = null;\n    this.dialectName = this.sequelize.options.dialect;\n\n    if (config.pool === false) {\n      throw new Error('Support for pool:false was removed in v4.0');\n    }\n\n    config.pool = _.defaults(config.pool || {}, {\n      max: 5,\n      min: 0,\n      idle: 10000,\n      acquire: 60000,\n      evict: 1000,\n      validate: this._validate.bind(this)\n    });\n\n    this.initPools();\n  }\n\n  refreshTypeParser(dataTypes) {\n    _.each(dataTypes, dataType => {\n      if (Object.prototype.hasOwnProperty.call(dataType, 'parse')) {\n        if (dataType.types[this.dialectName]) {\n          this._refreshTypeParser(dataType);\n        } else {\n          throw new Error(`Parse function not supported for type ${dataType.key} in dialect ${this.dialectName}`);\n        }\n      }\n    });\n  }\n\n  /**\n   * Try to load dialect module from various configured options.\n   * Priority goes like dialectModulePath > dialectModule > require(default)\n   *\n   * @param {string} moduleName Name of dialect module to lookup\n   *\n   * @private\n   * @returns {object}\n   */\n  _loadDialectModule(moduleName) {\n    try {\n      if (this.sequelize.config.dialectModulePath) {\n        return require(this.sequelize.config.dialectModulePath);\n      }\n      if (this.sequelize.config.dialectModule) {\n        return this.sequelize.config.dialectModule;\n      }\n      return require(moduleName);\n\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') {\n        if (this.sequelize.config.dialectModulePath) {\n          throw new Error(`Unable to find dialect at ${this.sequelize.config.dialectModulePath}`);\n        }\n        throw new Error(`Please install ${moduleName} package manually`);\n      }\n\n      throw err;\n    }\n  }\n\n  /**\n   * Handler which executes on process exit or connection manager shutdown\n   *\n   * @private\n   * @returns {Promise}\n   */\n  async _onProcessExit() {\n    if (!this.pool) {\n      return;\n    }\n\n    await this.pool.drain();\n    debug('connection drain due to process exit');\n\n    return await this.pool.destroyAllNow();\n  }\n\n  /**\n   * Drain the pool and close it permanently\n   *\n   * @returns {Promise}\n   */\n  async close() {\n    // Mark close of pool\n    this.getConnection = async function getConnection() {\n      throw new Error('ConnectionManager.getConnection was called after the connection manager was closed!');\n    };\n\n    return await this._onProcessExit();\n  }\n\n  /**\n   * Initialize connection pool. By default pool autostart is set to false, so no connection will be\n   * be created unless `pool.acquire` is called.\n   */\n  initPools() {\n    const config = this.config;\n\n    if (!config.replication) {\n      this.pool = new Pool({\n        name: 'sequelize',\n        create: () => this._connect(config),\n        destroy: async connection => {\n          const result = await this._disconnect(connection);\n          debug('connection destroy');\n          return result;\n        },\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      });\n\n      debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, no replication`);\n\n      return;\n    }\n\n    if (!Array.isArray(config.replication.read)) {\n      config.replication.read = [config.replication.read];\n    }\n\n    // Map main connection config\n    config.replication.write = _.defaults(config.replication.write, _.omit(config, 'replication'));\n\n    // Apply defaults to each read config\n    config.replication.read = config.replication.read.map(readConfig =>\n      _.defaults(readConfig, _.omit(this.config, 'replication'))\n    );\n\n    // custom pooling for replication (original author @janmeier)\n    let reads = 0;\n    this.pool = {\n      release: client => {\n        if (client.queryType === 'read') {\n          this.pool.read.release(client);\n        } else {\n          this.pool.write.release(client);\n        }\n      },\n      acquire: (queryType, useMaster) => {\n        useMaster = useMaster === undefined ? false : useMaster;\n        if (queryType === 'SELECT' && !useMaster) {\n          return this.pool.read.acquire();\n        }\n        return this.pool.write.acquire();\n      },\n      destroy: connection => {\n        this.pool[connection.queryType].destroy(connection);\n        debug('connection destroy');\n      },\n      destroyAllNow: async () => {\n        await Promise.all([\n          this.pool.read.destroyAllNow(),\n          this.pool.write.destroyAllNow()\n        ]);\n\n        debug('all connections destroyed');\n      },\n      drain: async () => Promise.all([\n        this.pool.write.drain(),\n        this.pool.read.drain()\n      ]),\n      read: new Pool({\n        name: 'sequelize:read',\n        create: async () => {\n          // round robin config\n          const nextRead = reads++ % config.replication.read.length;\n          const connection = await this._connect(config.replication.read[nextRead]);\n          connection.queryType = 'read';\n          return connection;\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      }),\n      write: new Pool({\n        name: 'sequelize:write',\n        create: async () => {\n          const connection = await this._connect(config.replication.write);\n          connection.queryType = 'write';\n          return connection;\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      })\n    };\n\n    debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, with replication`);\n  }\n\n  /**\n   * Get connection from pool. It sets database version if it's not already set.\n   * Call pool.acquire to get a connection\n   *\n   * @param {object}   [options]                 Pool options\n   * @param {string}   [options.type]            Set which replica to use. Available options are `read` and `write`\n   * @param {boolean}  [options.useMaster=false] Force master or write replica to get connection from\n   *\n   * @returns {Promise<Connection>}\n   */\n  async getConnection(options) {\n    options = options || {};\n\n    if (this.sequelize.options.databaseVersion === 0) {\n      if (!this.versionPromise) {\n        this.versionPromise = (async () => {\n          try {\n            const connection = await this._connect(this.config.replication.write || this.config);\n            const _options = {};\n\n            _options.transaction = { connection }; // Cheat .query to use our private connection\n            _options.logging = () => {};\n            _options.logging.__testLoggingFn = true;\n\n            //connection might have set databaseVersion value at initialization,\n            //avoiding a useless round trip\n            if (this.sequelize.options.databaseVersion === 0) {\n              const version = await this.sequelize.databaseVersion(_options);\n              const parsedVersion = _.get(semver.coerce(version), 'version') || version;\n              this.sequelize.options.databaseVersion = semver.valid(parsedVersion)\n                ? parsedVersion\n                : this.dialect.defaultVersion;\n            }\n\n            if (semver.lt(this.sequelize.options.databaseVersion, this.dialect.defaultVersion)) {\n              deprecations.unsupportedEngine();\n              debug(`Unsupported database engine version ${this.sequelize.options.databaseVersion}`);\n            }\n\n            this.versionPromise = null;\n            return await this._disconnect(connection);\n          } catch (err) {\n            this.versionPromise = null;\n            throw err;\n          }\n        })();\n      }\n      await this.versionPromise;\n    }\n\n    let result;\n\n    try {\n      result = await this.pool.acquire(options.type, options.useMaster);\n    } catch (error) {\n      if (error instanceof TimeoutError) throw new errors.ConnectionAcquireTimeoutError(error);\n      throw error;\n    }\n\n    debug('connection acquired');\n\n    return result;\n  }\n\n  /**\n   * Release a pooled connection so it can be utilized by other connection requests\n   *\n   * @param {Connection} connection\n   *\n   * @returns {Promise}\n   */\n  async releaseConnection(connection) {\n    this.pool.release(connection);\n    debug('connection released');\n  }\n\n  /**\n   * Call dialect library to get connection\n   *\n   * @param {*} config Connection config\n   * @private\n   * @returns {Promise<Connection>}\n   */\n  async _connect(config) {\n    await this.sequelize.runHooks('beforeConnect', config);\n    const connection = await this.dialect.connectionManager.connect(config);\n    await this.sequelize.runHooks('afterConnect', connection, config);\n    return connection;\n  }\n\n  /**\n   * Call dialect library to disconnect a connection\n   *\n   * @param {Connection} connection\n   * @private\n   * @returns {Promise}\n   */\n  async _disconnect(connection) {\n    await this.sequelize.runHooks('beforeDisconnect', connection);\n    await this.dialect.connectionManager.disconnect(connection);\n    return this.sequelize.runHooks('afterDisconnect', connection);\n  }\n\n  /**\n   * Determine if a connection is still valid or not\n   *\n   * @param {Connection} connection\n   *\n   * @returns {boolean}\n   */\n  _validate(connection) {\n    if (!this.dialect.connectionManager.validate) {\n      return true;\n    }\n\n    return this.dialect.connectionManager.validate(connection);\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}