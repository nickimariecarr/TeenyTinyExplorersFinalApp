{"ast":null,"code":"\"use strict\";\n\nvar i = Object.defineProperty;\n\nvar o = (s, e) => i(s, \"name\", {\n  value: e,\n  configurable: !0\n});\n\nconst h = require(\"../../errors/base-error\"),\n      n = require(\"../../errors/connection-error\");\n\nclass r extends h {\n  constructor(e) {\n    super(e);\n    this.name = \"SequelizeAsyncQueueError\";\n  }\n\n}\n\no(r, \"AsyncQueueError\"), exports.AsyncQueueError = r;\n\nclass u {\n  constructor() {\n    this.previous = Promise.resolve(), this.closed = !1, this.rejectCurrent = () => {};\n  }\n\n  close() {\n    this.closed = !0, this.rejectCurrent(new n(new r(\"the connection was closed before this query could finish executing\")));\n  }\n\n  enqueue(e) {\n    return new Promise((c, t) => {\n      this.previous = this.previous.then(() => (this.rejectCurrent = t, this.closed ? t(new n(new r(\"the connection was closed before this query could be executed\"))) : e().then(c, t)));\n    });\n  }\n\n}\n\no(u, \"AsyncQueue\"), exports.default = u;","map":{"version":3,"sources":["../../../../lib/dialects/mssql/async-queue.js"],"names":[],"mappings":";;;;;;;;;AAEA,MAAM,CAAA,GAAY,OAAA,CAAQ,yBAAR,CAAlB;AAAA,MACM,CAAA,GAAkB,OAAA,CAAQ,+BAAR,CADxB;;AAMA,MAAA,CAAA,SAA8B,CAA9B,CAAwC;AACtC,EAAA,WAAA,CAAY,CAAZ,EAAqB;AACnB,UAAM,CAAN;AACA,SAAK,IAAL,GAAY,0BAAZ;AAAY;;AAHwB;;AAAxC,CAAA,CAAA,CAAA,EAAA,iBAAA,CAAA,EAOA,OAAA,CAAQ,eAAR,GAA0B,CAP1B;;AASA,MAAA,CAAA,CAAiB;AACf,EAAA,WAAA,GAAc;AACZ,SAAK,QAAL,GAAgB,OAAA,CAAQ,OAAR,EAAhB,EACA,KAAK,MAAL,GAAc,CAAA,CADd,EAEA,KAAK,aAAL,GAAqB,MAAM,CAAA,CAF3B;AAIF;;AAAA,EAAA,KAAA,GAAQ;AACN,SAAK,MAAL,GAAc,CAAA,CAAd,EACA,KAAK,aAAL,CAAmB,IAAI,CAAJ,CAAoB,IAAI,CAAJ,CAAoB,oEAApB,CAApB,CAAnB,CADA;AAGF;;AAAA,EAAA,OAAA,CAAQ,CAAR,EAAuB;AAIrB,WAAO,IAAI,OAAJ,CAAY,CAAC,CAAD,EAAU,CAAV,KAAqB;AACtC,WAAK,QAAL,GAAgB,KAAK,QAAL,CAAc,IAAd,CACd,OACE,KAAK,aAAL,GAAqB,CAArB,EACI,KAAK,MAAL,GACK,CAAA,CAAO,IAAI,CAAJ,CAAoB,IAAI,CAAJ,CAAoB,+DAApB,CAApB,CAAP,CADL,GAGG,CAAA,GAAgB,IAAhB,CAAqB,CAArB,EAA8B,CAA9B,CALT,CADc,CAAhB;AAMyC,KAPpC,CAAP;AAO2C;;AArB9B;;AAAjB,CAAA,CAAA,CAAA,EAAA,YAAA,CAAA,EA4BA,OAAA,CAAQ,OAAR,GAAkB,CA5BlB","sourcesContent":["'use strict';\n\nconst BaseError = require('../../errors/base-error');\nconst ConnectionError = require('../../errors/connection-error');\n\n/**\n * Thrown when a connection to a database is closed while an operation is in progress\n */\nclass AsyncQueueError extends BaseError {\n  constructor(message) {\n    super(message);\n    this.name = 'SequelizeAsyncQueueError';\n  }\n}\n\nexports.AsyncQueueError = AsyncQueueError;\n\nclass AsyncQueue {\n  constructor() {\n    this.previous = Promise.resolve();\n    this.closed = false;\n    this.rejectCurrent = () => {};\n  }\n  close() {\n    this.closed = true;\n    this.rejectCurrent(new ConnectionError(new AsyncQueueError('the connection was closed before this query could finish executing')));\n  }\n  enqueue(asyncFunction) {\n    // This outer promise might seems superflous since down below we return asyncFunction().then(resolve, reject).\n    // However, this ensures that this.previous will never be a rejected promise so the queue will\n    // always keep going, while still communicating rejection from asyncFunction to the user.\n    return new Promise((resolve, reject) => {\n      this.previous = this.previous.then(\n        () => {\n          this.rejectCurrent = reject;\n          if (this.closed) {\n            return reject(new ConnectionError(new AsyncQueueError('the connection was closed before this query could be executed')));\n          }\n          return asyncFunction().then(resolve, reject);\n        }\n      );\n    });\n  }\n}\n\nexports.default = AsyncQueue;\n"]},"metadata":{},"sourceType":"script"}