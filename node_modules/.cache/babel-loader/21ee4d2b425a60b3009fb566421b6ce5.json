{"ast":null,"code":"\"use strict\";\n\nvar s = Object.defineProperty;\n\nvar i = (e, r) => s(e, \"name\", {\n  value: r,\n  configurable: !0\n});\n\nfunction d(e) {\n  if (Object.prototype.hasOwnProperty.call(e.source.rawAttributes, e.as)) throw new Error(`Naming collision between attribute '${e.as}' and association '${e.as}' on model ${e.source.name}. To remedy this, change either foreignKey or as in your association definition`);\n}\n\ni(d, \"checkNamingCollision\"), exports.checkNamingCollision = d;\n\nfunction l(e, r, a, n, t) {\n  if (n.foreignKeyConstraint || n.onDelete || n.onUpdate) {\n    const o = Object.keys(r.primaryKeys).map(c => r.rawAttributes[c].field || c);\n    (o.length === 1 || !o.includes(t)) && (e.references = {\n      model: r.getTableName(),\n      key: t || o[0]\n    }, e.onDelete = n.onDelete, e.onUpdate = n.onUpdate);\n  }\n}\n\ni(l, \"addForeignKeyConstraints\"), exports.addForeignKeyConstraints = l;\n\nfunction f(e, r, a, n) {\n  n = n || {};\n\n  for (const t of a) if (!Object.prototype.hasOwnProperty.call(r, e.accessors[t])) {\n    const o = n[t] || t;\n\n    r[e.accessors[t]] = function () {\n      return e[o](this, ...Array.from(arguments));\n    };\n  }\n}\n\ni(f, \"mixinMethods\"), exports.mixinMethods = f;","map":{"version":3,"sources":["../../../lib/associations/helpers.js"],"names":[],"mappings":";;;;;;;;;AAEA,SAAA,CAAA,CAA8B,CAA9B,EAA2C;AACzC,MAAI,MAAA,CAAO,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,CAAA,CAAY,MAAZ,CAAmB,aAAxD,EAAuE,CAAA,CAAY,EAAnF,CAAJ,EACE,MAAM,IAAI,KAAJ,CACJ,uCAAuC,CAAA,CAAY,EAAA,sBAC9B,CAAA,CAAY,EAAA,cAAgB,CAAA,CAAY,MAAZ,CAAmB,IAAA,iFAFhE,CAAN;AAFK;;AAAA,CAAA,CAAA,CAAA,EAAA,sBAAA,CAAA,EAST,OAAA,CAAQ,oBAAR,GAA+B,CATtB;;AAWT,SAAA,CAAA,CAAkC,CAAlC,EAAgD,CAAhD,EAAwD,CAAxD,EAAgE,CAAhE,EAAyE,CAAzE,EAA8E;AAI5E,MAAI,CAAA,CAAQ,oBAAR,IAAgC,CAAA,CAAQ,QAAxC,IAAoD,CAAA,CAAQ,QAAhE,EAA0E;AAExE,UAAM,CAAA,GAAc,MAAA,CAAO,IAAP,CAAY,CAAA,CAAO,WAAnB,EACjB,GADiB,CACb,CAAA,IAAuB,CAAA,CAAO,aAAP,CAAqB,CAArB,EAA0C,KAA1C,IAAmD,CAD7D,CAApB;AAGI,KAAA,CAAA,CAAY,MAAZ,KAAuB,CAAvB,IAA4B,CAAC,CAAA,CAAY,QAAZ,CAAqB,CAArB,CAA7B,MACF,CAAA,CAAa,UAAb,GAA0B;AACxB,MAAA,KAAA,EAAO,CAAA,CAAO,YAAP,EADiB;AAExB,MAAA,GAAA,EAAK,CAAA,IAAO,CAAA,CAAY,CAAZ;AAFY,KAA1B,EAKA,CAAA,CAAa,QAAb,GAAwB,CAAA,CAAQ,QALhC,EAMA,CAAA,CAAa,QAAb,GAAwB,CAAA,CAAQ,QAP9B;AAO8B;AAhB7B;;AAAA,CAAA,CAAA,CAAA,EAAA,0BAAA,CAAA,EAoBT,OAAA,CAAQ,wBAAR,GAAmC,CApB1B;;AAiCT,SAAA,CAAA,CAAsB,CAAtB,EAAmC,CAAnC,EAAwC,CAAxC,EAAiD,CAAjD,EAA0D;AACxD,EAAA,CAAA,GAAU,CAAA,IAAW,EAArB;;AAEA,OAAA,MAAW,CAAX,IAAqB,CAArB,EAEE,IAAI,CAAC,MAAA,CAAO,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,CAArC,EAA0C,CAAA,CAAY,SAAZ,CAAsB,CAAtB,CAA1C,CAAL,EAA+E;AAC7E,UAAM,CAAA,GAAa,CAAA,CAAQ,CAAR,CAAA,IAAmB,CAAtC;;AAEA,IAAA,CAAA,CAAI,CAAA,CAAY,SAAZ,CAAsB,CAAtB,CAAJ,CAAA,GAAqC,YAAW;AAC9C,aAAO,CAAA,CAAY,CAAZ,CAAA,CAAwB,IAAxB,EAA8B,GAAG,KAAA,CAAM,IAAN,CAAW,SAAX,CAAjC,CAAP;AAAmD,KADrD;AACqD;AATlD;;AAAA,CAAA,CAAA,CAAA,EAAA,cAAA,CAAA,EAcT,OAAA,CAAQ,YAAR,GAAuB,CAdd","sourcesContent":["'use strict';\n\nfunction checkNamingCollision(association) {\n  if (Object.prototype.hasOwnProperty.call(association.source.rawAttributes, association.as)) {\n    throw new Error(\n      `Naming collision between attribute '${association.as}'` +\n      ` and association '${association.as}' on model ${association.source.name}` +\n      '. To remedy this, change either foreignKey or as in your association definition'\n    );\n  }\n}\nexports.checkNamingCollision = checkNamingCollision;\n\nfunction addForeignKeyConstraints(newAttribute, source, target, options, key) {\n  // FK constraints are opt-in: users must either set `foreignKeyConstraints`\n  // on the association, or request an `onDelete` or `onUpdate` behavior\n\n  if (options.foreignKeyConstraint || options.onDelete || options.onUpdate) {\n    // Find primary keys: composite keys not supported with this approach\n    const primaryKeys = Object.keys(source.primaryKeys)\n      .map(primaryKeyAttribute => source.rawAttributes[primaryKeyAttribute].field || primaryKeyAttribute);\n\n    if (primaryKeys.length === 1 || !primaryKeys.includes(key)) {\n      newAttribute.references = {\n        model: source.getTableName(),\n        key: key || primaryKeys[0]\n      };\n\n      newAttribute.onDelete = options.onDelete;\n      newAttribute.onUpdate = options.onUpdate;\n    }\n  }\n}\nexports.addForeignKeyConstraints = addForeignKeyConstraints;\n\n/**\n * Mixin (inject) association methods to model prototype\n *\n * @private\n *\n * @param {object} association instance\n * @param {object} obj Model prototype\n * @param {Array} methods Method names to inject\n * @param {object} aliases Mapping between model and association method names\n *\n */\nfunction mixinMethods(association, obj, methods, aliases) {\n  aliases = aliases || {};\n\n  for (const method of methods) {\n    // don't override custom methods\n    if (!Object.prototype.hasOwnProperty.call(obj, association.accessors[method])) {\n      const realMethod = aliases[method] || method;\n\n      obj[association.accessors[method]] = function() {\n        return association[realMethod](this, ...Array.from(arguments));\n      };\n    }\n  }\n}\nexports.mixinMethods = mixinMethods;\n"]},"metadata":{},"sourceType":"script"}