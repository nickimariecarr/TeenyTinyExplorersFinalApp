{"ast":null,"code":"\"use strict\";\n\nvar a = Object.defineProperty;\nvar r = Object.getOwnPropertySymbols;\nvar E = Object.prototype.hasOwnProperty,\n    p = Object.prototype.propertyIsEnumerable;\n\nvar c = (e, t, i) => t in e ? a(e, t, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: i\n}) : e[t] = i,\n    h = (e, t) => {\n  for (var i in t || (t = {})) E.call(t, i) && c(e, i, t[i]);\n\n  if (r) for (var i of r(t)) p.call(t, i) && c(e, i, t[i]);\n  return e;\n};\n\nvar l = (e, t) => a(e, \"name\", {\n  value: t,\n  configurable: !0\n});\n\nclass s {\n  constructor(t, i) {\n    this.sequelize = t, this.savepoints = [], this._afterCommitHooks = [];\n    const n = this.sequelize.dialect.queryGenerator.generateTransactionId;\n    this.options = h({\n      type: t.options.transactionType,\n      isolationLevel: t.options.isolationLevel,\n      readOnly: !1\n    }, i), this.parent = this.options.transaction, this.parent ? (this.id = this.parent.id, this.parent.savepoints.push(this), this.name = `${this.id}-sp-${this.parent.savepoints.length}`) : this.id = this.name = n(), delete this.options.transaction;\n  }\n\n  async commit() {\n    if (this.finished) throw new Error(`Transaction cannot be committed because it has been finished with state: ${this.finished}`);\n\n    try {\n      return await this.sequelize.getQueryInterface().commitTransaction(this, this.options);\n    } finally {\n      this.finished = \"commit\", this.cleanup();\n\n      for (const t of this._afterCommitHooks) await t.apply(this, [this]);\n    }\n  }\n\n  async rollback() {\n    if (this.finished) throw new Error(`Transaction cannot be rolled back because it has been finished with state: ${this.finished}`);\n    if (!this.connection) throw new Error(\"Transaction cannot be rolled back because it never started\");\n\n    try {\n      return await this.sequelize.getQueryInterface().rollbackTransaction(this, this.options);\n    } finally {\n      this.cleanup();\n    }\n  }\n\n  async prepareEnvironment(t) {\n    let i;\n    if (t === void 0 && (t = !0), this.parent) i = Promise.resolve(this.parent.connection);else {\n      const o = {\n        uuid: this.id\n      };\n      this.options.readOnly && (o.type = \"SELECT\"), i = this.sequelize.connectionManager.getConnection(o);\n    }\n    let n;\n    const u = await i;\n    this.connection = u, this.connection.uuid = this.id;\n\n    try {\n      await this.begin(), n = await this.setDeferrable();\n    } catch (o) {\n      try {\n        n = await this.rollback();\n      } finally {\n        throw o;\n      }\n    }\n\n    return t && this.sequelize.constructor._cls && this.sequelize.constructor._cls.set(\"transaction\", this), n;\n  }\n\n  async setDeferrable() {\n    if (this.options.deferrable) return await this.sequelize.getQueryInterface().deferConstraints(this, this.options);\n  }\n\n  async begin() {\n    const t = this.sequelize.getQueryInterface();\n    return this.sequelize.dialect.supports.settingIsolationLevelDuringTransaction ? (await t.startTransaction(this, this.options), t.setIsolationLevel(this, this.options.isolationLevel, this.options)) : (await t.setIsolationLevel(this, this.options.isolationLevel, this.options), t.startTransaction(this, this.options));\n  }\n\n  cleanup() {\n    if (this.parent || this.connection.uuid === void 0) return;\n\n    this._clearCls();\n\n    const t = this.sequelize.connectionManager.releaseConnection(this.connection);\n    return this.connection.uuid = void 0, t;\n  }\n\n  _clearCls() {\n    const t = this.sequelize.constructor._cls;\n    t && t.get(\"transaction\") === this && t.set(\"transaction\", null);\n  }\n\n  afterCommit(t) {\n    if (!t || typeof t != \"function\") throw new Error('\"fn\" must be a function');\n\n    this._afterCommitHooks.push(t);\n  }\n\n  static get TYPES() {\n    return {\n      DEFERRED: \"DEFERRED\",\n      IMMEDIATE: \"IMMEDIATE\",\n      EXCLUSIVE: \"EXCLUSIVE\"\n    };\n  }\n\n  static get ISOLATION_LEVELS() {\n    return {\n      READ_UNCOMMITTED: \"READ UNCOMMITTED\",\n      READ_COMMITTED: \"READ COMMITTED\",\n      REPEATABLE_READ: \"REPEATABLE READ\",\n      SERIALIZABLE: \"SERIALIZABLE\"\n    };\n  }\n\n  static get LOCK() {\n    return {\n      UPDATE: \"UPDATE\",\n      SHARE: \"SHARE\",\n      KEY_SHARE: \"KEY SHARE\",\n      NO_KEY_UPDATE: \"NO KEY UPDATE\"\n    };\n  }\n\n  get LOCK() {\n    return s.LOCK;\n  }\n\n}\n\nl(s, \"Transaction\"), module.exports = s, module.exports.Transaction = s, module.exports.default = s;","map":{"version":3,"sources":["../../lib/transaction.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * The transaction object is used to identify a running transaction.\n * It is created by calling `Sequelize.transaction()`.\n * To run a query under a transaction, you should pass the transaction in the options object.\n *\n * @class Transaction\n * @see {@link Sequelize.transaction}\n */\nclass Transaction {\n  /**\n   * Creates a new transaction instance\n   *\n   * @param {Sequelize} sequelize A configured sequelize Instance\n   * @param {object} options An object with options\n   * @param {string} [options.type] Sets the type of the transaction. Sqlite only\n   * @param {string} [options.isolationLevel] Sets the isolation level of the transaction.\n   * @param {string} [options.deferrable] Sets the constraints to be deferred or immediately checked. PostgreSQL only\n   */\n  constructor(sequelize, options) {\n    this.sequelize = sequelize;\n    this.savepoints = [];\n    this._afterCommitHooks = [];\n\n    // get dialect specific transaction options\n    const generateTransactionId = this.sequelize.dialect.queryGenerator.generateTransactionId;\n\n    this.options = {\n      type: sequelize.options.transactionType,\n      isolationLevel: sequelize.options.isolationLevel,\n      readOnly: false,\n      ...options\n    };\n\n    this.parent = this.options.transaction;\n\n    if (this.parent) {\n      this.id = this.parent.id;\n      this.parent.savepoints.push(this);\n      this.name = `${this.id}-sp-${this.parent.savepoints.length}`;\n    } else {\n      this.id = this.name = generateTransactionId();\n    }\n\n    delete this.options.transaction;\n  }\n\n  /**\n   * Commit the transaction\n   *\n   * @returns {Promise}\n   */\n  async commit() {\n    if (this.finished) {\n      throw new Error(`Transaction cannot be committed because it has been finished with state: ${this.finished}`);\n    }\n\n    try {\n      return await this.sequelize.getQueryInterface().commitTransaction(this, this.options);\n    } finally {\n      this.finished = 'commit';\n      this.cleanup();\n      for (const hook of this._afterCommitHooks) {\n        await hook.apply(this, [this]);\n      }\n    }\n  }\n\n  /**\n   * Rollback (abort) the transaction\n   *\n   * @returns {Promise}\n   */\n  async rollback() {\n    if (this.finished) {\n      throw new Error(`Transaction cannot be rolled back because it has been finished with state: ${this.finished}`);\n    }\n\n    if (!this.connection) {\n      throw new Error('Transaction cannot be rolled back because it never started');\n    }\n\n    try {\n      return await this\n        .sequelize\n        .getQueryInterface()\n        .rollbackTransaction(this, this.options);\n    } finally {\n      this.cleanup();\n    }\n  }\n\n  /**\n   * Called to acquire a connection to use and set the correct options on the connection.\n   * We should ensure all of the environment that's set up is cleaned up in `cleanup()` below.\n   *\n   * @param {boolean} useCLS Defaults to true: Use CLS (Continuation Local Storage) with Sequelize. With CLS, all queries within the transaction callback will automatically receive the transaction object.\n   * @returns {Promise}\n   */\n  async prepareEnvironment(useCLS) {\n    let connectionPromise;\n\n    if (useCLS === undefined) {\n      useCLS = true;\n    }\n\n    if (this.parent) {\n      connectionPromise = Promise.resolve(this.parent.connection);\n    } else {\n      const acquireOptions = { uuid: this.id };\n      if (this.options.readOnly) {\n        acquireOptions.type = 'SELECT';\n      }\n      connectionPromise = this.sequelize.connectionManager.getConnection(acquireOptions);\n    }\n\n    let result;\n    const connection = await connectionPromise;\n    this.connection = connection;\n    this.connection.uuid = this.id;\n\n    try {\n      await this.begin();\n      result = await this.setDeferrable();\n    } catch (setupErr) {\n      try {\n        result = await this.rollback();\n      } finally {\n        throw setupErr; // eslint-disable-line no-unsafe-finally\n      }\n    }\n\n    if (useCLS && this.sequelize.constructor._cls) {\n      this.sequelize.constructor._cls.set('transaction', this);\n    }\n\n    return result;\n  }\n\n  async setDeferrable() {\n    if (this.options.deferrable) {\n      return await this\n        .sequelize\n        .getQueryInterface()\n        .deferConstraints(this, this.options);\n    }\n  }\n\n  async begin() {\n    const queryInterface = this.sequelize.getQueryInterface();\n\n    if ( this.sequelize.dialect.supports.settingIsolationLevelDuringTransaction ) {\n      await queryInterface.startTransaction(this, this.options);\n      return queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\n    }\n\n    await queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\n\n    return queryInterface.startTransaction(this, this.options);\n  }\n\n  cleanup() {\n    // Don't release the connection if there's a parent transaction or\n    // if we've already cleaned up\n    if (this.parent || this.connection.uuid === undefined) return;\n\n    this._clearCls();\n    const res = this.sequelize.connectionManager.releaseConnection(this.connection);\n    this.connection.uuid = undefined;\n    return res;\n  }\n\n  _clearCls() {\n    const cls = this.sequelize.constructor._cls;\n\n    if (cls) {\n      if (cls.get('transaction') === this) {\n        cls.set('transaction', null);\n      }\n    }\n  }\n\n  /**\n   * A hook that is run after a transaction is committed\n   *\n   * @param {Function} fn   A callback function that is called with the committed transaction\n   * @name afterCommit\n   * @memberof Sequelize.Transaction\n   */\n  afterCommit(fn) {\n    if (!fn || typeof fn !== 'function') {\n      throw new Error('\"fn\" must be a function');\n    }\n    this._afterCommitHooks.push(fn);\n  }\n\n  /**\n   * Types can be set per-transaction by passing `options.type` to `sequelize.transaction`.\n   * Default to `DEFERRED` but you can override the default type by passing `options.transactionType` in `new Sequelize`.\n   * Sqlite only.\n   *\n   * Pass in the desired level as the first argument:\n   *\n   * @example\n   * try {\n   *   await sequelize.transaction({ type: Sequelize.Transaction.TYPES.EXCLUSIVE }, transaction => {\n   *      // your transactions\n   *   });\n   *   // transaction has been committed. Do something after the commit if required.\n   * } catch(err) {\n   *   // do something with the err.\n   * }\n   *\n   * @property DEFERRED\n   * @property IMMEDIATE\n   * @property EXCLUSIVE\n   */\n  static get TYPES() {\n    return {\n      DEFERRED: 'DEFERRED',\n      IMMEDIATE: 'IMMEDIATE',\n      EXCLUSIVE: 'EXCLUSIVE'\n    };\n  }\n\n  /**\n   * Isolation levels can be set per-transaction by passing `options.isolationLevel` to `sequelize.transaction`.\n   * Sequelize uses the default isolation level of the database, you can override this by passing `options.isolationLevel` in Sequelize constructor options.\n   *\n   * Pass in the desired level as the first argument:\n   *\n   * @example\n   * try {\n   *   const result = await sequelize.transaction({isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE}, transaction => {\n   *     // your transactions\n   *   });\n   *   // transaction has been committed. Do something after the commit if required.\n   * } catch(err) {\n   *   // do something with the err.\n   * }\n   *\n   * @property READ_UNCOMMITTED\n   * @property READ_COMMITTED\n   * @property REPEATABLE_READ\n   * @property SERIALIZABLE\n   */\n  static get ISOLATION_LEVELS() {\n    return {\n      READ_UNCOMMITTED: 'READ UNCOMMITTED',\n      READ_COMMITTED: 'READ COMMITTED',\n      REPEATABLE_READ: 'REPEATABLE READ',\n      SERIALIZABLE: 'SERIALIZABLE'\n    };\n  }\n\n\n  /**\n   * Possible options for row locking. Used in conjunction with `find` calls:\n   *\n   * @example\n   * // t1 is a transaction\n   * Model.findAll({\n   *   where: ...,\n   *   transaction: t1,\n   *   lock: t1.LOCK...\n   * });\n   *\n   * @example <caption>Postgres also supports specific locks while eager loading by using OF:</caption>\n   * UserModel.findAll({\n   *   where: ...,\n   *   include: [TaskModel, ...],\n   *   transaction: t1,\n   *   lock: {\n   *     level: t1.LOCK...,\n   *     of: UserModel\n   *   }\n   * });\n   *\n   * # UserModel will be locked but TaskModel won't!\n   *\n   * @example <caption>You can also skip locked rows:</caption>\n   * // t1 is a transaction\n   * Model.findAll({\n   *   where: ...,\n   *   transaction: t1,\n   *   lock: true,\n   *   skipLocked: true\n   * });\n   * # The query will now return any rows that aren't locked by another transaction\n   *\n   * @returns {object}\n   * @property UPDATE\n   * @property SHARE\n   * @property KEY_SHARE Postgres 9.3+ only\n   * @property NO_KEY_UPDATE Postgres 9.3+ only\n   */\n  static get LOCK() {\n    return {\n      UPDATE: 'UPDATE',\n      SHARE: 'SHARE',\n      KEY_SHARE: 'KEY SHARE',\n      NO_KEY_UPDATE: 'NO KEY UPDATE'\n    };\n  }\n\n  /**\n   * Please see {@link Transaction.LOCK}\n   */\n  get LOCK() {\n    return Transaction.LOCK;\n  }\n}\n\nmodule.exports = Transaction;\nmodule.exports.Transaction = Transaction;\nmodule.exports.default = Transaction;\n"]},"metadata":{},"sourceType":"script"}