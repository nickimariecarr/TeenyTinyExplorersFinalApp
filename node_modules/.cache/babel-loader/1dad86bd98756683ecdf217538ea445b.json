{"ast":null,"code":"\"use strict\";\n\nvar S = Object.defineProperty,\n    z = Object.defineProperties;\nvar E = Object.getOwnPropertyDescriptors;\nvar _ = Object.getOwnPropertySymbols;\nvar x = Object.prototype.hasOwnProperty,\n    P = Object.prototype.propertyIsEnumerable;\n\nvar k = (y, r, e) => r in y ? S(y, r, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: e\n}) : y[r] = e,\n    o = (y, r) => {\n  for (var e in r || (r = {})) x.call(r, e) && k(y, e, r[e]);\n\n  if (_) for (var e of _(r)) P.call(r, e) && k(y, e, r[e]);\n  return y;\n},\n    A = (y, r) => z(y, E(r));\n\nvar D = (y, r) => S(y, \"name\", {\n  value: r,\n  configurable: !0\n});\n\nconst w = require(\"./../utils\"),\n      C = require(\"./helpers\"),\n      f = require(\"lodash\"),\n      I = require(\"./base\"),\n      T = require(\"./belongs-to\"),\n      U = require(\"./has-many\"),\n      M = require(\"./has-one\"),\n      $ = require(\"../errors\").AssociationError,\n      v = require(\"../errors\").EmptyResultError,\n      j = require(\"../operators\");\n\nclass O extends I {\n  constructor(r, e, t) {\n    super(r, e, t);\n    if (this.options.through === void 0 || this.options.through === !0 || this.options.through === null) throw new $(`${r.name}.belongsToMany(${e.name}) requires through option, pass either a string or a model`);\n    if (this.options.through.model || (this.options.through = {\n      model: t.through\n    }), this.associationType = \"BelongsToMany\", this.targetAssociation = null, this.sequelize = r.sequelize, this.through = o({}, this.options.through), this.isMultiAssociation = !0, this.doubleLinked = !1, !this.as && this.isSelfAssociation) throw new $(\"'as' must be defined for many-to-many self-associations\");\n\n    if (this.as ? (this.isAliased = !0, f.isPlainObject(this.as) ? (this.options.name = this.as, this.as = this.as.plural) : this.options.name = {\n      plural: this.as,\n      singular: w.singularize(this.as)\n    }) : (this.as = this.target.options.name.plural, this.options.name = this.target.options.name), this.combinedTableName = w.combineTableNames(this.source.tableName, this.isSelfAssociation ? this.as || this.target.tableName : this.target.tableName), this.isSelfAssociation && (this.targetAssociation = this), f.each(this.target.associations, s => {\n      s.associationType === \"BelongsToMany\" && s.target === this.source && this.options.through.model === s.options.through.model && (this.paired = s, s.paired = this);\n    }), this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute, this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey, this.options.targetKey ? (this.targetKey = this.options.targetKey, this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey) : (this.targetKeyDefault = !0, this.targetKey = this.target.primaryKeyAttribute, this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey), this._createForeignAndOtherKeys(), typeof this.through.model == \"string\" && (this.sequelize.isDefined(this.through.model) ? this.through.model = this.sequelize.model(this.through.model) : this.through.model = this.sequelize.define(this.through.model, {}, Object.assign(this.options, {\n      tableName: this.through.model,\n      indexes: [],\n      paranoid: this.through.paranoid ? this.through.paranoid : !1,\n      validate: {}\n    }))), Object.assign(this.options, f.pick(this.through.model.options, [\"timestamps\", \"createdAt\", \"updatedAt\", \"deletedAt\", \"paranoid\"])), this.paired) {\n      let s = !1;\n      this.targetKeyDefault && (this.targetKey = this.paired.sourceKey, this.targetKeyField = this.paired.sourceKeyField, this._createForeignAndOtherKeys()), this.paired.targetKeyDefault && this.paired.targetKey !== this.sourceKey && (delete this.through.model.rawAttributes[this.paired.otherKey], this.paired.targetKey = this.sourceKey, this.paired.targetKeyField = this.sourceKeyField, this.paired._createForeignAndOtherKeys(), s = !0), this.otherKeyDefault && (this.otherKey = this.paired.foreignKey), this.paired.otherKeyDefault && this.paired.otherKey !== this.foreignKey && (delete this.through.model.rawAttributes[this.paired.otherKey], this.paired.otherKey = this.foreignKey, s = !0), s && this.paired._injectAttributes();\n    }\n\n    this.through && (this.throughModel = this.through.model), this.options.tableName = this.combinedName = this.through.model === Object(this.through.model) ? this.through.model.tableName : this.through.model, this.associationAccessor = this.as;\n    const i = f.upperFirst(this.options.name.plural),\n          h = f.upperFirst(this.options.name.singular);\n    this.accessors = {\n      get: `get${i}`,\n      set: `set${i}`,\n      addMultiple: `add${i}`,\n      add: `add${h}`,\n      create: `create${h}`,\n      remove: `remove${h}`,\n      removeMultiple: `remove${i}`,\n      hasSingle: `has${h}`,\n      hasAll: `has${i}`,\n      count: `count${i}`\n    };\n  }\n\n  _createForeignAndOtherKeys() {\n    f.isObject(this.options.foreignKey) ? (this.foreignKeyAttribute = this.options.foreignKey, this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName) : (this.foreignKeyAttribute = {}, this.foreignKey = this.options.foreignKey || w.camelize([this.source.options.name.singular, this.sourceKey].join(\"_\"))), f.isObject(this.options.otherKey) ? (this.otherKeyAttribute = this.options.otherKey, this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName) : (this.options.otherKey || (this.otherKeyDefault = !0), this.otherKeyAttribute = {}, this.otherKey = this.options.otherKey || w.camelize([this.isSelfAssociation ? w.singularize(this.as) : this.target.options.name.singular, this.targetKey].join(\"_\")));\n  }\n\n  _injectAttributes() {\n    this.identifier = this.foreignKey, this.foreignIdentifier = this.otherKey, f.each(this.through.model.rawAttributes, (g, c) => {\n      g.primaryKey === !0 && g._autoGenerated === !0 && (c === this.foreignKey || c === this.otherKey ? g.primaryKey = !1 : delete this.through.model.rawAttributes[c], this.primaryKeyDeleted = !0);\n    });\n    const e = this.source.rawAttributes[this.sourceKey].type,\n          t = this.sourceKeyField,\n          h = this.target.rawAttributes[this.targetKey].type,\n          s = this.targetKeyField,\n          a = o({\n      type: e\n    }, this.foreignKeyAttribute),\n          u = o({\n      type: h\n    }, this.otherKeyAttribute);\n    if (this.primaryKeyDeleted === !0) u.primaryKey = a.primaryKey = !0;else if (this.through.unique !== !1) {\n      let g;\n      typeof this.options.uniqueKey == \"string\" && this.options.uniqueKey !== \"\" ? g = this.options.uniqueKey : g = [this.through.model.tableName, this.foreignKey, this.otherKey, \"unique\"].join(\"_\"), u.unique = a.unique = g;\n    }\n    return this.through.model.rawAttributes[this.foreignKey] || (this.through.model.rawAttributes[this.foreignKey] = {\n      _autoGenerated: !0\n    }), this.through.model.rawAttributes[this.otherKey] || (this.through.model.rawAttributes[this.otherKey] = {\n      _autoGenerated: !0\n    }), this.options.constraints !== !1 && (a.references = {\n      model: this.source.getTableName(),\n      key: t\n    }, a.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete, a.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate, a.onDelete || (a.onDelete = \"CASCADE\"), a.onUpdate || (a.onUpdate = \"CASCADE\"), u.references = {\n      model: this.target.getTableName(),\n      key: s\n    }, u.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete, u.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate, u.onDelete || (u.onDelete = \"CASCADE\"), u.onUpdate || (u.onUpdate = \"CASCADE\")), Object.assign(this.through.model.rawAttributes[this.foreignKey], a), Object.assign(this.through.model.rawAttributes[this.otherKey], u), this.through.model.refreshAttributes(), this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey, this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey, this.paired && !this.paired.foreignIdentifierField && (this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey), this.toSource = new T(this.through.model, this.source, {\n      foreignKey: this.foreignKey\n    }), this.manyFromSource = new U(this.source, this.through.model, {\n      foreignKey: this.foreignKey\n    }), this.oneFromSource = new M(this.source, this.through.model, {\n      foreignKey: this.foreignKey,\n      sourceKey: this.sourceKey,\n      as: this.through.model.name\n    }), this.toTarget = new T(this.through.model, this.target, {\n      foreignKey: this.otherKey\n    }), this.manyFromTarget = new U(this.target, this.through.model, {\n      foreignKey: this.otherKey\n    }), this.oneFromTarget = new M(this.target, this.through.model, {\n      foreignKey: this.otherKey,\n      sourceKey: this.targetKey,\n      as: this.through.model.name\n    }), this.paired && this.paired.otherKeyDefault && (this.paired.toTarget = new T(this.paired.through.model, this.paired.target, {\n      foreignKey: this.paired.otherKey\n    }), this.paired.oneFromTarget = new M(this.paired.target, this.paired.through.model, {\n      foreignKey: this.paired.otherKey,\n      sourceKey: this.paired.targetKey,\n      as: this.paired.through.model.name\n    })), C.checkNamingCollision(this), this;\n  }\n\n  mixin(r) {\n    const e = [\"get\", \"count\", \"hasSingle\", \"hasAll\", \"set\", \"add\", \"addMultiple\", \"remove\", \"removeMultiple\", \"create\"],\n          t = {\n      hasSingle: \"has\",\n      hasAll: \"has\",\n      addMultiple: \"add\",\n      removeMultiple: \"remove\"\n    };\n    C.mixinMethods(this, r, e, t);\n  }\n\n  async get(r, e) {\n    e = w.cloneDeep(e) || {};\n    const t = this.through;\n    let i, h;\n    this.scope && (i = o({}, this.scope)), e.where = {\n      [j.and]: [i, e.where]\n    }, Object(t.model) === t.model && (h = {}, h[this.foreignKey] = r.get(this.sourceKey), t.scope && Object.assign(h, t.scope), e.through && e.through.where && (h = {\n      [j.and]: [h, e.through.where]\n    }), e.include = e.include || [], e.include.push({\n      association: this.oneFromTarget,\n      attributes: e.joinTableAttributes,\n      required: !0,\n      paranoid: f.get(e.through, \"paranoid\", !0),\n      where: h\n    }));\n    let s = this.target;\n    return Object.prototype.hasOwnProperty.call(e, \"scope\") && (e.scope ? s = s.scope(e.scope) : s = s.unscoped()), Object.prototype.hasOwnProperty.call(e, \"schema\") && (s = s.schema(e.schema, e.schemaDelimiter)), s.findAll(e);\n  }\n\n  async count(r, e) {\n    const t = this.target.sequelize;\n    e = w.cloneDeep(e), e.attributes = [[t.fn(\"COUNT\", t.col([this.target.name, this.targetKeyField].join(\".\"))), \"count\"]], e.joinTableAttributes = [], e.raw = !0, e.plain = !0;\n    const i = await this.get(r, e);\n    return parseInt(i.count, 10);\n  }\n\n  async has(r, e, t) {\n    Array.isArray(e) || (e = [e]), t = A(o({\n      raw: !0\n    }, t), {\n      scope: !1,\n      attributes: [this.targetKey],\n      joinTableAttributes: []\n    });\n    const i = e.map(s => s instanceof this.target ? s.where() : {\n      [this.targetKey]: s\n    });\n    t.where = {\n      [j.and]: [{\n        [j.or]: i\n      }, t.where]\n    };\n    const h = await this.get(r, t);\n    return f.differenceWith(i, h, (s, a) => f.isEqual(s[this.targetKey], a[this.targetKey])).length === 0;\n  }\n\n  async set(r, e, t) {\n    t = t || {};\n    const i = this.sourceKey,\n          h = this.targetKey,\n          s = this.identifier,\n          a = this.foreignIdentifier;\n    e === null ? e = [] : e = this.toInstanceArray(e);\n    const u = o({\n      [s]: r.get(i)\n    }, this.through.scope),\n          g = D(c => {\n      const q = [],\n            d = [],\n            p = t.through || {},\n            F = e.filter(m => !c.some(n => n[a] === m.get(h)));\n\n      for (const m of c) {\n        const n = e.find(l => m[a] === l.get(h));\n        if (!n) q.push(m);else {\n          let l = n[this.through.model.name];\n          l instanceof this.through.model && (l = {});\n          const K = o(o({}, p), l);\n          Object.keys(K).length && d.push(this.through.model.update(K, Object.assign(t, {\n            where: {\n              [s]: r.get(i),\n              [a]: n.get(h)\n            }\n          })));\n        }\n      }\n\n      if (q.length > 0 && d.push(this.through.model.destroy(A(o({}, t), {\n        where: o({\n          [s]: r.get(i),\n          [a]: q.map(m => m[a])\n        }, this.through.scope)\n      }))), F.length > 0) {\n        const m = F.map(n => o(A(o(o({}, p), n[this.through.model.name]), {\n          [s]: r.get(i),\n          [a]: n.get(h)\n        }), this.through.scope));\n        d.push(this.through.model.bulkCreate(m, o({\n          validate: !0\n        }, t)));\n      }\n\n      return Promise.all(d);\n    }, \"updateAssociations\");\n\n    try {\n      const c = await this.through.model.findAll(A(o({}, t), {\n        where: u,\n        raw: !0\n      }));\n      return await g(c);\n    } catch (c) {\n      if (c instanceof v) return g([]);\n      throw c;\n    }\n  }\n\n  async add(r, e, t) {\n    if (!e) return Promise.resolve();\n    t = o({}, t);\n    const i = this,\n          h = i.sourceKey,\n          s = i.targetKey,\n          a = i.identifier,\n          u = i.foreignIdentifier,\n          g = t.through || {};\n    e = i.toInstanceArray(e);\n    const c = o({\n      [a]: r.get(h),\n      [u]: e.map(d => d.get(s))\n    }, i.through.scope),\n          q = D(d => {\n      const p = [],\n            F = [],\n            m = [];\n\n      for (const n of e) {\n        const l = d && d.find(K => K[u] === n.get(s));\n        if (!l) F.push(n);else {\n          const K = n[i.through.model.name],\n                b = o(o({}, g), K);\n          Object.keys(b).some(N => b[N] !== l[N]) && m.push(n);\n        }\n      }\n\n      if (F.length > 0) {\n        const n = F.map(l => {\n          const K = l[i.through.model.name],\n                b = o(o({}, g), K);\n          return b[a] = r.get(h), b[u] = l.get(s), Object.assign(b, i.through.scope), b;\n        });\n        p.push(i.through.model.bulkCreate(n, o({\n          validate: !0\n        }, t)));\n      }\n\n      for (const n of m) {\n        let l = n[i.through.model.name];\n        const K = o(o({}, g), l);\n        l instanceof i.through.model && (l = {}), p.push(i.through.model.update(K, Object.assign(t, {\n          where: {\n            [a]: r.get(h),\n            [u]: n.get(s)\n          }\n        })));\n      }\n\n      return Promise.all(p);\n    }, \"updateAssociations\");\n\n    try {\n      const d = await i.through.model.findAll(A(o({}, t), {\n        where: c,\n        raw: !0\n      })),\n            [p] = await q(d);\n      return p;\n    } catch (d) {\n      if (d instanceof v) return q();\n      throw d;\n    }\n  }\n\n  remove(r, e, t) {\n    const i = this;\n    t = t || {}, e = i.toInstanceArray(e);\n    const h = {\n      [i.identifier]: r.get(i.sourceKey),\n      [i.foreignIdentifier]: e.map(s => s.get(i.targetKey))\n    };\n    return i.through.model.destroy(A(o({}, t), {\n      where: h\n    }));\n  }\n\n  async create(r, e, t) {\n    const i = this;\n    t = t || {}, e = e || {}, Array.isArray(t) && (t = {\n      fields: t\n    }), i.scope && (Object.assign(e, i.scope), t.fields && (t.fields = t.fields.concat(Object.keys(i.scope))));\n    const h = await i.target.create(e, t);\n    return await r[i.accessors.add](h, f.omit(t, [\"fields\"])), h;\n  }\n\n  verifyAssociationAlias(r) {\n    return typeof r == \"string\" ? this.as === r : r && r.plural ? this.as === r.plural : !this.isAliased;\n  }\n\n}\n\nD(O, \"BelongsToMany\"), module.exports = O, module.exports.BelongsToMany = O, module.exports.default = O;","map":{"version":3,"sources":["../../../lib/associations/belongs-to-many.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\nconst BelongsTo = require('./belongs-to');\nconst HasMany = require('./has-many');\nconst HasOne = require('./has-one');\nconst AssociationError = require('../errors').AssociationError;\nconst EmptyResultError = require('../errors').EmptyResultError;\nconst Op = require('../operators');\n\n/**\n * Many-to-many association with a join table.\n *\n * When the join table has additional attributes, these can be passed in the options object:\n *\n * ```js\n * UserProject = sequelize.define('user_project', {\n *   role: Sequelize.STRING\n * });\n * User.belongsToMany(Project, { through: UserProject });\n * Project.belongsToMany(User, { through: UserProject });\n * // through is required!\n *\n * user.addProject(project, { through: { role: 'manager' }});\n * ```\n *\n * All methods allow you to pass either a persisted instance, its primary key, or a mixture:\n *\n * ```js\n * const project = await Project.create({ id: 11 });\n * await user.addProjects([project, 12]);\n * ```\n *\n * If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model:\n *\n * ```js\n * p1.UserProjects = {\n *   started: true\n * }\n * user.setProjects([p1, p2], { through: { started: false }}) // The default value is false, but p1 overrides that.\n * ```\n *\n * Similarly, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model.\n * ```js\n * const projects = await user.getProjects();\n * const p1 = projects[0];\n * p1.UserProjects.started // Is this project started yet?\n * ```\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.belongsToMany(Project)` the getter will be `user.getProjects()`.\n *\n * @see {@link Model.belongsToMany}\n */\nclass BelongsToMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    if (this.options.through === undefined || this.options.through === true || this.options.through === null) {\n      throw new AssociationError(`${source.name}.belongsToMany(${target.name}) requires through option, pass either a string or a model`);\n    }\n\n    if (!this.options.through.model) {\n      this.options.through = {\n        model: options.through\n      };\n    }\n\n    this.associationType = 'BelongsToMany';\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.through = { ...this.options.through };\n    this.isMultiAssociation = true;\n    this.doubleLinked = false;\n\n    if (!this.as && this.isSelfAssociation) {\n      throw new AssociationError('\\'as\\' must be defined for many-to-many self-associations');\n    }\n\n    if (this.as) {\n      this.isAliased = true;\n\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n\n    this.combinedTableName = Utils.combineTableNames(\n      this.source.tableName,\n      this.isSelfAssociation ? this.as || this.target.tableName : this.target.tableName\n    );\n\n    /*\n    * If self association, this is the target association - Unless we find a pairing association\n    */\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n\n    /*\n    * Find paired association (if exists)\n    */\n    _.each(this.target.associations, association => {\n      if (association.associationType !== 'BelongsToMany') return;\n      if (association.target !== this.source) return;\n\n      if (this.options.through.model === association.options.through.model) {\n        this.paired = association;\n        association.paired = this;\n      }\n    });\n\n    /*\n    * Default/generated source/target keys\n    */\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n\n    if (this.options.targetKey) {\n      this.targetKey = this.options.targetKey;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    } else {\n      this.targetKeyDefault = true;\n      this.targetKey = this.target.primaryKeyAttribute;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    }\n\n    this._createForeignAndOtherKeys();\n\n    if (typeof this.through.model === 'string') {\n      if (!this.sequelize.isDefined(this.through.model)) {\n        this.through.model = this.sequelize.define(this.through.model, {}, Object.assign(this.options, {\n          tableName: this.through.model,\n          indexes: [], //we don't want indexes here (as referenced in #2416)\n          paranoid: this.through.paranoid ? this.through.paranoid : false, // Default to non-paranoid join (referenced in #11991)\n          validate: {} // Don't propagate model-level validations\n        }));\n      } else {\n        this.through.model = this.sequelize.model(this.through.model);\n      }\n    }\n\n    Object.assign(this.options, _.pick(this.through.model.options, [\n      'timestamps', 'createdAt', 'updatedAt', 'deletedAt', 'paranoid'\n    ]));\n\n    if (this.paired) {\n      let needInjectPaired = false;\n\n      if (this.targetKeyDefault) {\n        this.targetKey = this.paired.sourceKey;\n        this.targetKeyField = this.paired.sourceKeyField;\n        this._createForeignAndOtherKeys();\n      }\n      if (this.paired.targetKeyDefault) {\n        // in this case paired.otherKey depends on paired.targetKey,\n        // so cleanup previously wrong generated otherKey\n        if (this.paired.targetKey !== this.sourceKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.targetKey = this.sourceKey;\n          this.paired.targetKeyField = this.sourceKeyField;\n          this.paired._createForeignAndOtherKeys();\n          needInjectPaired = true;\n        }\n      }\n\n      if (this.otherKeyDefault) {\n        this.otherKey = this.paired.foreignKey;\n      }\n      if (this.paired.otherKeyDefault) {\n        // If paired otherKey was inferred we should make sure to clean it up\n        // before adding a new one that matches the foreignKey\n        if (this.paired.otherKey !== this.foreignKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.otherKey = this.foreignKey;\n          needInjectPaired = true;\n        }\n      }\n\n      if (needInjectPaired) {\n        this.paired._injectAttributes();\n      }\n    }\n\n    if (this.through) {\n      this.throughModel = this.through.model;\n    }\n\n    this.options.tableName = this.combinedName = this.through.model === Object(this.through.model) ? this.through.model.tableName : this.through.model;\n\n    this.associationAccessor = this.as;\n\n    // Get singular and plural names, trying to uppercase the first letter, unless the model forbids it\n    const plural = _.upperFirst(this.options.name.plural);\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: `get${plural}`,\n      set: `set${plural}`,\n      addMultiple: `add${plural}`,\n      add: `add${singular}`,\n      create: `create${singular}`,\n      remove: `remove${singular}`,\n      removeMultiple: `remove${plural}`,\n      hasSingle: `has${singular}`,\n      hasAll: `has${plural}`,\n      count: `count${plural}`\n    };\n  }\n\n  _createForeignAndOtherKeys() {\n    /*\n    * Default/generated foreign/other keys\n    */\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else {\n      this.foreignKeyAttribute = {};\n      this.foreignKey = this.options.foreignKey || Utils.camelize(\n        [\n          this.source.options.name.singular,\n          this.sourceKey\n        ].join('_')\n      );\n    }\n\n    if (_.isObject(this.options.otherKey)) {\n      this.otherKeyAttribute = this.options.otherKey;\n      this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;\n    } else {\n      if (!this.options.otherKey) {\n        this.otherKeyDefault = true;\n      }\n\n      this.otherKeyAttribute = {};\n      this.otherKey = this.options.otherKey || Utils.camelize(\n        [\n          this.isSelfAssociation ? Utils.singularize(this.as) : this.target.options.name.singular,\n          this.targetKey\n        ].join('_')\n      );\n    }\n  }\n\n  // the id is in the target table\n  // or in an extra table which connects two tables\n  _injectAttributes() {\n    this.identifier = this.foreignKey;\n    this.foreignIdentifier = this.otherKey;\n\n    // remove any PKs previously defined by sequelize\n    // but ignore any keys that are part of this association (#5865)\n    _.each(this.through.model.rawAttributes, (attribute, attributeName) => {\n      if (attribute.primaryKey === true && attribute._autoGenerated === true) {\n        if (attributeName === this.foreignKey || attributeName === this.otherKey) {\n          // this key is still needed as it's part of the association\n          // so just set primaryKey to false\n          attribute.primaryKey = false;\n        }\n        else {\n          delete this.through.model.rawAttributes[attributeName];\n        }\n        this.primaryKeyDeleted = true;\n      }\n    });\n\n    const sourceKey = this.source.rawAttributes[this.sourceKey];\n    const sourceKeyType = sourceKey.type;\n    const sourceKeyField = this.sourceKeyField;\n    const targetKey = this.target.rawAttributes[this.targetKey];\n    const targetKeyType = targetKey.type;\n    const targetKeyField = this.targetKeyField;\n    const sourceAttribute = { type: sourceKeyType, ...this.foreignKeyAttribute };\n    const targetAttribute = { type: targetKeyType, ...this.otherKeyAttribute };\n\n    if (this.primaryKeyDeleted === true) {\n      targetAttribute.primaryKey = sourceAttribute.primaryKey = true;\n    } else if (this.through.unique !== false) {\n      let uniqueKey;\n      if (typeof this.options.uniqueKey === 'string' && this.options.uniqueKey !== '') {\n        uniqueKey = this.options.uniqueKey;\n      } else {\n        uniqueKey = [this.through.model.tableName, this.foreignKey, this.otherKey, 'unique'].join('_');\n      }\n      targetAttribute.unique = sourceAttribute.unique = uniqueKey;\n    }\n\n    if (!this.through.model.rawAttributes[this.foreignKey]) {\n      this.through.model.rawAttributes[this.foreignKey] = {\n        _autoGenerated: true\n      };\n    }\n\n    if (!this.through.model.rawAttributes[this.otherKey]) {\n      this.through.model.rawAttributes[this.otherKey] = {\n        _autoGenerated: true\n      };\n    }\n\n    if (this.options.constraints !== false) {\n      sourceAttribute.references = {\n        model: this.source.getTableName(),\n        key: sourceKeyField\n      };\n      // For the source attribute the passed option is the priority\n      sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;\n      sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;\n\n      if (!sourceAttribute.onDelete) sourceAttribute.onDelete = 'CASCADE';\n      if (!sourceAttribute.onUpdate) sourceAttribute.onUpdate = 'CASCADE';\n\n      targetAttribute.references = {\n        model: this.target.getTableName(),\n        key: targetKeyField\n      };\n      // But the for target attribute the previously defined option is the priority (since it could've been set by another belongsToMany call)\n      targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;\n      targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;\n\n      if (!targetAttribute.onDelete) targetAttribute.onDelete = 'CASCADE';\n      if (!targetAttribute.onUpdate) targetAttribute.onUpdate = 'CASCADE';\n    }\n\n    Object.assign(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);\n    Object.assign(this.through.model.rawAttributes[this.otherKey], targetAttribute);\n\n    this.through.model.refreshAttributes();\n\n    this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;\n\n    if (this.paired && !this.paired.foreignIdentifierField) {\n      this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;\n    }\n\n    this.toSource = new BelongsTo(this.through.model, this.source, {\n      foreignKey: this.foreignKey\n    });\n    this.manyFromSource = new HasMany(this.source, this.through.model, {\n      foreignKey: this.foreignKey\n    });\n    this.oneFromSource = new HasOne(this.source, this.through.model, {\n      foreignKey: this.foreignKey,\n      sourceKey: this.sourceKey,\n      as: this.through.model.name\n    });\n\n    this.toTarget = new BelongsTo(this.through.model, this.target, {\n      foreignKey: this.otherKey\n    });\n    this.manyFromTarget = new HasMany(this.target, this.through.model, {\n      foreignKey: this.otherKey\n    });\n    this.oneFromTarget = new HasOne(this.target, this.through.model, {\n      foreignKey: this.otherKey,\n      sourceKey: this.targetKey,\n      as: this.through.model.name\n    });\n\n    if (this.paired && this.paired.otherKeyDefault) {\n      this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {\n        foreignKey: this.paired.otherKey\n      });\n\n      this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {\n        foreignKey: this.paired.otherKey,\n        sourceKey: this.paired.targetKey,\n        as: this.paired.through.model.name\n      });\n    }\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];\n    const aliases = {\n      hasSingle: 'has',\n      hasAll: 'has',\n      addMultiple: 'add',\n      removeMultiple: 'remove'\n    };\n\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n\n  /**\n   * Get everything currently associated with this, using an optional where clause.\n   *\n   * @see\n   * {@link Model} for a full explanation of options\n   *\n   * @param {Model} instance instance\n   * @param {object} [options] find options\n   * @param {object} [options.where] An optional where clause to limit the associated models\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {string} [options.schema] Apply a schema on the related model\n   * @param {object} [options.through.where] An optional where clause applied to through model (join table)\n   * @param {boolean} [options.through.paranoid=true] If true, only non-deleted records will be returned from the join table. If false, both deleted and non-deleted records will be returned. Only applies if through model is paranoid\n   *\n   * @returns {Promise<Array<Model>>}\n   */\n  async get(instance, options) {\n    options = Utils.cloneDeep(options) || {};\n\n    const through = this.through;\n    let scopeWhere;\n    let throughWhere;\n\n    if (this.scope) {\n      scopeWhere = { ...this.scope };\n    }\n\n    options.where = {\n      [Op.and]: [\n        scopeWhere,\n        options.where\n      ]\n    };\n\n    if (Object(through.model) === through.model) {\n      throughWhere = {};\n      throughWhere[this.foreignKey] = instance.get(this.sourceKey);\n\n      if (through.scope) {\n        Object.assign(throughWhere, through.scope);\n      }\n\n      //If a user pass a where on the options through options, make an \"and\" with the current throughWhere\n      if (options.through && options.through.where) {\n        throughWhere = {\n          [Op.and]: [throughWhere, options.through.where]\n        };\n      }\n\n      options.include = options.include || [];\n      options.include.push({\n        association: this.oneFromTarget,\n        attributes: options.joinTableAttributes,\n        required: true,\n        paranoid: _.get(options.through, 'paranoid', true),\n        where: throughWhere\n      });\n    }\n\n    let model = this.target;\n    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n      if (!options.scope) {\n        model = model.unscoped();\n      } else {\n        model = model.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n      model = model.schema(options.schema, options.schemaDelimiter);\n    }\n\n    return model.findAll(options);\n  }\n\n  /**\n   * Count everything currently associated with this, using an optional where clause.\n   *\n   * @param {Model} instance instance\n   * @param {object} [options] find options\n   * @param {object} [options.where] An optional where clause to limit the associated models\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   *\n   * @returns {Promise<number>}\n   */\n  async count(instance, options) {\n    const sequelize = this.target.sequelize;\n\n    options = Utils.cloneDeep(options);\n    options.attributes = [\n      [sequelize.fn('COUNT', sequelize.col([this.target.name, this.targetKeyField].join('.'))), 'count']\n    ];\n    options.joinTableAttributes = [];\n    options.raw = true;\n    options.plain = true;\n\n    const result = await this.get(instance, options);\n\n    return parseInt(result.count, 10);\n  }\n\n  /**\n   * Check if one or more instance(s) are associated with this. If a list of instances is passed, the function returns true if _all_ instances are associated\n   *\n   * @param {Model} sourceInstance source instance to check for an association with\n   * @param {Model|Model[]|string[]|string|number[]|number} [instances] Can be an array of instances or their primary keys\n   * @param {object} [options] Options passed to getAssociations\n   *\n   * @returns {Promise<boolean>}\n   */\n  async has(sourceInstance, instances, options) {\n    if (!Array.isArray(instances)) {\n      instances = [instances];\n    }\n\n    options = {\n      raw: true,\n      ...options,\n      scope: false,\n      attributes: [this.targetKey],\n      joinTableAttributes: []\n    };\n\n    const instancePrimaryKeys = instances.map(instance => {\n      if (instance instanceof this.target) {\n        return instance.where();\n      }\n      return {\n        [this.targetKey]: instance\n      };\n    });\n\n    options.where = {\n      [Op.and]: [\n        { [Op.or]: instancePrimaryKeys },\n        options.where\n      ]\n    };\n\n    const associatedObjects = await this.get(sourceInstance, options);\n\n    return _.differenceWith(instancePrimaryKeys, associatedObjects,\n      (a, b) => _.isEqual(a[this.targetKey], b[this.targetKey])).length === 0;\n  }\n\n  /**\n   * Set the associated models by passing an array of instances or their primary keys.\n   * Everything that it not in the passed array will be un-associated.\n   *\n   * @param {Model} sourceInstance source instance to associate new instances with\n   * @param {Model|Model[]|string[]|string|number[]|number} [newAssociatedObjects] A single instance or primary key, or a mixed array of persisted instances or primary keys\n   * @param {object} [options] Options passed to `through.findAll`, `bulkCreate`, `update` and `destroy`\n   * @param {object} [options.validate] Run validation for the join model\n   * @param {object} [options.through] Additional attributes for the join table.\n   *\n   * @returns {Promise}\n   */\n  async set(sourceInstance, newAssociatedObjects, options) {\n    options = options || {};\n\n    const sourceKey = this.sourceKey;\n    const targetKey = this.targetKey;\n    const identifier = this.identifier;\n    const foreignIdentifier = this.foreignIdentifier;\n\n    if (newAssociatedObjects === null) {\n      newAssociatedObjects = [];\n    } else {\n      newAssociatedObjects = this.toInstanceArray(newAssociatedObjects);\n    }\n    const where = {\n      [identifier]: sourceInstance.get(sourceKey),\n      ...this.through.scope\n    };\n\n    const updateAssociations = currentRows => {\n      const obsoleteAssociations = [];\n      const promises = [];\n      const defaultAttributes = options.through || {};\n\n      const unassociatedObjects = newAssociatedObjects.filter(obj =>\n        !currentRows.some(currentRow => currentRow[foreignIdentifier] === obj.get(targetKey))\n      );\n\n      for (const currentRow of currentRows) {\n        const newObj = newAssociatedObjects.find(obj => currentRow[foreignIdentifier] === obj.get(targetKey));\n\n        if (!newObj) {\n          obsoleteAssociations.push(currentRow);\n        } else {\n          let throughAttributes = newObj[this.through.model.name];\n          // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n          if (throughAttributes instanceof this.through.model) {\n            throughAttributes = {};\n          }\n\n          const attributes = { ...defaultAttributes, ...throughAttributes };\n\n          if (Object.keys(attributes).length) {\n            promises.push(\n              this.through.model.update(attributes, Object.assign(options, {\n                where: {\n                  [identifier]: sourceInstance.get(sourceKey),\n                  [foreignIdentifier]: newObj.get(targetKey)\n                }\n              }\n              ))\n            );\n          }\n        }\n      }\n\n      if (obsoleteAssociations.length > 0) {\n        promises.push(\n          this.through.model.destroy({\n            ...options,\n            where: {\n              [identifier]: sourceInstance.get(sourceKey),\n              [foreignIdentifier]: obsoleteAssociations.map(obsoleteAssociation => obsoleteAssociation[foreignIdentifier]),\n              ...this.through.scope\n            }\n          })\n        );\n      }\n\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          return {\n            ...defaultAttributes,\n            ...unassociatedObject[this.through.model.name],\n            [identifier]: sourceInstance.get(sourceKey),\n            [foreignIdentifier]: unassociatedObject.get(targetKey),\n            ...this.through.scope\n          };\n        });\n\n        promises.push(this.through.model.bulkCreate(bulk, { validate: true, ...options }));\n      }\n\n      return Promise.all(promises);\n    };\n\n    try {\n      const currentRows = await this.through.model.findAll({ ...options, where, raw: true });\n      return await updateAssociations(currentRows);\n    } catch (error) {\n      if (error instanceof EmptyResultError) return updateAssociations([]);\n      throw error;\n    }\n  }\n\n  /**\n   * Associate one or several rows with source instance. It will not un-associate any already associated instance\n   * that may be missing from `newInstances`.\n   *\n   * @param {Model} sourceInstance source instance to associate new instances with\n   * @param {Model|Model[]|string[]|string|number[]|number} [newInstances] A single instance or primary key, or a mixed array of persisted instances or primary keys\n   * @param {object} [options] Options passed to `through.findAll`, `bulkCreate` and `update`\n   * @param {object} [options.validate] Run validation for the join model.\n   * @param {object} [options.through] Additional attributes for the join table.\n   *\n   * @returns {Promise}\n   */\n  async add(sourceInstance, newInstances, options) {\n    // If newInstances is null or undefined, no-op\n    if (!newInstances) return Promise.resolve();\n\n    options = { ...options };\n\n    const association = this;\n    const sourceKey = association.sourceKey;\n    const targetKey = association.targetKey;\n    const identifier = association.identifier;\n    const foreignIdentifier = association.foreignIdentifier;\n    const defaultAttributes = options.through || {};\n\n    newInstances = association.toInstanceArray(newInstances);\n\n    const where = {\n      [identifier]: sourceInstance.get(sourceKey),\n      [foreignIdentifier]: newInstances.map(newInstance => newInstance.get(targetKey)),\n      ...association.through.scope\n    };\n\n    const updateAssociations = currentRows => {\n      const promises = [];\n      const unassociatedObjects = [];\n      const changedAssociations = [];\n      for (const obj of newInstances) {\n        const existingAssociation = currentRows && currentRows.find(current => current[foreignIdentifier] === obj.get(targetKey));\n\n        if (!existingAssociation) {\n          unassociatedObjects.push(obj);\n        } else {\n          const throughAttributes = obj[association.through.model.name];\n          const attributes = { ...defaultAttributes, ...throughAttributes };\n\n          if (Object.keys(attributes).some(attribute => attributes[attribute] !== existingAssociation[attribute])) {\n            changedAssociations.push(obj);\n          }\n        }\n      }\n\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          const throughAttributes = unassociatedObject[association.through.model.name];\n          const attributes = { ...defaultAttributes, ...throughAttributes };\n\n          attributes[identifier] = sourceInstance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n\n          Object.assign(attributes, association.through.scope);\n\n          return attributes;\n        });\n\n        promises.push(association.through.model.bulkCreate(bulk, { validate: true, ...options }));\n      }\n\n      for (const assoc of changedAssociations) {\n        let throughAttributes = assoc[association.through.model.name];\n        const attributes = { ...defaultAttributes, ...throughAttributes };\n        // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n        if (throughAttributes instanceof association.through.model) {\n          throughAttributes = {};\n        }\n\n        promises.push(association.through.model.update(attributes, Object.assign(options, { where: {\n          [identifier]: sourceInstance.get(sourceKey),\n          [foreignIdentifier]: assoc.get(targetKey)\n        } })));\n      }\n\n      return Promise.all(promises);\n    };\n\n    try {\n      const currentRows = await association.through.model.findAll({ ...options, where, raw: true });\n      const [associations] = await updateAssociations(currentRows);\n      return associations;\n    } catch (error) {\n      if (error instanceof EmptyResultError) return updateAssociations();\n      throw error;\n    }\n  }\n\n  /**\n   * Un-associate one or more instance(s).\n   *\n   * @param {Model} sourceInstance instance to un associate instances with\n   * @param {Model|Model[]|string|string[]|number|number[]} [oldAssociatedObjects] Can be an Instance or its primary key, or a mixed array of instances and primary keys\n   * @param {object} [options] Options passed to `through.destroy`\n   *\n   * @returns {Promise}\n   */\n  remove(sourceInstance, oldAssociatedObjects, options) {\n    const association = this;\n\n    options = options || {};\n\n    oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);\n\n    const where = {\n      [association.identifier]: sourceInstance.get(association.sourceKey),\n      [association.foreignIdentifier]: oldAssociatedObjects.map(newInstance => newInstance.get(association.targetKey))\n    };\n\n    return association.through.model.destroy({ ...options, where });\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Model} sourceInstance source instance\n   * @param {object} [values] values for target model\n   * @param {object} [options] Options passed to create and add\n   * @param {object} [options.through] Additional attributes for the join table\n   *\n   * @returns {Promise}\n   */\n  async create(sourceInstance, values, options) {\n    const association = this;\n\n    options = options || {};\n    values = values || {};\n\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n\n    if (association.scope) {\n      Object.assign(values, association.scope);\n      if (options.fields) {\n        options.fields = options.fields.concat(Object.keys(association.scope));\n      }\n    }\n\n    // Create the related model instance\n    const newAssociatedObject = await association.target.create(values, options);\n\n    await sourceInstance[association.accessors.add](newAssociatedObject, _.omit(options, ['fields']));\n    return newAssociatedObject;\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === 'string') {\n      return this.as === alias;\n    }\n\n    if (alias && alias.plural) {\n      return this.as === alias.plural;\n    }\n\n    return !this.isAliased;\n  }\n}\n\nmodule.exports = BelongsToMany;\nmodule.exports.BelongsToMany = BelongsToMany;\nmodule.exports.default = BelongsToMany;\n"]},"metadata":{},"sourceType":"script"}