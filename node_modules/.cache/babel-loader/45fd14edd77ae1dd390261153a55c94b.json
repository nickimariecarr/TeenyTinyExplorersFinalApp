{"ast":null,"code":"\"use strict\";\n\nvar h = Object.defineProperty;\n\nvar o = (t, e) => h(t, \"name\", {\n  value: e,\n  configurable: !0\n});\n\nconst q = require(\"fs\"),\n      f = require(\"path\"),\n      g = require(\"../abstract/connection-manager\"),\n      {\n  logger: m\n} = require(\"../../utils/logger\"),\n      a = m.debugContext(\"connection:sqlite\"),\n      y = require(\"../../data-types\").sqlite,\n      E = require(\"../../errors\"),\n      u = require(\"../parserStore\")(\"sqlite\"),\n      {\n  promisify: M\n} = require(\"util\");\n\nclass r extends g {\n  constructor(e, s) {\n    super(e, s);\n    this.sequelize.options.host === \"localhost\" && delete this.sequelize.options.host, this.connections = {}, this.lib = this._loadDialectModule(\"sqlite3\"), this.refreshTypeParser(y);\n  }\n\n  async _onProcessExit() {\n    return await Promise.all(Object.getOwnPropertyNames(this.connections).map(e => M(s => this.connections[e].close(s))())), super._onProcessExit.call(this);\n  }\n\n  _refreshTypeParser(e) {\n    u.refresh(e);\n  }\n\n  _clearTypeParser() {\n    u.clear();\n  }\n\n  async getConnection(e) {\n    e = e || {}, e.uuid = e.uuid || \"default\", !!this.sequelize.options.storage !== null && this.sequelize.options.storage !== void 0 ? e.storage = this.sequelize.options.storage : e.storage = this.sequelize.options.host || \":memory:\", e.inMemory = e.storage === \":memory:\" ? 1 : 0;\n    const s = this.sequelize.options.dialectOptions,\n          c = this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE;\n    if (e.readWriteMode = s && s.mode || c, this.connections[e.inMemory || e.uuid]) return this.connections[e.inMemory || e.uuid];\n    !e.inMemory && (e.readWriteMode & this.lib.OPEN_CREATE) != 0 && q.mkdirSync(f.dirname(e.storage), {\n      recursive: !0\n    });\n    const i = await new Promise((l, d) => {\n      this.connections[e.inMemory || e.uuid] = new this.lib.Database(e.storage, e.readWriteMode, n => {\n        if (n) return d(new E.ConnectionError(n));\n        a(`connection acquired ${e.uuid}`), l(this.connections[e.inMemory || e.uuid]);\n      });\n    });\n    return this.sequelize.config.password && i.run(`PRAGMA KEY=${this.sequelize.escape(this.sequelize.config.password)}`), this.sequelize.options.foreignKeys !== !1 && i.run(\"PRAGMA FOREIGN_KEYS=ON\"), i;\n  }\n\n  releaseConnection(e, s) {\n    e.filename === \":memory:\" && s !== !0 || e.uuid && (e.close(), a(`connection released ${e.uuid}`), delete this.connections[e.uuid]);\n  }\n\n}\n\no(r, \"ConnectionManager\"), module.exports = r, module.exports.ConnectionManager = r, module.exports.default = r;","map":{"version":3,"sources":["../../../../lib/dialects/sqlite/connection-manager.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst { logger } = require('../../utils/logger');\nconst debug = logger.debugContext('connection:sqlite');\nconst dataTypes = require('../../data-types').sqlite;\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('sqlite');\nconst { promisify } = require('util');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n\n    // We attempt to parse file location from a connection uri\n    // but we shouldn't match sequelize default host.\n    if (this.sequelize.options.host === 'localhost') {\n      delete this.sequelize.options.host;\n    }\n\n    this.connections = {};\n    this.lib = this._loadDialectModule('sqlite3');\n    this.refreshTypeParser(dataTypes);\n  }\n\n  async _onProcessExit() {\n    await Promise.all(\n      Object.getOwnPropertyNames(this.connections)\n        .map(connection => promisify(callback => this.connections[connection].close(callback))())\n    );\n    return super._onProcessExit.call(this);\n  }\n\n  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async getConnection(options) {\n    options = options || {};\n    options.uuid = options.uuid || 'default';\n\n    if (!!this.sequelize.options.storage !== null && this.sequelize.options.storage !== undefined) {\n      // Check explicitely for the storage option to not be set since an empty string signals\n      // SQLite will create a temporary disk-based database in that case.\n      options.storage = this.sequelize.options.storage;\n    } else {\n      options.storage = this.sequelize.options.host || ':memory:';\n    }\n\n    options.inMemory = options.storage === ':memory:' ? 1 : 0;\n\n    const dialectOptions = this.sequelize.options.dialectOptions;\n    const defaultReadWriteMode = this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE;\n\n    options.readWriteMode = dialectOptions && dialectOptions.mode || defaultReadWriteMode;\n\n    if (this.connections[options.inMemory || options.uuid]) {\n      return this.connections[options.inMemory || options.uuid];\n    }\n\n    if (!options.inMemory && (options.readWriteMode & this.lib.OPEN_CREATE) !== 0) {\n      // automatic path provision for `options.storage`\n      fs.mkdirSync(path.dirname(options.storage), { recursive: true });\n    }\n\n    const connection = await new Promise((resolve, reject) => {\n      this.connections[options.inMemory || options.uuid] = new this.lib.Database(\n        options.storage,\n        options.readWriteMode,\n        err => {\n          if (err) return reject(new sequelizeErrors.ConnectionError(err));\n          debug(`connection acquired ${options.uuid}`);\n          resolve(this.connections[options.inMemory || options.uuid]);\n        }\n      );\n    });\n\n    if (this.sequelize.config.password) {\n      // Make it possible to define and use password for sqlite encryption plugin like sqlcipher\n      connection.run(`PRAGMA KEY=${this.sequelize.escape(this.sequelize.config.password)}`);\n    }\n    if (this.sequelize.options.foreignKeys !== false) {\n      // Make it possible to define and use foreign key constraints unless\n      // explicitly disallowed. It's still opt-in per relation\n      connection.run('PRAGMA FOREIGN_KEYS=ON');\n    }\n\n    return connection;\n  }\n\n  releaseConnection(connection, force) {\n    if (connection.filename === ':memory:' && force !== true) return;\n\n    if (connection.uuid) {\n      connection.close();\n      debug(`connection released ${connection.uuid}`);\n      delete this.connections[connection.uuid];\n    }\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}