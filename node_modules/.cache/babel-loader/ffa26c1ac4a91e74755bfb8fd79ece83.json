{"ast":null,"code":"\"use strict\";\n\nvar N = Object.defineProperty;\nvar $ = Object.getOwnPropertySymbols;\nvar y = Object.prototype.hasOwnProperty,\n    L = Object.prototype.propertyIsEnumerable;\n\nvar R = (u, e, t) => e in u ? N(u, e, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: t\n}) : u[e] = t,\n    _ = (u, e) => {\n  for (var t in e || (e = {})) y.call(e, t) && R(u, t, e[t]);\n\n  if ($) for (var t of $(e)) L.call(e, t) && R(u, t, e[t]);\n  return u;\n};\n\nvar A = (u, e) => N(u, \"name\", {\n  value: e,\n  configurable: !0\n});\n\nconst d = require(\"../../utils\"),\n      O = require(\"util\"),\n      p = require(\"../../data-types\"),\n      C = require(\"../abstract/query-generator\"),\n      g = require(\"semver\"),\n      m = require(\"lodash\");\n\nclass I extends C {\n  setSearchPath(e) {\n    return `SET search_path to ${e};`;\n  }\n\n  createDatabaseQuery(e, t) {\n    t = _({\n      encoding: null,\n      collate: null\n    }, t);\n    const n = {\n      database: this.quoteTable(e),\n      encoding: t.encoding ? ` ENCODING = ${this.escape(t.encoding)}` : \"\",\n      collation: t.collate ? ` LC_COLLATE = ${this.escape(t.collate)}` : \"\",\n      ctype: t.ctype ? ` LC_CTYPE = ${this.escape(t.ctype)}` : \"\",\n      template: t.template ? ` TEMPLATE = ${this.escape(t.template)}` : \"\"\n    };\n    return `CREATE DATABASE ${n.database}${n.encoding}${n.collation}${n.ctype}${n.template};`;\n  }\n\n  dropDatabaseQuery(e) {\n    return `DROP DATABASE IF EXISTS ${this.quoteTable(e)};`;\n  }\n\n  createSchema(e) {\n    const t = m.get(this, \"sequelize.options.databaseVersion\", 0);\n    return t && g.gte(t, \"9.2.0\") ? `CREATE SCHEMA IF NOT EXISTS ${e};` : `CREATE SCHEMA ${e};`;\n  }\n\n  dropSchema(e) {\n    return `DROP SCHEMA IF EXISTS ${e} CASCADE;`;\n  }\n\n  showSchemasQuery() {\n    return \"SELECT schema_name FROM information_schema.schemata WHERE schema_name <> 'information_schema' AND schema_name != 'public' AND schema_name !~ E'^pg_';\";\n  }\n\n  versionQuery() {\n    return \"SHOW SERVER_VERSION\";\n  }\n\n  createTableQuery(e, t, n) {\n    n = _({}, n);\n    const a = m.get(this, \"sequelize.options.databaseVersion\", 0),\n          i = [];\n    let r = \"\",\n        s = \"\";\n    const o = this.quoteTable(e);\n    n.comment && typeof n.comment == \"string\" && (r += `; COMMENT ON TABLE ${o} IS ${this.escape(n.comment)}`);\n\n    for (const c in t) {\n      const h = this.quoteIdentifier(c),\n            f = t[c].indexOf(\"COMMENT \");\n\n      if (f !== -1) {\n        const S = this.escape(t[c].substring(f + 8));\n        s += `; COMMENT ON COLUMN ${o}.${h} IS ${S}`, t[c] = t[c].substring(0, f);\n      }\n\n      const T = this.dataTypeMapping(e, c, t[c]);\n      i.push(`${h} ${T}`);\n    }\n\n    let l = i.join(\", \");\n    n.uniqueKeys && m.each(n.uniqueKeys, c => {\n      c.customIndex && (l += `, UNIQUE (${c.fields.map(h => this.quoteIdentifier(h)).join(\", \")})`);\n    });\n    const E = m.reduce(t, (c, h, f) => (h.includes(\"PRIMARY KEY\") && c.push(this.quoteIdentifier(f)), c), []).join(\",\");\n    return E.length > 0 && (l += `, PRIMARY KEY (${E})`), `CREATE TABLE ${a === 0 || g.gte(a, \"9.1.0\") ? \"IF NOT EXISTS \" : \"\"}${o} (${l})${r}${s};`;\n  }\n\n  dropTableQuery(e, t) {\n    return t = t || {}, `DROP TABLE IF EXISTS ${this.quoteTable(e)}${t.cascade ? \" CASCADE\" : \"\"};`;\n  }\n\n  showTablesQuery() {\n    return \"SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_type LIKE '%TABLE' AND table_name != 'spatial_ref_sys';\";\n  }\n\n  describeTableQuery(e, t) {\n    return t || (t = \"public\"), `SELECT pk.constraint_type as \"Constraint\",c.column_name as \"Field\", c.column_default as \"Default\",c.is_nullable as \"Null\", (CASE WHEN c.udt_name = 'hstore' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN '(' || c.character_maximum_length || ')' ELSE '' END) as \"Type\", (SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS \"special\", (SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS \"Comment\" FROM information_schema.columns c LEFT JOIN (SELECT tc.table_schema, tc.table_name, cu.column_name, tc.constraint_type FROM information_schema.TABLE_CONSTRAINTS tc JOIN information_schema.KEY_COLUMN_USAGE  cu ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name and tc.constraint_name=cu.constraint_name and tc.constraint_type='PRIMARY KEY') pk ON pk.table_schema=c.table_schema AND pk.table_name=c.table_name AND pk.column_name=c.column_name WHERE c.table_name = ${this.escape(e)} AND c.table_schema = ${this.escape(t)} `;\n  }\n\n  _checkValidJsonStatement(e) {\n    if (typeof e != \"string\") return !1;\n    const t = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i,\n          n = /^\\s*(->>?|#>>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i,\n          a = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n    let i = 0,\n        r = 0,\n        s = 0,\n        o = !1,\n        l = !1;\n\n    for (; i < e.length;) {\n      const E = e.substr(i),\n            c = t.exec(E);\n\n      if (c) {\n        i += c[0].indexOf(\"(\"), o = !0;\n        continue;\n      }\n\n      const h = n.exec(E);\n\n      if (h) {\n        i += h[0].length, o = !0;\n        continue;\n      }\n\n      const f = a.exec(E);\n\n      if (f) {\n        const T = f[1];\n        if (T === \"(\") r++;else if (T === \")\") s++;else if (T === \";\") {\n          l = !0;\n          break;\n        }\n        i += f[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    if (l |= r !== s, o && l) throw new Error(`Invalid json statement: ${e}`);\n    return o;\n  }\n\n  handleSequelizeMethod(e, t, n, a, i) {\n    if (e instanceof d.Json) {\n      if (e.conditions) return this.parseConditionObject(e.conditions).map(s => `${this.jsonPathExtractionQuery(s.path[0], m.tail(s.path))} = '${s.value}'`).join(\" AND \");\n\n      if (e.path) {\n        let r;\n        if (this._checkValidJsonStatement(e.path)) r = e.path;else {\n          const s = m.toPath(e.path),\n                o = s.shift();\n          r = this.jsonPathExtractionQuery(o, s);\n        }\n        return e.value && (r += O.format(\" = %s\", this.escape(e.value))), r;\n      }\n    }\n\n    return super.handleSequelizeMethod.call(this, e, t, n, a, i);\n  }\n\n  addColumnQuery(e, t, n) {\n    const a = this.attributeToSQL(n, {\n      context: \"addColumn\",\n      table: e,\n      key: t\n    }),\n          i = n.type || n,\n          r = this.dataTypeMapping(e, t, a),\n          s = this.quoteIdentifier(t);\n    let l = `ALTER TABLE ${this.quoteTable(this.extractTableDetails(e))} ADD COLUMN ${s} ${r};`;\n    return i instanceof p.ENUM ? l = this.pgEnum(e, t, i) + l : i.type && i.type instanceof p.ENUM && (l = this.pgEnum(e, t, i.type) + l), l;\n  }\n\n  removeColumnQuery(e, t) {\n    const n = this.quoteTable(this.extractTableDetails(e)),\n          a = this.quoteIdentifier(t);\n    return `ALTER TABLE ${n} DROP COLUMN ${a};`;\n  }\n\n  changeColumnQuery(e, t) {\n    const n = A(i => `ALTER TABLE ${this.quoteTable(e)} ALTER COLUMN ${i};`, \"query\"),\n          a = [];\n\n    for (const i in t) {\n      let r = this.dataTypeMapping(e, i, t[i]),\n          s = \"\";\n      r.includes(\"NOT NULL\") ? (s += n(`${this.quoteIdentifier(i)} SET NOT NULL`), r = r.replace(\"NOT NULL\", \"\").trim()) : r.includes(\"REFERENCES\") || (s += n(`${this.quoteIdentifier(i)} DROP NOT NULL`)), r.includes(\"DEFAULT\") ? (s += n(`${this.quoteIdentifier(i)} SET DEFAULT ${r.match(/DEFAULT ([^;]+)/)[1]}`), r = r.replace(/(DEFAULT[^;]+)/, \"\").trim()) : r.includes(\"REFERENCES\") || (s += n(`${this.quoteIdentifier(i)} DROP DEFAULT`)), t[i].startsWith(\"ENUM(\") && (s += this.pgEnum(e, i, t[i]), r = r.replace(/^ENUM\\(.+\\)/, this.pgEnumName(e, i, {\n        schema: !1\n      })), r += ` USING (${this.quoteIdentifier(i)}::${this.pgEnumName(e, i)})`), r.match(/UNIQUE;*$/) && (r = r.replace(/UNIQUE;*$/, \"\"), s += n(`ADD UNIQUE (${this.quoteIdentifier(i)})`).replace(\"ALTER COLUMN\", \"\")), r.includes(\"REFERENCES\") ? (r = r.replace(/.+?(?=REFERENCES)/, \"\"), s += n(`ADD FOREIGN KEY (${this.quoteIdentifier(i)}) ${r}`).replace(\"ALTER COLUMN\", \"\")) : s += n(`${this.quoteIdentifier(i)} TYPE ${r}`), a.push(s);\n    }\n\n    return a.join(\"\");\n  }\n\n  renameColumnQuery(e, t, n) {\n    const a = [];\n\n    for (const i in n) a.push(`${this.quoteIdentifier(t)} TO ${this.quoteIdentifier(i)}`);\n\n    return `ALTER TABLE ${this.quoteTable(e)} RENAME COLUMN ${a.join(\", \")};`;\n  }\n\n  fn(e, t, n, a, i, r) {\n    return e = e || \"testfunc\", r = r || \"plpgsql\", i = i ? `RETURNS ${i}` : \"\", n = n || \"\", `CREATE OR REPLACE FUNCTION pg_temp.${e}(${n}) ${i} AS $func$ BEGIN ${a} END; $func$ LANGUAGE ${r}; SELECT * FROM pg_temp.${e}();`;\n  }\n\n  truncateTableQuery(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return [`TRUNCATE ${this.quoteTable(e)}`, t.restartIdentity ? \" RESTART IDENTITY\" : \"\", t.cascade ? \" CASCADE\" : \"\"].join(\"\");\n  }\n\n  deleteQuery(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let a = arguments.length > 3 ? arguments[3] : undefined;\n    const i = this.quoteTable(e);\n    let r = this.getWhereConditions(t, null, a, n);\n    const s = n.limit ? ` LIMIT ${this.escape(n.limit)}` : \"\";\n    let o = \"\",\n        l = \"\";\n\n    if (r && (r = ` WHERE ${r}`), n.limit) {\n      if (!a) throw new Error(\"Cannot LIMIT delete without a model.\");\n      const E = Object.values(a.primaryKeys).map(c => this.quoteIdentifier(c.field)).join(\",\");\n      return o = a.primaryKeyAttributes.length > 1 ? `(${E})` : E, l = E, `DELETE FROM ${i} WHERE ${o} IN (SELECT ${l} FROM ${i}${r}${s})`;\n    }\n\n    return `DELETE FROM ${i}${r}`;\n  }\n\n  showIndexesQuery(e) {\n    let t = \"\",\n        n = \"\";\n    return typeof e != \"string\" && (t = \", pg_namespace s\", n = ` AND s.oid = t.relnamespace AND s.nspname = '${e.schema}'`, e = e.tableName), `SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a${t} WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = '${e}'${n} GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;`;\n  }\n\n  showConstraintsQuery(e) {\n    return ['SELECT constraint_catalog AS \"constraintCatalog\",', 'constraint_schema AS \"constraintSchema\",', 'constraint_name AS \"constraintName\",', 'table_catalog AS \"tableCatalog\",', 'table_schema AS \"tableSchema\",', 'table_name AS \"tableName\",', 'constraint_type AS \"constraintType\",', 'is_deferrable AS \"isDeferrable\",', 'initially_deferred AS \"initiallyDeferred\"', \"from INFORMATION_SCHEMA.table_constraints\", `WHERE table_name='${e}';`].join(\" \");\n  }\n\n  removeIndexQuery(e, t) {\n    let n = t;\n    return typeof n != \"string\" && (n = d.underscore(`${e}_${t.join(\"_\")}`)), `DROP INDEX IF EXISTS ${this.quoteIdentifiers(n)}`;\n  }\n\n  addLimitAndOffset(e) {\n    let t = \"\";\n    return e.limit != null && (t += \" LIMIT \" + this.escape(e.limit)), e.offset != null && (t += \" OFFSET \" + this.escape(e.offset)), t;\n  }\n\n  attributeToSQL(e, t) {\n    m.isPlainObject(e) || (e = {\n      type: e\n    });\n    let n;\n\n    if (e.type instanceof p.ENUM || e.type instanceof p.ARRAY && e.type.type instanceof p.ENUM) {\n      const i = e.type.type || e.type;\n      let r = e.values;\n      if (i.values && !e.values && (r = i.values), Array.isArray(r) && r.length > 0) n = `ENUM(${r.map(s => this.escape(s)).join(\", \")})`, e.type instanceof p.ARRAY && (n += \"[]\");else throw new Error(\"Values for ENUM haven't been defined.\");\n    }\n\n    n || (n = e.type);\n    let a = n.toString();\n\n    if (Object.prototype.hasOwnProperty.call(e, \"allowNull\") && !e.allowNull && (a += \" NOT NULL\"), e.autoIncrement && (e.autoIncrementIdentity ? a += \" GENERATED BY DEFAULT AS IDENTITY\" : a += \" SERIAL\"), d.defaultValueSchemable(e.defaultValue) && (a += ` DEFAULT ${this.escape(e.defaultValue, e)}`), e.unique === !0 && (a += \" UNIQUE\"), e.primaryKey && (a += \" PRIMARY KEY\"), e.references) {\n      let i = this.quoteTable(e.references.model),\n          r;\n      t.schema ? r = t.schema : (!e.references.model || typeof e.references.model == \"string\") && t.table && t.table.schema && (r = t.table.schema), r && (i = this.quoteTable(this.addSchema({\n        tableName: i,\n        _schema: r\n      })));\n      let s;\n      e.references.key ? s = this.quoteIdentifiers(e.references.key) : s = this.quoteIdentifier(\"id\"), a += ` REFERENCES ${i} (${s})`, e.onDelete && (a += ` ON DELETE ${e.onDelete.toUpperCase()}`), e.onUpdate && (a += ` ON UPDATE ${e.onUpdate.toUpperCase()}`), e.references.deferrable && (a += ` ${e.references.deferrable.toString(this)}`);\n    }\n\n    if (e.comment && typeof e.comment == \"string\") if (t && (t.context === \"addColumn\" || t.context === \"changeColumn\")) {\n      const i = this.quoteIdentifier(t.key),\n            r = this.escape(e.comment);\n      a += `; COMMENT ON COLUMN ${this.quoteTable(t.table)}.${i} IS ${r}`;\n    } else a += ` COMMENT ${e.comment}`;\n    return a;\n  }\n\n  deferConstraintsQuery(e) {\n    return e.deferrable.toString(this);\n  }\n\n  setConstraintQuery(e, t) {\n    let n = \"ALL\";\n    return e && (n = e.map(a => this.quoteIdentifier(a)).join(\", \")), `SET CONSTRAINTS ${n} ${t}`;\n  }\n\n  setDeferredQuery(e) {\n    return this.setConstraintQuery(e, \"DEFERRED\");\n  }\n\n  setImmediateQuery(e) {\n    return this.setConstraintQuery(e, \"IMMEDIATE\");\n  }\n\n  attributesToSQL(e, t) {\n    const n = {};\n\n    for (const a in e) {\n      const i = e[a];\n      n[i.field || a] = this.attributeToSQL(i, _({\n        key: a\n      }, t));\n    }\n\n    return n;\n  }\n\n  createTrigger(e, t, n, a, i, r, s) {\n    const o = this.decodeTriggerEventType(n),\n          l = this.expandTriggerEventSpec(a),\n          E = this.expandOptions(s),\n          c = this._expandFunctionParamList(r);\n\n    return `CREATE ${this.triggerEventTypeIsConstraint(n)}TRIGGER ${this.quoteIdentifier(t)} ${o} ${l} ON ${this.quoteTable(e)}${E ? ` ${E}` : \"\"} EXECUTE PROCEDURE ${i}(${c});`;\n  }\n\n  dropTrigger(e, t) {\n    return `DROP TRIGGER ${this.quoteIdentifier(t)} ON ${this.quoteTable(e)} RESTRICT;`;\n  }\n\n  renameTrigger(e, t, n) {\n    return `ALTER TRIGGER ${this.quoteIdentifier(t)} ON ${this.quoteTable(e)} RENAME TO ${this.quoteIdentifier(n)};`;\n  }\n\n  createFunction(e, t, n, a, i, r, s) {\n    if (!e || !n || !a || !i) throw new Error(\"createFunction missing some parameters. Did you pass functionName, returnType, language and body?\");\n\n    const o = this._expandFunctionParamList(t),\n          l = s && s.variables ? this._expandFunctionVariableList(s.variables) : \"\",\n          E = this.expandOptions(r);\n\n    return `${s && s.force ? \"CREATE OR REPLACE FUNCTION\" : \"CREATE FUNCTION\"} ${e}(${o}) RETURNS ${n} AS $func$ ${l} BEGIN ${i} END; $func$ language '${a}'${E};`;\n  }\n\n  dropFunction(e, t) {\n    if (!e) throw new Error(\"requires functionName\");\n\n    const n = this._expandFunctionParamList(t);\n\n    return `DROP FUNCTION ${e}(${n}) RESTRICT;`;\n  }\n\n  renameFunction(e, t, n) {\n    const a = this._expandFunctionParamList(t);\n\n    return `ALTER FUNCTION ${e}(${a}) RENAME TO ${n};`;\n  }\n\n  pgEscapeAndQuote(e) {\n    return this.quoteIdentifier(d.removeTicks(this.escape(e), \"'\"));\n  }\n\n  _expandFunctionParamList(e) {\n    if (e === void 0 || !Array.isArray(e)) throw new Error(\"_expandFunctionParamList: function parameters array required, including an empty one for no arguments\");\n    const t = [];\n    return e.forEach(n => {\n      const a = [];\n      if (n.type) n.direction && a.push(n.direction), n.name && a.push(n.name), a.push(n.type);else throw new Error(\"function or trigger used with a parameter without any type\");\n      const i = a.join(\" \");\n      i && t.push(i);\n    }), t.join(\", \");\n  }\n\n  _expandFunctionVariableList(e) {\n    if (!Array.isArray(e)) throw new Error(\"_expandFunctionVariableList: function variables must be an array\");\n    const t = [];\n    return e.forEach(n => {\n      if (!n.name || !n.type) throw new Error(\"function variable must have a name and type\");\n      let a = `DECLARE ${n.name} ${n.type}`;\n      n.default && (a += ` := ${n.default}`), a += \";\", t.push(a);\n    }), t.join(\" \");\n  }\n\n  expandOptions(e) {\n    return e === void 0 || m.isEmpty(e) ? \"\" : e.join(\" \");\n  }\n\n  decodeTriggerEventType(e) {\n    const t = {\n      after: \"AFTER\",\n      before: \"BEFORE\",\n      instead_of: \"INSTEAD OF\",\n      after_constraint: \"AFTER\"\n    };\n    if (!t[e]) throw new Error(`Invalid trigger event specified: ${e}`);\n    return t[e];\n  }\n\n  triggerEventTypeIsConstraint(e) {\n    return e === \"after_constraint\" ? \"CONSTRAINT \" : \"\";\n  }\n\n  expandTriggerEventSpec(e) {\n    if (m.isEmpty(e)) throw new Error(\"no table change events specified to trigger on\");\n    return m.map(e, (t, n) => {\n      const a = {\n        insert: \"INSERT\",\n        update: \"UPDATE\",\n        delete: \"DELETE\",\n        truncate: \"TRUNCATE\"\n      };\n      if (!a[t]) throw new Error(`parseTriggerEventSpec: undefined trigger event ${n}`);\n      let i = a[t];\n      return i === \"UPDATE\" && Array.isArray(t) && t.length > 0 && (i += ` OF ${t.join(\", \")}`), i;\n    }).join(\" OR \");\n  }\n\n  pgEnumName(e, t, n) {\n    n = n || {};\n    const a = this.extractTableDetails(e, n);\n    let i = d.addTicks(d.generateEnumName(a.tableName, t), '\"');\n    return n.schema !== !1 && a.schema && (i = this.quoteIdentifier(a.schema) + a.delimiter + i), i;\n  }\n\n  pgListEnums(e, t, n) {\n    let a = \"\";\n    const i = this.extractTableDetails(e, n);\n    return i.tableName && t && (a = ` AND t.typname=${this.pgEnumName(i.tableName, t, {\n      schema: !1\n    }).replace(/\"/g, \"'\")}`), `SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = '${i.schema}'${a} GROUP BY 1`;\n  }\n\n  pgEnum(e, t, n, a) {\n    const i = this.pgEnumName(e, t, a);\n    let r;\n    n.values ? r = `ENUM(${n.values.map(o => this.escape(o)).join(\", \")})` : r = n.toString().match(/^ENUM\\(.+\\)/)[0];\n    let s = `CREATE TYPE ${i} AS ${r};`;\n    return !!a && a.force === !0 && (s = this.pgEnumDrop(e, t) + s), s;\n  }\n\n  pgEnumAdd(e, t, n, a) {\n    let r = `ALTER TYPE ${this.pgEnumName(e, t)} ADD VALUE `;\n    return g.gte(this.sequelize.options.databaseVersion, \"9.3.0\") && (r += \"IF NOT EXISTS \"), r += this.escape(n), a.before ? r += ` BEFORE ${this.escape(a.before)}` : a.after && (r += ` AFTER ${this.escape(a.after)}`), r;\n  }\n\n  pgEnumDrop(e, t, n) {\n    return n = n || this.pgEnumName(e, t), `DROP TYPE IF EXISTS ${n}; `;\n  }\n\n  fromArray(e) {\n    e = e.replace(/^{/, \"\").replace(/}$/, \"\");\n    let t = e.match(/(\"(?:\\\\.|[^\"\\\\\\\\])*\"|[^,]*)(?:\\s*,\\s*|\\s*$)/ig);\n    return t.length < 1 ? [] : (t = t.map(n => n.replace(/\",$/, \"\").replace(/,$/, \"\").replace(/(^\"|\"$)/g, \"\")), t.slice(0, -1));\n  }\n\n  dataTypeMapping(e, t, n) {\n    return n.includes(\"PRIMARY KEY\") && (n = n.replace(\"PRIMARY KEY\", \"\")), n.includes(\"SERIAL\") && (n.includes(\"BIGINT\") ? (n = n.replace(\"SERIAL\", \"BIGSERIAL\"), n = n.replace(\"BIGINT\", \"\")) : n.includes(\"SMALLINT\") ? (n = n.replace(\"SERIAL\", \"SMALLSERIAL\"), n = n.replace(\"SMALLINT\", \"\")) : n = n.replace(\"INTEGER\", \"\"), n = n.replace(\"NOT NULL\", \"\")), n.startsWith(\"ENUM(\") && (n = n.replace(/^ENUM\\(.+\\)/, this.pgEnumName(e, t))), n;\n  }\n\n  getForeignKeysQuery(e) {\n    return `SELECT conname as constraint_name, pg_catalog.pg_get_constraintdef(r.oid, true) as condef FROM pg_catalog.pg_constraint r WHERE r.conrelid = (SELECT oid FROM pg_class WHERE relname = '${e}' LIMIT 1) AND r.contype = 'f' ORDER BY 1;`;\n  }\n\n  _getForeignKeyReferencesQueryPrefix() {\n    return \"SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name \";\n  }\n\n  getForeignKeyReferencesQuery(e, t, n) {\n    return `${this._getForeignKeyReferencesQueryPrefix()}WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = '${e}'${t ? ` AND tc.table_catalog = '${t}'` : \"\"}${n ? ` AND tc.table_schema = '${n}'` : \"\"}`;\n  }\n\n  getForeignKeyReferenceQuery(e, t) {\n    const n = e.tableName || e,\n          a = e.schema;\n    return `${this._getForeignKeyReferencesQueryPrefix()}WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name='${n}' AND  kcu.column_name = '${t}'${a ? ` AND tc.table_schema = '${a}'` : \"\"}`;\n  }\n\n  dropForeignKeyQuery(e, t) {\n    return `ALTER TABLE ${this.quoteTable(e)} DROP CONSTRAINT ${this.quoteIdentifier(t)};`;\n  }\n\n}\n\nA(I, \"PostgresQueryGenerator\"), module.exports = I;","map":{"version":3,"sources":["../../../../lib/dialects/postgres/query-generator.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst Utils = require('../../utils');\nconst util = require('util');\nconst DataTypes = require('../../data-types');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst semver = require('semver');\nconst _ = require('lodash');\n\nclass PostgresQueryGenerator extends AbstractQueryGenerator {\n  setSearchPath(searchPath) {\n    return `SET search_path to ${searchPath};`;\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = {\n      encoding: null,\n      collate: null,\n      ...options\n    };\n\n    const values = {\n      database: this.quoteTable(databaseName),\n      encoding: options.encoding ? ` ENCODING = ${this.escape(options.encoding)}` : '',\n      collation: options.collate ? ` LC_COLLATE = ${this.escape(options.collate)}` : '',\n      ctype: options.ctype ? ` LC_CTYPE = ${this.escape(options.ctype)}` : '',\n      template: options.template ? ` TEMPLATE = ${this.escape(options.template)}` : ''\n    };\n\n    return `CREATE DATABASE ${values.database}${values.encoding}${values.collation}${values.ctype}${values.template};`;\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteTable(databaseName)};`;\n  }\n\n  createSchema(schema) {\n    const databaseVersion = _.get(this, 'sequelize.options.databaseVersion', 0);\n\n    if (databaseVersion && semver.gte(databaseVersion, '9.2.0')) {\n      return `CREATE SCHEMA IF NOT EXISTS ${schema};`;\n    }\n\n    return `CREATE SCHEMA ${schema};`;\n  }\n\n  dropSchema(schema) {\n    return `DROP SCHEMA IF EXISTS ${schema} CASCADE;`;\n  }\n\n  showSchemasQuery() {\n    return \"SELECT schema_name FROM information_schema.schemata WHERE schema_name <> 'information_schema' AND schema_name != 'public' AND schema_name !~ E'^pg_';\";\n  }\n\n  versionQuery() {\n    return 'SHOW SERVER_VERSION';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = { ...options };\n\n    //Postgres 9.0 does not support CREATE TABLE IF NOT EXISTS, 9.1 and above do\n    const databaseVersion = _.get(this, 'sequelize.options.databaseVersion', 0);\n    const attrStr = [];\n    let comments = '';\n    let columnComments = '';\n\n    const quotedTable = this.quoteTable(tableName);\n\n    if (options.comment && typeof options.comment === 'string') {\n      comments += `; COMMENT ON TABLE ${quotedTable} IS ${this.escape(options.comment)}`;\n    }\n\n    for (const attr in attributes) {\n      const quotedAttr = this.quoteIdentifier(attr);\n      const i = attributes[attr].indexOf('COMMENT ');\n      if (i !== -1) {\n        // Move comment to a separate query\n        const escapedCommentText = this.escape(attributes[attr].substring(i + 8));\n        columnComments += `; COMMENT ON COLUMN ${quotedTable}.${quotedAttr} IS ${escapedCommentText}`;\n        attributes[attr] = attributes[attr].substring(0, i);\n      }\n\n      const dataType = this.dataTypeMapping(tableName, attr, attributes[attr]);\n      attrStr.push(`${quotedAttr} ${dataType}`);\n    }\n\n\n    let attributesClause = attrStr.join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, columns => {\n        if (columns.customIndex) {\n          attributesClause += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    const pks = _.reduce(attributes, (acc, attribute, key) => {\n      if (attribute.includes('PRIMARY KEY')) {\n        acc.push(this.quoteIdentifier(key));\n      }\n      return acc;\n    }, []).join(',');\n\n    if (pks.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pks})`;\n    }\n\n    return `CREATE TABLE ${databaseVersion === 0 || semver.gte(databaseVersion, '9.1.0') ? 'IF NOT EXISTS ' : ''}${quotedTable} (${attributesClause})${comments}${columnComments};`;\n  }\n\n  dropTableQuery(tableName, options) {\n    options = options || {};\n    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)}${options.cascade ? ' CASCADE' : ''};`;\n  }\n\n  showTablesQuery() {\n    return \"SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_type LIKE '%TABLE' AND table_name != 'spatial_ref_sys';\";\n  }\n\n  describeTableQuery(tableName, schema) {\n    if (!schema) schema = 'public';\n\n    return 'SELECT ' +\n      'pk.constraint_type as \"Constraint\",' +\n      'c.column_name as \"Field\", ' +\n      'c.column_default as \"Default\",' +\n      'c.is_nullable as \"Null\", ' +\n      '(CASE WHEN c.udt_name = \\'hstore\\' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN \\'(\\' || c.character_maximum_length || \\')\\' ELSE \\'\\' END) as \"Type\", ' +\n      '(SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS \"special\", ' +\n      '(SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS \"Comment\" ' +\n      'FROM information_schema.columns c ' +\n      'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ' +\n      'cu.column_name, tc.constraint_type ' +\n      'FROM information_schema.TABLE_CONSTRAINTS tc ' +\n      'JOIN information_schema.KEY_COLUMN_USAGE  cu ' +\n      'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ' +\n      'and tc.constraint_name=cu.constraint_name ' +\n      'and tc.constraint_type=\\'PRIMARY KEY\\') pk ' +\n      'ON pk.table_schema=c.table_schema ' +\n      'AND pk.table_name=c.table_name ' +\n      'AND pk.column_name=c.column_name ' +\n      `WHERE c.table_name = ${this.escape(tableName)} AND c.table_schema = ${this.escape(schema)} `;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    // https://www.postgresql.org/docs/current/static/functions-json.html\n    const jsonFunctionRegex = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const jsonOperatorRegex = /^\\s*(->>?|#>>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = jsonOperatorRegex.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition =>\n          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`\n        );\n\n        return conditions.join(' AND ');\n      }\n      if (smth.path) {\n        let str;\n\n        // Allow specifying conditions using the postgres json syntax\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    }\n    return super.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n\n  addColumnQuery(table, key, attribute) {\n    const dbDataType = this.attributeToSQL(attribute, { context: 'addColumn', table, key });\n    const dataType = attribute.type || attribute;\n    const definition = this.dataTypeMapping(table, key, dbDataType);\n    const quotedKey = this.quoteIdentifier(key);\n    const quotedTable = this.quoteTable(this.extractTableDetails(table));\n\n    let query = `ALTER TABLE ${quotedTable} ADD COLUMN ${quotedKey} ${definition};`;\n\n    if (dataType instanceof DataTypes.ENUM) {\n      query = this.pgEnum(table, key, dataType) + query;\n    } else if (dataType.type && dataType.type instanceof DataTypes.ENUM) {\n      query = this.pgEnum(table, key, dataType.type) + query;\n    }\n\n    return query;\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    const quotedTableName = this.quoteTable(this.extractTableDetails(tableName));\n    const quotedAttributeName = this.quoteIdentifier(attributeName);\n    return `ALTER TABLE ${quotedTableName} DROP COLUMN ${quotedAttributeName};`;\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const query = subQuery => `ALTER TABLE ${this.quoteTable(tableName)} ALTER COLUMN ${subQuery};`;\n    const sql = [];\n    for (const attributeName in attributes) {\n      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);\n      let attrSql = '';\n\n      if (definition.includes('NOT NULL')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} SET NOT NULL`);\n\n        definition = definition.replace('NOT NULL', '').trim();\n      } else if (!definition.includes('REFERENCES')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP NOT NULL`);\n      }\n\n      if (definition.includes('DEFAULT')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} SET DEFAULT ${definition.match(/DEFAULT ([^;]+)/)[1]}`);\n\n        definition = definition.replace(/(DEFAULT[^;]+)/, '').trim();\n      } else if (!definition.includes('REFERENCES')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP DEFAULT`);\n      }\n\n      if (attributes[attributeName].startsWith('ENUM(')) {\n        attrSql += this.pgEnum(tableName, attributeName, attributes[attributeName]);\n        definition = definition.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attributeName, { schema: false }));\n        definition += ` USING (${this.quoteIdentifier(attributeName)}::${this.pgEnumName(tableName, attributeName)})`;\n      }\n\n      if (definition.match(/UNIQUE;*$/)) {\n        definition = definition.replace(/UNIQUE;*$/, '');\n        attrSql += query(`ADD UNIQUE (${this.quoteIdentifier(attributeName)})`).replace('ALTER COLUMN', '');\n      }\n\n      if (definition.includes('REFERENCES')) {\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        attrSql += query(`ADD FOREIGN KEY (${this.quoteIdentifier(attributeName)}) ${definition}`).replace('ALTER COLUMN', '');\n      } else {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} TYPE ${definition}`);\n      }\n\n      sql.push(attrSql);\n    }\n\n    return sql.join('');\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n\n    const attrString = [];\n\n    for (const attributeName in attributes) {\n      attrString.push(`${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(attributeName)}`);\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${attrString.join(', ')};`;\n  }\n\n  fn(fnName, tableName, parameters, body, returns, language) {\n    fnName = fnName || 'testfunc';\n    language = language || 'plpgsql';\n    returns = returns ? `RETURNS ${returns}` : '';\n    parameters = parameters || '';\n\n    return `CREATE OR REPLACE FUNCTION pg_temp.${fnName}(${parameters}) ${returns} AS $func$ BEGIN ${body} END; $func$ LANGUAGE ${language}; SELECT * FROM pg_temp.${fnName}();`;\n  }\n\n  truncateTableQuery(tableName, options = {}) {\n    return [\n      `TRUNCATE ${this.quoteTable(tableName)}`,\n      options.restartIdentity ? ' RESTART IDENTITY' : '',\n      options.cascade ? ' CASCADE' : ''\n    ].join('');\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    const limit = options.limit ? ` LIMIT ${this.escape(options.limit)}` : '';\n    let primaryKeys = '';\n    let primaryKeysSelection = '';\n\n    if (whereClause) {\n      whereClause = ` WHERE ${whereClause}`;\n    }\n\n    if (options.limit) {\n      if (!model) {\n        throw new Error('Cannot LIMIT delete without a model.');\n      }\n\n      const pks = Object.values(model.primaryKeys).map(pk => this.quoteIdentifier(pk.field)).join(',');\n\n      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;\n      primaryKeysSelection = pks;\n\n      return `DELETE FROM ${table} WHERE ${primaryKeys} IN (SELECT ${primaryKeysSelection} FROM ${table}${whereClause}${limit})`;\n    }\n    return `DELETE FROM ${table}${whereClause}`;\n  }\n\n  showIndexesQuery(tableName) {\n    let schemaJoin = '';\n    let schemaWhere = '';\n    if (typeof tableName !== 'string') {\n      schemaJoin = ', pg_namespace s';\n      schemaWhere = ` AND s.oid = t.relnamespace AND s.nspname = '${tableName.schema}'`;\n      tableName = tableName.tableName;\n    }\n\n    // This is ARCANE!\n    return 'SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, ' +\n      'array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) ' +\n      `AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a${schemaJoin} ` +\n      'WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND ' +\n      `t.relkind = 'r' and t.relname = '${tableName}'${schemaWhere} ` +\n      'GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;';\n  }\n\n  showConstraintsQuery(tableName) {\n    //Postgres converts camelCased alias to lowercase unless quoted\n    return [\n      'SELECT constraint_catalog AS \"constraintCatalog\",',\n      'constraint_schema AS \"constraintSchema\",',\n      'constraint_name AS \"constraintName\",',\n      'table_catalog AS \"tableCatalog\",',\n      'table_schema AS \"tableSchema\",',\n      'table_name AS \"tableName\",',\n      'constraint_type AS \"constraintType\",',\n      'is_deferrable AS \"isDeferrable\",',\n      'initially_deferred AS \"initiallyDeferred\"',\n      'from INFORMATION_SCHEMA.table_constraints',\n      `WHERE table_name='${tableName}';`\n    ].join(' ');\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifiers(indexName)}`;\n  }\n\n  addLimitAndOffset(options) {\n    let fragment = '';\n    /* eslint-disable */\n    if (options.limit != null) {\n      fragment += ' LIMIT ' + this.escape(options.limit);\n    }\n    if (options.offset != null) {\n      fragment += ' OFFSET ' + this.escape(options.offset);\n    }\n    /* eslint-enable */\n\n    return fragment;\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    let type;\n    if (\n      attribute.type instanceof DataTypes.ENUM ||\n      attribute.type instanceof DataTypes.ARRAY && attribute.type.type instanceof DataTypes.ENUM\n    ) {\n      const enumType = attribute.type.type || attribute.type;\n      let values = attribute.values;\n\n      if (enumType.values && !attribute.values) {\n        values = enumType.values;\n      }\n\n      if (Array.isArray(values) && values.length > 0) {\n        type = `ENUM(${values.map(value => this.escape(value)).join(', ')})`;\n\n        if (attribute.type instanceof DataTypes.ARRAY) {\n          type += '[]';\n        }\n\n      } else {\n        throw new Error(\"Values for ENUM haven't been defined.\");\n      }\n    }\n\n    if (!type) {\n      type = attribute.type;\n    }\n\n    let sql = type.toString();\n\n    if (Object.prototype.hasOwnProperty.call(attribute, 'allowNull') && !attribute.allowNull) {\n      sql += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      if (attribute.autoIncrementIdentity) {\n        sql += ' GENERATED BY DEFAULT AS IDENTITY';\n      } else {\n        sql += ' SERIAL';\n      }\n    }\n\n    if (Utils.defaultValueSchemable(attribute.defaultValue)) {\n      sql += ` DEFAULT ${this.escape(attribute.defaultValue, attribute)}`;\n    }\n\n    if (attribute.unique === true) {\n      sql += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      sql += ' PRIMARY KEY';\n    }\n\n    if (attribute.references) {\n      let referencesTable = this.quoteTable(attribute.references.model);\n      let schema;\n\n      if (options.schema) {\n        schema = options.schema;\n      } else if (\n        (!attribute.references.model || typeof attribute.references.model == 'string')\n        && options.table\n        && options.table.schema\n      ) {\n        schema = options.table.schema;\n      }\n\n      if (schema) {\n        referencesTable = this.quoteTable(this.addSchema({\n          tableName: referencesTable,\n          _schema: schema\n        }));\n      }\n\n      let referencesKey;\n\n      if (attribute.references.key) {\n        referencesKey = this.quoteIdentifiers(attribute.references.key);\n      } else {\n        referencesKey = this.quoteIdentifier('id');\n      }\n\n      sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n      if (attribute.onDelete) {\n        sql += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        sql += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n\n      if (attribute.references.deferrable) {\n        sql += ` ${attribute.references.deferrable.toString(this)}`;\n      }\n    }\n\n    if (attribute.comment && typeof attribute.comment === 'string') {\n      if (options && (options.context === 'addColumn' || options.context === 'changeColumn')) {\n        const quotedAttr = this.quoteIdentifier(options.key);\n        const escapedCommentText = this.escape(attribute.comment);\n        sql += `; COMMENT ON COLUMN ${this.quoteTable(options.table)}.${quotedAttr} IS ${escapedCommentText}`;\n      } else {\n        // for createTable event which does it's own parsing\n        // TODO: centralize creation of comment statements here\n        sql += ` COMMENT ${attribute.comment}`;\n      }\n    }\n\n    return sql;\n  }\n\n  deferConstraintsQuery(options) {\n    return options.deferrable.toString(this);\n  }\n\n  setConstraintQuery(columns, type) {\n    let columnFragment = 'ALL';\n\n    if (columns) {\n      columnFragment = columns.map(column => this.quoteIdentifier(column)).join(', ');\n    }\n\n    return `SET CONSTRAINTS ${columnFragment} ${type}`;\n  }\n\n  setDeferredQuery(columns) {\n    return this.setConstraintQuery(columns, 'DEFERRED');\n  }\n\n  setImmediateQuery(columns) {\n    return this.setConstraintQuery(columns, 'IMMEDIATE');\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, { key, ...options });\n    }\n\n    return result;\n  }\n\n  createTrigger(tableName, triggerName, eventType, fireOnSpec, functionName, functionParams, optionsArray) {\n    const decodedEventType = this.decodeTriggerEventType(eventType);\n    const eventSpec = this.expandTriggerEventSpec(fireOnSpec);\n    const expandedOptions = this.expandOptions(optionsArray);\n    const paramList = this._expandFunctionParamList(functionParams);\n\n    return `CREATE ${this.triggerEventTypeIsConstraint(eventType)}TRIGGER ${this.quoteIdentifier(triggerName)} ${decodedEventType} ${\n      eventSpec} ON ${this.quoteTable(tableName)}${expandedOptions ? ` ${expandedOptions}` : ''} EXECUTE PROCEDURE ${functionName}(${paramList});`;\n  }\n\n  dropTrigger(tableName, triggerName) {\n    return `DROP TRIGGER ${this.quoteIdentifier(triggerName)} ON ${this.quoteTable(tableName)} RESTRICT;`;\n  }\n\n  renameTrigger(tableName, oldTriggerName, newTriggerName) {\n    return `ALTER TRIGGER ${this.quoteIdentifier(oldTriggerName)} ON ${this.quoteTable(tableName)} RENAME TO ${this.quoteIdentifier(newTriggerName)};`;\n  }\n\n  createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    if (!functionName || !returnType || !language || !body) throw new Error('createFunction missing some parameters. Did you pass functionName, returnType, language and body?');\n\n    const paramList = this._expandFunctionParamList(params);\n    const variableList = options && options.variables ? this._expandFunctionVariableList(options.variables) : '';\n    const expandedOptionsArray = this.expandOptions(optionsArray);\n\n    const statement = options && options.force ? 'CREATE OR REPLACE FUNCTION' : 'CREATE FUNCTION';\n\n    return `${statement} ${functionName}(${paramList}) RETURNS ${returnType} AS $func$ ${variableList} BEGIN ${body} END; $func$ language '${language}'${expandedOptionsArray};`;\n  }\n\n  dropFunction(functionName, params) {\n    if (!functionName) throw new Error('requires functionName');\n    // RESTRICT is (currently, as of 9.2) default but we'll be explicit\n    const paramList = this._expandFunctionParamList(params);\n    return `DROP FUNCTION ${functionName}(${paramList}) RESTRICT;`;\n  }\n\n  renameFunction(oldFunctionName, params, newFunctionName) {\n    const paramList = this._expandFunctionParamList(params);\n    return `ALTER FUNCTION ${oldFunctionName}(${paramList}) RENAME TO ${newFunctionName};`;\n  }\n\n  pgEscapeAndQuote(val) {\n    return this.quoteIdentifier(Utils.removeTicks(this.escape(val), \"'\"));\n  }\n\n  _expandFunctionParamList(params) {\n    if (params === undefined || !Array.isArray(params)) {\n      throw new Error('_expandFunctionParamList: function parameters array required, including an empty one for no arguments');\n    }\n\n    const paramList = [];\n    params.forEach(curParam => {\n      const paramDef = [];\n      if (curParam.type) {\n        if (curParam.direction) { paramDef.push(curParam.direction); }\n        if (curParam.name) { paramDef.push(curParam.name); }\n        paramDef.push(curParam.type);\n      } else {\n        throw new Error('function or trigger used with a parameter without any type');\n      }\n\n      const joined = paramDef.join(' ');\n      if (joined) paramList.push(joined);\n\n    });\n\n    return paramList.join(', ');\n  }\n\n  _expandFunctionVariableList(variables) {\n    if (!Array.isArray(variables)) {\n      throw new Error('_expandFunctionVariableList: function variables must be an array');\n    }\n    const variableDefinitions = [];\n    variables.forEach(variable => {\n      if (!variable.name || !variable.type) {\n        throw new Error('function variable must have a name and type');\n      }\n      let variableDefinition = `DECLARE ${variable.name} ${variable.type}`;\n      if (variable.default) {\n        variableDefinition += ` := ${variable.default}`;\n      }\n      variableDefinition += ';';\n      variableDefinitions.push(variableDefinition);\n    });\n    return variableDefinitions.join(' ');\n  }\n\n  expandOptions(options) {\n    return options === undefined || _.isEmpty(options) ?\n      '' : options.join(' ');\n  }\n\n  decodeTriggerEventType(eventSpecifier) {\n    const EVENT_DECODER = {\n      'after': 'AFTER',\n      'before': 'BEFORE',\n      'instead_of': 'INSTEAD OF',\n      'after_constraint': 'AFTER'\n    };\n\n    if (!EVENT_DECODER[eventSpecifier]) {\n      throw new Error(`Invalid trigger event specified: ${eventSpecifier}`);\n    }\n\n    return EVENT_DECODER[eventSpecifier];\n  }\n\n  triggerEventTypeIsConstraint(eventSpecifier) {\n    return eventSpecifier === 'after_constraint' ? 'CONSTRAINT ' : '';\n  }\n\n  expandTriggerEventSpec(fireOnSpec) {\n    if (_.isEmpty(fireOnSpec)) {\n      throw new Error('no table change events specified to trigger on');\n    }\n\n    return _.map(fireOnSpec, (fireValue, fireKey) => {\n      const EVENT_MAP = {\n        'insert': 'INSERT',\n        'update': 'UPDATE',\n        'delete': 'DELETE',\n        'truncate': 'TRUNCATE'\n      };\n\n      if (!EVENT_MAP[fireValue]) {\n        throw new Error(`parseTriggerEventSpec: undefined trigger event ${fireKey}`);\n      }\n\n      let eventSpec = EVENT_MAP[fireValue];\n      if (eventSpec === 'UPDATE') {\n        if (Array.isArray(fireValue) && fireValue.length > 0) {\n          eventSpec += ` OF ${fireValue.join(', ')}`;\n        }\n      }\n\n      return eventSpec;\n    }).join(' OR ');\n  }\n\n  pgEnumName(tableName, attr, options) {\n    options = options || {};\n\n    const tableDetails = this.extractTableDetails(tableName, options);\n    let enumName = Utils.addTicks(Utils.generateEnumName(tableDetails.tableName, attr), '\"');\n\n    // pgListEnums requires the enum name only, without the schema\n    if (options.schema !== false && tableDetails.schema) {\n      enumName = this.quoteIdentifier(tableDetails.schema) + tableDetails.delimiter + enumName;\n    }\n\n    return enumName;\n  }\n\n  pgListEnums(tableName, attrName, options) {\n    let enumName = '';\n    const tableDetails = this.extractTableDetails(tableName, options);\n\n    if (tableDetails.tableName && attrName) {\n      enumName = ` AND t.typname=${this.pgEnumName(tableDetails.tableName, attrName, { schema: false }).replace(/\"/g, \"'\")}`;\n    }\n\n    return 'SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t ' +\n      'JOIN pg_enum e ON t.oid = e.enumtypid ' +\n      'JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace ' +\n      `WHERE n.nspname = '${tableDetails.schema}'${enumName} GROUP BY 1`;\n  }\n\n  pgEnum(tableName, attr, dataType, options) {\n    const enumName = this.pgEnumName(tableName, attr, options);\n    let values;\n\n    if (dataType.values) {\n      values = `ENUM(${dataType.values.map(value => this.escape(value)).join(', ')})`;\n    } else {\n      values = dataType.toString().match(/^ENUM\\(.+\\)/)[0];\n    }\n\n    let sql = `CREATE TYPE ${enumName} AS ${values};`;\n    if (!!options && options.force === true) {\n      sql = this.pgEnumDrop(tableName, attr) + sql;\n    }\n    return sql;\n  }\n\n  pgEnumAdd(tableName, attr, value, options) {\n    const enumName = this.pgEnumName(tableName, attr);\n    let sql = `ALTER TYPE ${enumName} ADD VALUE `;\n\n    if (semver.gte(this.sequelize.options.databaseVersion, '9.3.0')) {\n      sql += 'IF NOT EXISTS ';\n    }\n    sql += this.escape(value);\n\n    if (options.before) {\n      sql += ` BEFORE ${this.escape(options.before)}`;\n    } else if (options.after) {\n      sql += ` AFTER ${this.escape(options.after)}`;\n    }\n\n    return sql;\n  }\n\n  pgEnumDrop(tableName, attr, enumName) {\n    enumName = enumName || this.pgEnumName(tableName, attr);\n    return `DROP TYPE IF EXISTS ${enumName}; `;\n  }\n\n  fromArray(text) {\n    text = text.replace(/^{/, '').replace(/}$/, '');\n    let matches = text.match(/(\"(?:\\\\.|[^\"\\\\\\\\])*\"|[^,]*)(?:\\s*,\\s*|\\s*$)/ig);\n\n    if (matches.length < 1) {\n      return [];\n    }\n\n    matches = matches.map(m => m.replace(/\",$/, '').replace(/,$/, '').replace(/(^\"|\"$)/g, ''));\n\n    return matches.slice(0, -1);\n  }\n\n  dataTypeMapping(tableName, attr, dataType) {\n    if (dataType.includes('PRIMARY KEY')) {\n      dataType = dataType.replace('PRIMARY KEY', '');\n    }\n\n    if (dataType.includes('SERIAL')) {\n      if (dataType.includes('BIGINT')) {\n        dataType = dataType.replace('SERIAL', 'BIGSERIAL');\n        dataType = dataType.replace('BIGINT', '');\n      } else if (dataType.includes('SMALLINT')) {\n        dataType = dataType.replace('SERIAL', 'SMALLSERIAL');\n        dataType = dataType.replace('SMALLINT', '');\n      } else {\n        dataType = dataType.replace('INTEGER', '');\n      }\n      dataType = dataType.replace('NOT NULL', '');\n    }\n\n    if (dataType.startsWith('ENUM(')) {\n      dataType = dataType.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attr));\n    }\n\n    return dataType;\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(tableName) {\n    return 'SELECT conname as constraint_name, pg_catalog.pg_get_constraintdef(r.oid, true) as condef FROM pg_catalog.pg_constraint r ' +\n      `WHERE r.conrelid = (SELECT oid FROM pg_class WHERE relname = '${tableName}' LIMIT 1) AND r.contype = 'f' ORDER BY 1;`;\n  }\n\n  /**\n   * Generate common SQL prefix for getForeignKeyReferencesQuery.\n   *\n   * @returns {string}\n   */\n  _getForeignKeyReferencesQueryPrefix() {\n    return 'SELECT ' +\n      'DISTINCT tc.constraint_name as constraint_name, ' +\n      'tc.constraint_schema as constraint_schema, ' +\n      'tc.constraint_catalog as constraint_catalog, ' +\n      'tc.table_name as table_name,' +\n      'tc.table_schema as table_schema,' +\n      'tc.table_catalog as table_catalog,' +\n      'kcu.column_name as column_name,' +\n      'ccu.table_schema  AS referenced_table_schema,' +\n      'ccu.table_catalog  AS referenced_table_catalog,' +\n      'ccu.table_name  AS referenced_table_name,' +\n      'ccu.column_name AS referenced_column_name ' +\n      'FROM information_schema.table_constraints AS tc ' +\n      'JOIN information_schema.key_column_usage AS kcu ' +\n      'ON tc.constraint_name = kcu.constraint_name ' +\n      'JOIN information_schema.constraint_column_usage AS ccu ' +\n      'ON ccu.constraint_name = tc.constraint_name ';\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys details of a table.\n   *\n   * As for getForeignKeysQuery is not compatible with getForeignKeyReferencesQuery, so add a new function.\n   *\n   * @param {string} tableName\n   * @param {string} catalogName\n   * @param {string} schemaName\n   */\n  getForeignKeyReferencesQuery(tableName, catalogName, schemaName) {\n    return `${this._getForeignKeyReferencesQueryPrefix()\n    }WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = '${tableName}'${\n      catalogName ? ` AND tc.table_catalog = '${catalogName}'` : ''\n    }${schemaName ? ` AND tc.table_schema = '${schemaName}'` : ''}`;\n  }\n\n  getForeignKeyReferenceQuery(table, columnName) {\n    const tableName = table.tableName || table;\n    const schema = table.schema;\n    return `${this._getForeignKeyReferencesQueryPrefix()\n    }WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name='${tableName}' AND  kcu.column_name = '${columnName}'${\n      schema ? ` AND tc.table_schema = '${schema}'` : ''}`;\n  }\n\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @param  {string} foreignKey The name of the foreign key constraint.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${this.quoteIdentifier(foreignKey)};`;\n  }\n}\n\nmodule.exports = PostgresQueryGenerator;\n"]},"metadata":{},"sourceType":"script"}