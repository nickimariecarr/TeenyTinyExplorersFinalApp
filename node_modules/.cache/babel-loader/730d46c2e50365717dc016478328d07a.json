{"ast":null,"code":"\"use strict\";\n\nvar o = Object.defineProperty;\n\nvar s = (e, r) => o(e, \"name\", {\n  value: r,\n  configurable: !0\n});\n\nclass t extends Error {\n  constructor(r) {\n    super(r);\n    this.name = \"SequelizeBaseError\";\n  }\n\n}\n\ns(t, \"BaseError\"), module.exports = t;","map":{"version":3,"sources":["../../../lib/errors/base-error.js"],"names":[],"mappings":";;;;;;;;;AASA,MAAA,CAAA,SAAwB,KAAxB,CAA8B;AAC5B,EAAA,WAAA,CAAY,CAAZ,EAAqB;AACnB,UAAM,CAAN;AACA,SAAK,IAAL,GAAY,oBAAZ;AAAY;;AAHc;;AAA9B,CAAA,CAAA,CAAA,EAAA,WAAA,CAAA,EAOA,MAAA,CAAO,OAAP,GAAiB,CAPjB","sourcesContent":["'use strict';\n\n/**\n * Sequelize provides a host of custom error classes, to allow you to do easier debugging. All of these errors are exposed on the sequelize object and the sequelize constructor.\n * All sequelize errors inherit from the base JS error object.\n *\n * This means that errors can be accessed using `Sequelize.ValidationError`\n * The Base Error all Sequelize Errors inherit from.\n */\nclass BaseError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'SequelizeBaseError';\n  }\n}\n\nmodule.exports = BaseError;\n"]},"metadata":{},"sourceType":"script"}