{"ast":null,"code":"\"use strict\";\n\nvar z = Object.defineProperty,\n    W = Object.defineProperties;\nvar H = Object.getOwnPropertyDescriptors;\nvar K = Object.getOwnPropertySymbols;\nvar Y = Object.prototype.hasOwnProperty,\n    X = Object.prototype.propertyIsEnumerable;\n\nvar V = (w, e, t) => e in w ? z(w, e, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: t\n}) : w[e] = t,\n    N = (w, e) => {\n  for (var t in e || (e = {})) Y.call(e, t) && V(w, t, e[t]);\n\n  if (K) for (var t of K(e)) X.call(e, t) && V(w, t, e[t]);\n  return w;\n},\n    M = (w, e) => W(w, H(e));\n\nvar L = (w, e) => z(w, \"name\", {\n  value: e,\n  configurable: !0\n});\n\nconst x = require(\"util\"),\n      $ = require(\"lodash\"),\n      Z = require(\"uuid\").v4,\n      d = require(\"../../utils\"),\n      k = require(\"../../utils/deprecations\"),\n      J = require(\"../../sql-string\"),\n      C = require(\"../../data-types\"),\n      j = require(\"../../model\"),\n      F = require(\"../../associations/base\"),\n      P = require(\"../../associations/belongs-to\"),\n      v = require(\"../../associations/belongs-to-many\"),\n      ee = require(\"../../associations/has-many\"),\n      c = require(\"../../operators\"),\n      U = require(\"../../errors\"),\n      B = require(\"../../index-hints\"),\n      G = require(\"./query-generator/helpers/quote\");\n\nclass R {\n  constructor(e) {\n    if (!e.sequelize) throw new Error(\"QueryGenerator initialized without options.sequelize\");\n    if (!e._dialect) throw new Error(\"QueryGenerator initialized without options._dialect\");\n    this.sequelize = e.sequelize, this.options = e.sequelize.options, this.dialect = e._dialect.name, this._dialect = e._dialect;\n  }\n\n  extractTableDetails(e, t) {\n    return t = t || {}, e = e || {}, {\n      schema: e.schema || t.schema || \"public\",\n      tableName: $.isPlainObject(e) ? e.tableName : e,\n      delimiter: e.delimiter || t.delimiter || \".\"\n    };\n  }\n\n  addSchema(e) {\n    if (!e._schema) return e.tableName || e;\n    const t = this;\n    return {\n      tableName: e.tableName || e,\n      table: e.tableName || e,\n      name: e.name || e,\n      schema: e._schema,\n      delimiter: e._schemaDelimiter || \".\",\n\n      toString() {\n        return t.quoteTable(this);\n      }\n\n    };\n  }\n\n  dropSchema(e, t) {\n    return this.dropTableQuery(e, t);\n  }\n\n  describeTableQuery(e, t, i) {\n    return `DESCRIBE ${this.quoteTable(this.addSchema({\n      tableName: e,\n      _schema: t,\n      _schemaDelimiter: i\n    }))};`;\n  }\n\n  dropTableQuery(e) {\n    return `DROP TABLE IF EXISTS ${this.quoteTable(e)};`;\n  }\n\n  renameTableQuery(e, t) {\n    return `ALTER TABLE ${this.quoteTable(e)} RENAME TO ${this.quoteTable(t)};`;\n  }\n\n  insertQuery(e, t, i, r) {\n    r = r || {}, $.defaults(r, this.options);\n    const n = {},\n          a = [],\n          u = [],\n          s = [],\n          l = [],\n          o = this.quoteTable(e),\n          g = r.bindParam === void 0 ? this.bindParam(a) : r.bindParam;\n    let f,\n        m = \"\",\n        y = \"\",\n        h = \"\",\n        p = \"\",\n        A = !1,\n        I = \"\";\n\n    if (i && $.each(i, (q, b) => {\n      n[b] = q, q.field && (n[q.field] = q);\n    }), this._dialect.supports[\"DEFAULT VALUES\"] ? y += \" DEFAULT VALUES\" : this._dialect.supports[\"VALUES ()\"] && (y += \" VALUES ()\"), this._dialect.supports.returnValues && r.returning) {\n      const q = this.generateReturnValues(i, r);\n      s.push(...q.returnFields), p = q.returningFragment, I = q.tmpTable || \"\", h = q.outputFragment || \"\";\n    }\n\n    ($.get(this, [\"sequelize\", \"options\", \"dialectOptions\", \"prependSearchPath\"]) || r.searchPath) && (r.bindParam = !1), this._dialect.supports.EXCEPTION && r.exception && (r.bindParam = !1), t = d.removeNullValuesFromHash(t, this.options.omitNull);\n\n    for (const q in t) if (Object.prototype.hasOwnProperty.call(t, q)) {\n      const b = t[q];\n      u.push(this.quoteIdentifier(q)), n && n[q] && n[q].autoIncrement === !0 && b == null ? this._dialect.supports.autoIncrement.defaultValue ? this._dialect.supports.DEFAULT ? l.push(\"DEFAULT\") : l.push(this.escape(null)) : u.splice(-1, 1) : (n && n[q] && n[q].autoIncrement === !0 && (A = !0), b instanceof d.SequelizeMethod || r.bindParam === !1 ? l.push(this.escape(b, n && n[q] || void 0, {\n        context: \"INSERT\"\n      })) : l.push(this.format(b, n && n[q] || void 0, {\n        context: \"INSERT\"\n      }, g)));\n    }\n\n    let E = \"\";\n    if (this._dialect.supports.inserts.updateOnDuplicate && r.updateOnDuplicate) if (this._dialect.supports.inserts.updateOnDuplicate == \" ON CONFLICT DO UPDATE SET\") {\n      const q = r.upsertKeys.map(O => this.quoteIdentifier(O)),\n            b = r.updateOnDuplicate.map(O => `${this.quoteIdentifier(O)}=EXCLUDED.${this.quoteIdentifier(O)}`);\n      E = ` ON CONFLICT (${q.join(\",\")}) DO UPDATE SET ${b.join(\",\")}`;\n    } else {\n      const q = r.updateOnDuplicate.map(b => `${this.quoteIdentifier(b)}=VALUES(${this.quoteIdentifier(b)})`);\n      E += `${this._dialect.supports.inserts.updateOnDuplicate} ${q.join(\",\")}`;\n    }\n    const S = {\n      ignoreDuplicates: r.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : \"\",\n      onConflictDoNothing: r.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : \"\",\n      attributes: u.join(\",\"),\n      output: h,\n      values: l.join(\",\"),\n      tmpTable: I\n    };\n\n    if (m = `${I}INSERT${S.ignoreDuplicates} INTO ${o} (${S.attributes})${S.output} VALUES (${S.values})${E}${S.onConflictDoNothing}${m}`, y = `${I}INSERT${S.ignoreDuplicates} INTO ${o}${S.output}${E}${S.onConflictDoNothing}${y}`, this._dialect.supports.EXCEPTION && r.exception) {\n      const q = \"DROP FUNCTION IF EXISTS pg_temp.testfunc()\";\n      s.length === 0 && s.push(\"*\");\n      const b = `$func_${Z().replace(/-/g, \"\")}$`,\n            O = `SELECT (testfunc.response).${s.join(\", (testfunc.response).\")}, testfunc.sequelize_caught_exception FROM pg_temp.testfunc();`;\n      r.exception = \"WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL;\", m = `CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response ${o}, OUT sequelize_caught_exception text) RETURNS RECORD AS ${b} BEGIN ${m} RETURNING * INTO response; EXCEPTION ${r.exception} END ${b} LANGUAGE plpgsql; ${O} ${q}`;\n    } else m += p, y += p;\n\n    f = `${S.attributes.length ? m : y};`, A && this._dialect.supports.autoIncrement.identityInsert && (f = `SET IDENTITY_INSERT ${o} ON; ${f} SET IDENTITY_INSERT ${o} OFF;`);\n    const _ = {\n      query: f\n    };\n    return r.bindParam !== !1 && (_.bind = a), _;\n  }\n\n  bulkInsertQuery(e, t, i, r) {\n    i = i || {}, r = r || {};\n    const n = [],\n          a = {},\n          u = [];\n    let s = \"\";\n\n    for (const m of t) $.forOwn(m, (y, h) => {\n      u.includes(h) || u.push(h), r[h] && r[h].autoIncrement === !0 && (a[h] = !0);\n    });\n\n    for (const m of t) {\n      const y = u.map(h => this._dialect.supports.bulkDefault && a[h] === !0 ? m[h] != null ? m[h] : \"DEFAULT\" : this.escape(m[h], r[h], {\n        context: \"INSERT\"\n      }));\n      n.push(`(${y.join(\",\")})`);\n    }\n\n    if (this._dialect.supports.inserts.updateOnDuplicate && i.updateOnDuplicate) if (this._dialect.supports.inserts.updateOnDuplicate == \" ON CONFLICT DO UPDATE SET\") {\n      const m = i.upsertKeys.map(h => this.quoteIdentifier(h)),\n            y = i.updateOnDuplicate.map(h => `${this.quoteIdentifier(h)}=EXCLUDED.${this.quoteIdentifier(h)}`);\n      s = ` ON CONFLICT (${m.join(\",\")}) DO UPDATE SET ${y.join(\",\")}`;\n    } else {\n      const m = i.updateOnDuplicate.map(y => `${this.quoteIdentifier(y)}=VALUES(${this.quoteIdentifier(y)})`);\n      s = `${this._dialect.supports.inserts.updateOnDuplicate} ${m.join(\",\")}`;\n    }\n    const l = i.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : \"\",\n          o = u.map(m => this.quoteIdentifier(m)).join(\",\"),\n          g = i.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : \"\";\n    let f = \"\";\n    return this._dialect.supports.returnValues && i.returning && (f += this.generateReturnValues(r, i).returningFragment), d.joinSQLFragments([\"INSERT\", l, \"INTO\", this.quoteTable(e), `(${o})`, \"VALUES\", n.join(\",\"), s, g, f, \";\"]);\n  }\n\n  updateQuery(e, t, i, r, n) {\n    r = r || {}, $.defaults(r, this.options), t = d.removeNullValuesFromHash(t, r.omitNull, r);\n    const a = [],\n          u = [],\n          s = {};\n    let l = \"\",\n        o = \"\",\n        g = \"\";\n    ($.get(this, [\"sequelize\", \"options\", \"dialectOptions\", \"prependSearchPath\"]) || r.searchPath) && (r.bindParam = !1);\n    const f = r.bindParam === void 0 ? this.bindParam(u) : r.bindParam;\n\n    if (this._dialect.supports[\"LIMIT ON UPDATE\"] && r.limit && this.dialect !== \"mssql\" && (g = ` LIMIT ${this.escape(r.limit)} `), this._dialect.supports.returnValues && r.returning) {\n      const p = this.generateReturnValues(n, r);\n      g += p.returningFragment, o = p.tmpTable || \"\", l = p.outputFragment || \"\", !this._dialect.supports.returnValues.output && r.returning && (r.mapToModel = !0);\n    }\n\n    n && $.each(n, (p, A) => {\n      s[A] = p, p.field && (s[p.field] = p);\n    });\n\n    for (const p in t) {\n      if (s && s[p] && s[p].autoIncrement === !0 && !this._dialect.supports.autoIncrement.update) continue;\n      const A = t[p];\n      A instanceof d.SequelizeMethod || r.bindParam === !1 ? a.push(`${this.quoteIdentifier(p)}=${this.escape(A, s && s[p] || void 0, {\n        context: \"UPDATE\"\n      })}`) : a.push(`${this.quoteIdentifier(p)}=${this.format(A, s && s[p] || void 0, {\n        context: \"UPDATE\"\n      }, f)}`);\n    }\n\n    const m = M(N({}, r), {\n      bindParam: f\n    });\n    if (a.length === 0) return \"\";\n    const h = {\n      query: `${o}UPDATE ${this.quoteTable(e)} SET ${a.join(\",\")}${l} ${this.whereQuery(i, m)}${g}`.trim()\n    };\n    return r.bindParam !== !1 && (h.bind = u), h;\n  }\n\n  arithmeticQuery(e, t, i, r, n, a) {\n    a = a || {}, $.defaults(a, {\n      returning: !0\n    }), n = d.removeNullValuesFromHash(n, this.options.omitNull);\n    let u = \"\",\n        s = \"\";\n\n    if (this._dialect.supports.returnValues && a.returning) {\n      const o = this.generateReturnValues(null, a);\n      u = o.outputFragment, s = o.returningFragment;\n    }\n\n    const l = [];\n\n    for (const o in r) {\n      const g = r[o],\n            f = this.quoteIdentifier(o),\n            m = this.escape(g);\n      l.push(`${f}=${f}${e} ${m}`);\n    }\n\n    for (const o in n) {\n      const g = n[o],\n            f = this.quoteIdentifier(o),\n            m = this.escape(g);\n      l.push(`${f}=${m}`);\n    }\n\n    return d.joinSQLFragments([\"UPDATE\", this.quoteTable(t), \"SET\", l.join(\",\"), u, this.whereQuery(i), s]);\n  }\n\n  addIndexQuery(e, t, i, r) {\n    i = i || {}, Array.isArray(t) ? i.fields = t : (i = t, t = void 0), i.prefix = i.prefix || r || e, i.prefix && typeof i.prefix == \"string\" && (i.prefix = i.prefix.replace(/\\./g, \"_\"), i.prefix = i.prefix.replace(/(\"|')/g, \"\"));\n    const n = i.fields.map(s => {\n      if (s instanceof d.SequelizeMethod) return this.handleSequelizeMethod(s);\n      typeof s == \"string\" && (s = {\n        name: s\n      });\n      let l = \"\";\n      if (s.attribute && (s.name = s.attribute), !s.name) throw new Error(`The following index field has no name: ${x.inspect(s)}`);\n\n      if (l += this.quoteIdentifier(s.name), this._dialect.supports.index.collate && s.collate && (l += ` COLLATE ${this.quoteIdentifier(s.collate)}`), this._dialect.supports.index.operator) {\n        const o = s.operator || i.operator;\n        o && (l += ` ${o}`);\n      }\n\n      return this._dialect.supports.index.length && s.length && (l += `(${s.length})`), s.order && (l += ` ${s.order}`), l;\n    });\n    i.name || (i = d.nameIndex(i, i.prefix)), i = j._conformIndex(i), this._dialect.supports.index.type || delete i.type, i.where && (i.where = this.whereQuery(i.where)), typeof e == \"string\" ? e = this.quoteIdentifiers(e) : e = this.quoteTable(e);\n    const a = this._dialect.supports.index.concurrently && i.concurrently ? \"CONCURRENTLY\" : void 0;\n    let u;\n    return this._dialect.supports.indexViaAlter ? u = [\"ALTER TABLE\", e, a, \"ADD\"] : u = [\"CREATE\"], u = u.concat(i.unique ? \"UNIQUE\" : \"\", i.type, \"INDEX\", this._dialect.supports.indexViaAlter ? void 0 : a, this.quoteIdentifiers(i.name), this._dialect.supports.index.using === 1 && i.using ? `USING ${i.using}` : \"\", this._dialect.supports.indexViaAlter ? void 0 : `ON ${e}`, this._dialect.supports.index.using === 2 && i.using ? `USING ${i.using}` : \"\", `(${n.join(\", \")})`, this._dialect.supports.index.parser && i.parser ? `WITH PARSER ${i.parser}` : void 0, this._dialect.supports.index.where && i.where ? i.where : void 0), $.compact(u).join(\" \");\n  }\n\n  addConstraintQuery(e, t) {\n    return typeof e == \"string\" ? e = this.quoteIdentifiers(e) : e = this.quoteTable(e), d.joinSQLFragments([\"ALTER TABLE\", e, \"ADD\", this.getConstraintSnippet(e, t || {}), \";\"]);\n  }\n\n  getConstraintSnippet(e, t) {\n    let i, r;\n    const n = t.fields.map(s => {\n      if (typeof s == \"string\") return this.quoteIdentifier(s);\n      if (s instanceof d.SequelizeMethod) return this.handleSequelizeMethod(s);\n      if (s.attribute && (s.name = s.attribute), !s.name) throw new Error(`The following index field has no name: ${s}`);\n      return this.quoteIdentifier(s.name);\n    }),\n          a = n.join(\", \"),\n          u = n.join(\"_\");\n\n    switch (t.type.toUpperCase()) {\n      case \"UNIQUE\":\n        r = this.quoteIdentifier(t.name || `${e}_${u}_uk`), i = `CONSTRAINT ${r} UNIQUE (${a})`;\n        break;\n\n      case \"CHECK\":\n        t.where = this.whereItemsQuery(t.where), r = this.quoteIdentifier(t.name || `${e}_${u}_ck`), i = `CONSTRAINT ${r} CHECK (${t.where})`;\n        break;\n\n      case \"DEFAULT\":\n        if (t.defaultValue === void 0) throw new Error(\"Default value must be specifed for DEFAULT CONSTRAINT\");\n        if (this._dialect.name !== \"mssql\") throw new Error(\"Default constraints are supported only for MSSQL dialect.\");\n        r = this.quoteIdentifier(t.name || `${e}_${u}_df`), i = `CONSTRAINT ${r} DEFAULT (${this.escape(t.defaultValue)}) FOR ${n[0]}`;\n        break;\n\n      case \"PRIMARY KEY\":\n        r = this.quoteIdentifier(t.name || `${e}_${u}_pk`), i = `CONSTRAINT ${r} PRIMARY KEY (${a})`;\n        break;\n\n      case \"FOREIGN KEY\":\n        const s = t.references;\n        if (!s || !s.table || !(s.field || s.fields)) throw new Error(\"references object with table and field must be specified\");\n        r = this.quoteIdentifier(t.name || `${e}_${u}_${s.table}_fk`);\n        const l = typeof s.field != \"undefined\" ? this.quoteIdentifier(s.field) : s.fields.map(g => this.quoteIdentifier(g)).join(\", \"),\n              o = `${this.quoteTable(s.table)} (${l})`;\n        i = `CONSTRAINT ${r} `, i += `FOREIGN KEY (${a}) REFERENCES ${o}`, t.onUpdate && (i += ` ON UPDATE ${t.onUpdate.toUpperCase()}`), t.onDelete && (i += ` ON DELETE ${t.onDelete.toUpperCase()}`);\n        break;\n\n      default:\n        throw new Error(`${t.type} is invalid.`);\n    }\n\n    return t.deferrable && [\"UNIQUE\", \"PRIMARY KEY\", \"FOREIGN KEY\"].includes(t.type.toUpperCase()) && (i += ` ${this.deferConstraintsQuery(t)}`), i;\n  }\n\n  removeConstraintQuery(e, t) {\n    return typeof e == \"string\" ? e = this.quoteIdentifiers(e) : e = this.quoteTable(e), d.joinSQLFragments([\"ALTER TABLE\", e, \"DROP CONSTRAINT\", this.quoteIdentifiers(t)]);\n  }\n\n  quote(e, t, i) {\n    const r = [\"ASC\", \"DESC\", \"ASC NULLS LAST\", \"DESC NULLS LAST\", \"ASC NULLS FIRST\", \"DESC NULLS FIRST\", \"NULLS FIRST\", \"NULLS LAST\"];\n    if (i = i || \".\", typeof e == \"string\") return this.quoteIdentifiers(e);\n\n    if (Array.isArray(e)) {\n      e.forEach((o, g) => {\n        const f = e[g - 1];\n        let m, y;\n\n        if (!f && t !== void 0 ? y = t : f && f instanceof F && (m = f, y = f.target), y && y.prototype instanceof j) {\n          let h, p;\n          if (typeof o == \"function\" && o.prototype instanceof j ? h = o : $.isPlainObject(o) && o.model && o.model.prototype instanceof j && (h = o.model, p = o.as), h && (!p && m && m instanceof F && m.through && m.through.model === h ? o = new F(y, h, {\n            as: h.name\n          }) : (o = y.getAssociationForAlias(h, p), o || (o = y.getAssociationForAlias(h, h.name))), !(o instanceof F))) throw new Error(x.format(\"Unable to find a valid association for model, '%s'\", h.name));\n        }\n\n        if (typeof o == \"string\") {\n          const h = r.indexOf(o.toUpperCase());\n          if (g > 0 && h !== -1) o = this.sequelize.literal(` ${r[h]}`);else if (y && y.prototype instanceof j) {\n            if (y.associations !== void 0 && y.associations[o]) o = y.associations[o];else if (y.rawAttributes !== void 0 && y.rawAttributes[o] && o !== y.rawAttributes[o].field) o = y.rawAttributes[o].field;else if (o.includes(\".\") && y.rawAttributes !== void 0) {\n              const p = o.split(\".\");\n\n              if (y.rawAttributes[p[0]].type instanceof C.JSON) {\n                const A = this.quoteIdentifiers(`${y.name}.${y.rawAttributes[p[0]].field}`),\n                      I = p.slice(1);\n                o = this.jsonPathExtractionQuery(A, I), o = this.sequelize.literal(o);\n              }\n            }\n          }\n        }\n\n        e[g] = o;\n      }, this);\n      const n = e.length,\n            a = [];\n      let u,\n          s = 0;\n\n      for (s = 0; s < n - 1 && (u = e[s], !(typeof u == \"string\" || u._modelAttribute || u instanceof d.SequelizeMethod)); s++) u instanceof F && (a[s] = u.as);\n\n      let l = \"\";\n      return s > 0 ? l += `${this.quoteIdentifier(a.join(i))}.` : typeof e[0] == \"string\" && t && (l += `${this.quoteIdentifier(t.name)}.`), e.slice(s).forEach(o => {\n        l += this.quote(o, t, i);\n      }, this), l;\n    }\n\n    if (e._modelAttribute) return `${this.quoteTable(e.Model.name)}.${this.quoteIdentifier(e.fieldName)}`;\n    if (e instanceof d.SequelizeMethod) return this.handleSequelizeMethod(e);\n    throw $.isPlainObject(e) && e.raw ? new Error('The `{raw: \"...\"}` syntax is no longer supported.  Use `sequelize.literal` instead.') : new Error(`Unknown structure passed to order / group: ${x.inspect(e)}`);\n  }\n\n  quoteIdentifier(e, t) {\n    return G.quoteIdentifier(this.dialect, e, {\n      force: t,\n      quoteIdentifiers: this.options.quoteIdentifiers\n    });\n  }\n\n  quoteIdentifiers(e) {\n    if (e.includes(\".\")) {\n      e = e.split(\".\");\n      const t = e.slice(0, e.length - 1).join(\"->\"),\n            i = e[e.length - 1];\n      return `${this.quoteIdentifier(t)}.${this.quoteIdentifier(i)}`;\n    }\n\n    return this.quoteIdentifier(e);\n  }\n\n  quoteAttribute(e, t) {\n    return t && e in t.rawAttributes ? this.quoteIdentifier(e) : this.quoteIdentifiers(e);\n  }\n\n  quoteTable(e, t) {\n    let i = \"\";\n    return t === !0 && (t = e.as || e.name || e), $.isObject(e) ? this._dialect.supports.schemas ? (e.schema && (i += `${this.quoteIdentifier(e.schema)}.`), i += this.quoteIdentifier(e.tableName)) : (e.schema && (i += e.schema + (e.delimiter || \".\")), i += e.tableName, i = this.quoteIdentifier(i)) : i = this.quoteIdentifier(e), t && (i += ` AS ${this.quoteIdentifier(t)}`), i;\n  }\n\n  escape(e, t, i) {\n    if (i = i || {}, e != null) {\n      if (e instanceof d.SequelizeMethod) return this.handleSequelizeMethod(e);\n\n      if (t && t.type && (this.validate(e, t, i), t.type.stringify)) {\n        const r = L(n => J.escape(n, this.options.timezone, this.dialect), \"simpleEscape\");\n        if (e = t.type.stringify(e, {\n          escape: r,\n          field: t,\n          timezone: this.options.timezone,\n          operation: i.operation\n        }), t.type.escape === !1) return e;\n      }\n    }\n\n    return J.escape(e, this.options.timezone, this.dialect);\n  }\n\n  bindParam(e) {\n    return t => (e.push(t), `$${e.length}`);\n  }\n\n  format(e, t, i, r) {\n    if (i = i || {}, e != null) {\n      if (e instanceof d.SequelizeMethod) throw new Error(\"Cannot pass SequelizeMethod as a bind parameter - use escape instead\");\n      if (t && t.type && (this.validate(e, t, i), t.type.bindParam)) return t.type.bindParam(e, {\n        escape: $.identity,\n        field: t,\n        timezone: this.options.timezone,\n        operation: i.operation,\n        bindParam: r\n      });\n    }\n\n    return r(e);\n  }\n\n  validate(e, t, i) {\n    if (this.typeValidation && t.type.validate && e) try {\n      if (i.isList && Array.isArray(e)) for (const r of e) t.type.validate(r, i);else t.type.validate(e, i);\n    } catch (r) {\n      throw r instanceof U.ValidationError && r.errors.push(new U.ValidationErrorItem(r.message, \"Validation error\", t.fieldName, e, null, `${t.type.key} validator`)), r;\n    }\n  }\n\n  isIdentifierQuoted(e) {\n    return G.isIdentifierQuoted(e);\n  }\n\n  jsonPathExtractionQuery(e, t) {\n    let i = $.toPath(t),\n        r;\n    const n = this.isIdentifierQuoted(e) ? e : this.quoteIdentifier(e);\n\n    switch (this.dialect) {\n      case \"mysql\":\n      case \"mariadb\":\n      case \"sqlite\":\n        return this.dialect === \"mysql\" && (i = i.map(a => /\\D/.test(a) ? d.addTicks(a, '\"') : a)), r = this.escape([\"$\"].concat(i).join(\".\").replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (a, u) => `[${u}]`)), this.dialect === \"sqlite\" ? `json_extract(${n},${r})` : `json_unquote(json_extract(${n},${r}))`;\n\n      case \"postgres\":\n        return r = this.escape(`{${i.join(\",\")}}`), `(${n}#>>${r})`;\n\n      default:\n        throw new Error(`Unsupported ${this.dialect} for JSON operations`);\n    }\n  }\n\n  selectQuery(e, t, i) {\n    t = t || {};\n    const r = t.limit,\n          n = [],\n          a = [],\n          u = t.subQuery === void 0 ? r && t.hasMultiAssociation : t.subQuery,\n          s = {\n      main: t.attributes && t.attributes.slice(),\n      subQuery: null\n    },\n          l = {\n      name: e,\n      quotedName: null,\n      as: null,\n      model: i\n    },\n          o = {\n      names: l,\n      options: t,\n      subQuery: u\n    };\n    let g = [],\n        f = [],\n        m;\n    if (this.options.minifyAliases && !t.aliasesMapping && (t.aliasesMapping = new Map(), t.aliasesByTable = {}, t.includeAliases = new Map()), t.tableAs ? l.as = this.quoteIdentifier(t.tableAs) : !Array.isArray(l.name) && l.model && (l.as = this.quoteIdentifier(l.model.name)), l.quotedName = Array.isArray(l.name) ? e.map(h => Array.isArray(h) ? this.quoteTable(h[0], h[1]) : this.quoteTable(h, !0)).join(\", \") : this.quoteTable(l.name), u && s.main) for (const h of l.model.primaryKeyAttributes) s.main.some(p => h === p || h === p[0] || h === p[1]) || s.main.push(l.model.rawAttributes[h].field ? [h, l.model.rawAttributes[h].field] : h);\n    if (s.main = this.escapeAttributes(s.main, t, l.as), s.main = s.main || (t.include ? [`${l.as}.*`] : [\"*\"]), (u || t.groupedLimit) && (s.subQuery = s.main, s.main = [`${l.as || l.quotedName}.*`]), t.include) for (const h of t.include) {\n      if (h.separate) continue;\n      const p = this.generateInclude(h, {\n        externalAs: l.as,\n        internalAs: l.as\n      }, o);\n      f = f.concat(p.subQuery), g = g.concat(p.mainQuery), p.attributes.main.length > 0 && (s.main = $.uniq(s.main.concat(p.attributes.main))), p.attributes.subQuery.length > 0 && (s.subQuery = $.uniq(s.subQuery.concat(p.attributes.subQuery)));\n    }\n    if (u) a.push(this.selectFromTableFragment(t, l.model, s.subQuery, l.quotedName, l.as)), a.push(f.join(\"\"));else {\n      if (t.groupedLimit) {\n        l.as || (l.as = l.quotedName);\n        const h = N({}, t.where);\n        let p,\n            A,\n            I,\n            E = l.as;\n\n        if (typeof t.groupedLimit.on == \"string\" ? A = t.groupedLimit.on : t.groupedLimit.on instanceof ee && (A = t.groupedLimit.on.foreignKeyField), t.groupedLimit.on instanceof v) {\n          E = t.groupedLimit.on.manyFromSource.as;\n\n          const b = j._validateIncludedElements({\n            include: [{\n              association: t.groupedLimit.on.manyFromSource,\n              duplicating: !1,\n              required: !0,\n              where: N({\n                [c.placeholder]: !0\n              }, t.groupedLimit.through && t.groupedLimit.through.where)\n            }],\n            model: i\n          });\n\n          t.hasJoin = !0, t.hasMultiAssociation = !0, t.includeMap = Object.assign(b.includeMap, t.includeMap), t.includeNames = b.includeNames.concat(t.includeNames || []), I = b.include, Array.isArray(t.order) && (t.order.forEach((O, Q) => {\n            Array.isArray(O) && (O = O[0]);\n            let T = `subquery_order_${Q}`;\n            t.attributes.push([O, T]), T = this.sequelize.literal(this.quote(T)), Array.isArray(t.order[Q]) ? t.order[Q][0] = T : t.order[Q] = T;\n          }), p = t.order);\n        } else p = t.order, delete t.order, h[c.placeholder] = !0;\n\n        const S = `SELECT * FROM (${this.selectQuery(e, {\n          attributes: t.attributes,\n          offset: t.offset,\n          limit: t.groupedLimit.limit,\n          order: p,\n          aliasesMapping: t.aliasesMapping,\n          aliasesByTable: t.aliasesByTable,\n          where: h,\n          include: I,\n          model: i\n        }, i).replace(/;$/, \"\")}) AS sub`,\n              _ = this.whereItemQuery(c.placeholder, !0, {\n          model: i\n        }),\n              q = S.indexOf(_);\n\n        n.push(this.selectFromTableFragment(t, l.model, s.main, `(${t.groupedLimit.values.map(b => {\n          let O;\n          return A && (O = {\n            [A]: b\n          }), I && (O = {\n            [t.groupedLimit.on.foreignIdentifierField]: b\n          }), d.spliceStr(S, q, _.length, this.getWhereConditions(O, E));\n        }).join(this._dialect.supports[\"UNION ALL\"] ? \" UNION ALL \" : \" UNION \")})`, l.as));\n      } else n.push(this.selectFromTableFragment(t, l.model, s.main, l.quotedName, l.as));\n\n      n.push(g.join(\"\"));\n    }\n\n    if (Object.prototype.hasOwnProperty.call(t, \"where\") && !t.groupedLimit && (t.where = this.getWhereConditions(t.where, l.as || e, i, t), t.where && (u ? a.push(` WHERE ${t.where}`) : (n.push(` WHERE ${t.where}`), n.forEach((h, p) => {\n      h.startsWith(\"SELECT\") && (n[p] = this.selectFromTableFragment(t, i, s.main, l.quotedName, l.as, t.where));\n    })))), t.group && (t.group = Array.isArray(t.group) ? t.group.map(h => this.aliasGrouping(h, i, l.as, t)).join(\", \") : this.aliasGrouping(t.group, i, l.as, t), u && t.group ? a.push(` GROUP BY ${t.group}`) : t.group && n.push(` GROUP BY ${t.group}`)), Object.prototype.hasOwnProperty.call(t, \"having\") && (t.having = this.getWhereConditions(t.having, e, i, t, !1), t.having && (u ? a.push(` HAVING ${t.having}`) : n.push(` HAVING ${t.having}`))), t.order) {\n      const h = this.getQueryOrders(t, i, u);\n      h.mainQueryOrder.length && n.push(` ORDER BY ${h.mainQueryOrder.join(\", \")}`), h.subQueryOrder.length && a.push(` ORDER BY ${h.subQueryOrder.join(\", \")}`);\n    }\n\n    const y = this.addLimitAndOffset(t, l.model);\n\n    if (y && !t.groupedLimit && (u ? a.push(y) : n.push(y)), u ? (this._throwOnEmptyAttributes(s.main, {\n      modelName: i && i.name,\n      as: l.as\n    }), m = `SELECT ${s.main.join(\", \")} FROM (${a.join(\"\")}) AS ${l.as}${g.join(\"\")}${n.join(\"\")}`) : m = n.join(\"\"), t.lock && this._dialect.supports.lock) {\n      let h = t.lock;\n      typeof t.lock == \"object\" && (h = t.lock.level), this._dialect.supports.lockKey && (h === \"KEY SHARE\" || h === \"NO KEY UPDATE\") ? m += ` FOR ${h}` : h === \"SHARE\" ? m += ` ${this._dialect.supports.forShare}` : m += \" FOR UPDATE\", this._dialect.supports.lockOf && t.lock.of && t.lock.of.prototype instanceof j && (m += ` OF ${this.quoteTable(t.lock.of.name)}`), this._dialect.supports.skipLocked && t.skipLocked && (m += \" SKIP LOCKED\");\n    }\n\n    return `${m};`;\n  }\n\n  aliasGrouping(e, t, i, r) {\n    const n = Array.isArray(e) ? e[0] : e;\n    return this.quote(this._getAliasForField(i, n, r) || n, t);\n  }\n\n  escapeAttributes(e, t, i) {\n    return e && e.map(r => {\n      let n = !0;\n      if (r instanceof d.SequelizeMethod) return this.handleSequelizeMethod(r);\n\n      if (Array.isArray(r)) {\n        if (r.length !== 2) throw new Error(`${JSON.stringify(r)} is not a valid attribute definition. Please use the following format: ['attribute definition', 'alias']`);\n        r = r.slice(), r[0] instanceof d.SequelizeMethod ? (r[0] = this.handleSequelizeMethod(r[0]), n = !1) : !r[0].includes(\"(\") && !r[0].includes(\")\") ? r[0] = this.quoteIdentifier(r[0]) : k.noRawAttributes();\n        let a = r[1];\n        this.options.minifyAliases && (a = this._getMinifiedAlias(a, i, t)), r = [r[0], this.quoteIdentifier(a)].join(\" AS \");\n      } else r = !r.includes(d.TICK_CHAR) && !r.includes('\"') ? this.quoteAttribute(r, t.model) : this.escape(r);\n\n      return !$.isEmpty(t.include) && (!r.includes(\".\") || t.dotNotation) && n && (r = `${i}.${r}`), r;\n    });\n  }\n\n  generateInclude(e, t, i) {\n    const r = {\n      mainQuery: [],\n      subQuery: []\n    },\n          n = [],\n          a = [];\n    let u = !1;\n    const s = {\n      internalAs: e.as,\n      externalAs: e.as\n    },\n          l = {\n      main: [],\n      subQuery: []\n    };\n    let o;\n\n    if (i.options.keysEscaped = !0, i.names.name !== t.externalAs && i.names.as !== t.externalAs && (s.internalAs = `${t.internalAs}->${e.as}`, s.externalAs = `${t.externalAs}.${e.as}`), i.options.includeIgnoreAttributes !== !1) {\n      e.model._expandAttributes(e), d.mapFinderOptions(e, e.model);\n      const g = e.attributes.map(f => {\n        let m = f,\n            y = !1;\n        if (Array.isArray(f) && f.length === 2 && (f[0] instanceof d.SequelizeMethod && (f[0] instanceof d.Literal || f[0] instanceof d.Cast || f[0] instanceof d.Fn) && (y = !0), f = f.map(A => A instanceof d.SequelizeMethod ? this.handleSequelizeMethod(A) : A), m = f[1], f = f[0]), f instanceof d.Literal) return f.val;\n        if (f instanceof d.Cast || f instanceof d.Fn) throw new Error(\"Tried to select attributes using Sequelize.cast or Sequelize.fn without specifying an alias for the result, during eager loading. This means the attribute will not be added to the returned instance\");\n        let h;\n        y === !0 ? h = f : /#>>|->>/.test(f) ? h = `(${this.quoteIdentifier(s.internalAs)}.${f.replace(/\\(|\\)/g, \"\")})` : /json_extract\\(/.test(f) ? h = f.replace(/json_extract\\(/i, `json_extract(${this.quoteIdentifier(s.internalAs)}.`) : h = `${this.quoteIdentifier(s.internalAs)}.${this.quoteIdentifier(f)}`;\n        let p = `${s.externalAs}.${m}`;\n        return this.options.minifyAliases && (p = this._getMinifiedAlias(p, s.internalAs, i.options)), d.joinSQLFragments([h, \"AS\", this.quoteIdentifier(p, !0)]);\n      });\n      if (e.subQuery && i.subQuery) for (const f of g) l.subQuery.push(f);else for (const f of g) l.main.push(f);\n    }\n\n    if (e.through ? o = this.generateThroughJoin(e, s, t.internalAs, i) : (this._generateSubQueryFilter(e, s, i), o = this.generateJoin(e, i)), o.attributes.main.length > 0 && (l.main = l.main.concat(o.attributes.main)), o.attributes.subQuery.length > 0 && (l.subQuery = l.subQuery.concat(o.attributes.subQuery)), e.include) for (const g of e.include) {\n      if (g.separate || g._pseudo) continue;\n      const f = this.generateInclude(g, s, i);\n      e.required === !1 && g.required === !0 && (u = !0), g.subQuery && i.subQuery && a.push(f.subQuery), f.mainQuery && n.push(f.mainQuery), f.attributes.main.length > 0 && (l.main = l.main.concat(f.attributes.main)), f.attributes.subQuery.length > 0 && (l.subQuery = l.subQuery.concat(f.attributes.subQuery));\n    }\n    return e.subQuery && i.subQuery ? (u && a.length > 0 ? r.subQuery.push(` ${o.join} ( ${o.body}${a.join(\"\")} ) ON ${o.condition}`) : (r.subQuery.push(` ${o.join} ${o.body} ON ${o.condition}`), a.length > 0 && r.subQuery.push(a.join(\"\"))), r.mainQuery.push(n.join(\"\"))) : (u && n.length > 0 ? r.mainQuery.push(` ${o.join} ( ${o.body}${n.join(\"\")} ) ON ${o.condition}`) : (r.mainQuery.push(` ${o.join} ${o.body} ON ${o.condition}`), n.length > 0 && r.mainQuery.push(n.join(\"\"))), r.subQuery.push(a.join(\"\"))), {\n      mainQuery: r.mainQuery.join(\"\"),\n      subQuery: r.subQuery.join(\"\"),\n      attributes: l\n    };\n  }\n\n  _getMinifiedAlias(e, t, i) {\n    if (i.aliasesByTable[`${t}${e}`]) return i.aliasesByTable[`${t}${e}`];\n    if (e.match(/subquery_order_[0-9]/)) return e;\n    const r = `_${i.aliasesMapping.size}`;\n    return i.aliasesMapping.set(r, e), i.aliasesByTable[`${t}${e}`] = r, r;\n  }\n\n  _getAliasForField(e, t, i) {\n    return this.options.minifyAliases && i.aliasesByTable[`${e}${t}`] ? i.aliasesByTable[`${e}${t}`] : null;\n  }\n\n  generateJoin(e, t) {\n    const i = e.association,\n          r = e.parent,\n          n = !!r && !e.parent.association && e.parent.model.name === t.options.model.name;\n    let a, u;\n    const s = i.source,\n          l = i instanceof P ? i.identifier : i.sourceKeyAttribute || s.primaryKeyAttribute,\n          o = i instanceof P ? i.identifierField : s.rawAttributes[i.sourceKeyAttribute || s.primaryKeyAttribute].field;\n    let g;\n    const f = e.model,\n          m = f.getTableName(),\n          y = i instanceof P ? f.rawAttributes[i.targetIdentifier || f.primaryKeyAttribute].field : i.identifierField;\n    let h = e.as;\n\n    for (; (a = a && a.parent || e.parent) && a.association;) g ? g = `${a.as}->${g}` : g = a.as;\n\n    g ? h = `${g}->${h}` : g = r.as || r.model.name;\n    let p = `${this.quoteTable(g)}.${this.quoteIdentifier(o)}`;\n    const A = [];\n    if (t.options.groupedLimit && n || t.subQuery && e.parent.subQuery && !e.subQuery) if (n) {\n      const I = this.quoteTable(r.as || r.model.name);\n\n      if (p = this._getAliasForField(I, l, t.options) || `${I}.${this.quoteIdentifier(l)}`, t.subQuery) {\n        const E = `${I}.${this.quoteIdentifier(o)}`;\n        A.push(E !== p ? `${E} AS ${this.quoteIdentifier(l)}` : E);\n      }\n    } else {\n      const I = `${g.replace(/->/g, \".\")}.${l}`;\n      p = this._getAliasForField(g, I, t.options) || this.quoteIdentifier(I);\n    }\n\n    if (p += ` = ${this.quoteIdentifier(h)}.${this.quoteIdentifier(y)}`, e.on && (p = this.whereItemsQuery(e.on, {\n      prefix: this.sequelize.literal(this.quoteIdentifier(h)),\n      model: e.model\n    })), e.where && (u = this.whereItemsQuery(e.where, {\n      prefix: this.sequelize.literal(this.quoteIdentifier(h)),\n      model: e.model\n    }), u && (e.or ? p += ` OR ${u}` : p += ` AND ${u}`)), this.options.minifyAliases && h.length > 63) {\n      const I = `%${t.options.includeAliases.size}`;\n      t.options.includeAliases.set(I, h);\n    }\n\n    return {\n      join: e.required ? \"INNER JOIN\" : e.right && this._dialect.supports[\"RIGHT JOIN\"] ? \"RIGHT OUTER JOIN\" : \"LEFT OUTER JOIN\",\n      body: this.quoteTable(m, h),\n      condition: p,\n      attributes: {\n        main: [],\n        subQuery: A\n      }\n    };\n  }\n\n  generateReturnValues(e, t) {\n    const i = [],\n          r = [];\n    let n = \"\",\n        a = \"\",\n        u = \"\";\n    return Array.isArray(t.returning) ? i.push(...t.returning.map(s => this.quoteIdentifier(s))) : e && $.each(e, s => {\n      s.type instanceof C.VIRTUAL || (i.push(this.quoteIdentifier(s.field)), r.push(s.type));\n    }), $.isEmpty(i) && i.push(\"*\"), this._dialect.supports.returnValues.returning ? a = ` RETURNING ${i.join(\",\")}` : this._dialect.supports.returnValues.output && (n = ` OUTPUT ${i.map(s => `INSERTED.${s}`).join(\",\")}`, t.hasTrigger && this._dialect.supports.tmpTableTrigger && (u = `DECLARE @tmp TABLE (${i.map((l, o) => `${l} ${r[o].toSql()}`).join(\",\")}); `, n += \" INTO @tmp\", a = \"; SELECT * FROM @tmp\")), {\n      outputFragment: n,\n      returnFields: i,\n      returningFragment: a,\n      tmpTable: u\n    };\n  }\n\n  generateThroughJoin(e, t, i, r) {\n    const n = e.through,\n          a = n.model.getTableName(),\n          u = `${t.internalAs}->${n.as}`,\n          s = `${t.externalAs}.${n.as}`,\n          l = n.attributes.map(T => {\n      let D = `${s}.${Array.isArray(T) ? T[1] : T}`;\n      return this.options.minifyAliases && (D = this._getMinifiedAlias(D, u, r.options)), d.joinSQLFragments([`${this.quoteIdentifier(u)}.${this.quoteIdentifier(Array.isArray(T) ? T[0] : T)}`, \"AS\", this.quoteIdentifier(D)]);\n    }),\n          o = e.association,\n          g = !e.parent.association && e.parent.model.name === r.options.model.name,\n          f = i,\n          m = o.identifierField,\n          y = t.internalAs,\n          h = o.foreignIdentifierField,\n          p = o.targetKeyField,\n          A = e.required ? \"INNER JOIN\" : e.right && this._dialect.supports[\"RIGHT JOIN\"] ? \"RIGHT OUTER JOIN\" : \"LEFT OUTER JOIN\";\n    let I, E;\n    const S = {\n      main: [],\n      subQuery: []\n    };\n    let _ = o.sourceKey,\n        q,\n        b,\n        O,\n        Q;\n    if (r.options.includeIgnoreAttributes !== !1) for (const T of l) S.main.push(T);\n\n    if (r.subQuery || (_ = o.sourceKeyField), r.subQuery && !e.subQuery && !e.parent.subQuery && e.parent.model !== r.options.mainModel && (_ = o.sourceKeyField), r.subQuery && !e.subQuery && e.parent.subQuery && !g) {\n      const T = this._getAliasForField(f, `${f}.${_}`, r.options) || `${f}.${_}`;\n      q = `${this.quoteIdentifier(T)} = `;\n    } else {\n      const T = this._getAliasForField(f, _, r.options) || _;\n\n      q = `${this.quoteTable(f)}.${this.quoteIdentifier(T)} = `;\n    }\n\n    return q += `${this.quoteIdentifier(u)}.${this.quoteIdentifier(m)}`, b = `${this.quoteIdentifier(y)}.${this.quoteIdentifier(p)} = `, b += `${this.quoteIdentifier(u)}.${this.quoteIdentifier(h)}`, n.where && (O = this.getWhereConditions(n.where, this.sequelize.literal(this.quoteIdentifier(u)), n.model)), I = `( ${this.quoteTable(a, u)} INNER JOIN ${this.quoteTable(e.model.getTableName(), t.internalAs)} ON ${b}`, O && (I += ` AND ${O}`), I += \")\", E = q, (e.where || e.through.where) && e.where && (Q = this.getWhereConditions(e.where, this.sequelize.literal(this.quoteIdentifier(t.internalAs)), e.model, r.options), Q && (E += ` AND ${Q}`)), this._generateSubQueryFilter(e, t, r), {\n      join: A,\n      body: I,\n      condition: E,\n      attributes: S\n    };\n  }\n\n  _generateSubQueryFilter(e, t, i) {\n    if (!i.subQuery || !e.subQueryFilter) return;\n    i.options.where || (i.options.where = {});\n\n    let r = e,\n        n = e,\n        a = this._getRequiredClosure(e).include,\n        u;\n\n    for (; r = r.parent;) {\n      if (r.parent && !r.required || r.subQueryFilter) return;\n      a = [M(N({}, n), {\n        include: a,\n        attributes: []\n      })], n = r;\n    }\n\n    const s = a[0],\n          l = s.parent,\n          o = s.association;\n    if (s.association = void 0, s.through && Object(s.through.model) === s.through.model) u = this.selectQuery(s.through.model.getTableName(), {\n      attributes: [s.through.model.primaryKeyField],\n      include: j._validateIncludedElements({\n        model: s.through.model,\n        include: [{\n          association: o.toTarget,\n          required: !0,\n          where: s.where,\n          include: s.include\n        }]\n      }).include,\n      model: s.through.model,\n      where: {\n        [c.and]: [this.sequelize.literal([`${this.quoteTable(l.model.name)}.${this.quoteIdentifier(l.model.primaryKeyField)}`, `${this.quoteIdentifier(s.through.model.name)}.${this.quoteIdentifier(o.identifierField)}`].join(\" = \")), s.through.where]\n      },\n      limit: 1,\n      includeIgnoreAttributes: !1\n    }, s.through.model);else {\n      const g = o.associationType === \"BelongsTo\",\n            f = g ? o.identifierField : o.sourceKeyField || l.model.primaryKeyField,\n            m = g ? o.sourceKeyField || s.model.primaryKeyField : o.identifierField,\n            y = [`${this.quoteIdentifier(s.as)}.${this.quoteIdentifier(m)}`, `${this.quoteTable(l.as || l.model.name)}.${this.quoteIdentifier(f)}`].join(\" = \");\n      u = this.selectQuery(s.model.getTableName(), {\n        attributes: [m],\n        include: j._validateIncludedElements(s).include,\n        model: s.model,\n        where: {\n          [c.and]: [s.where, {\n            [c.join]: this.sequelize.literal(y)\n          }]\n        },\n        limit: 1,\n        tableAs: s.as,\n        includeIgnoreAttributes: !1\n      }, s.model);\n    }\n    i.options.where[c.and] || (i.options.where[c.and] = []), i.options.where[`__${t.internalAs}`] = this.sequelize.literal([\"(\", u.replace(/;$/, \"\"), \")\", \"IS NOT NULL\"].join(\" \"));\n  }\n\n  _getRequiredClosure(e) {\n    const t = M(N({}, e), {\n      attributes: [],\n      include: []\n    });\n    return Array.isArray(e.include) && (t.include = e.include.filter(i => i.required).map(i => this._getRequiredClosure(i))), t;\n  }\n\n  getQueryOrders(e, t, i) {\n    const r = [],\n          n = [];\n    if (Array.isArray(e.order)) for (let a of e.order) {\n      if (Array.isArray(a) || (a = [a]), i && Array.isArray(a) && a[0] && !(a[0] instanceof F) && !(typeof a[0] == \"function\" && a[0].prototype instanceof j) && !(typeof a[0].model == \"function\" && a[0].model.prototype instanceof j) && !(typeof a[0] == \"string\" && t && t.associations !== void 0 && t.associations[a[0]]) && n.push(this.quote(a, t, \"->\")), i) {\n        const u = e.attributes.find(s => Array.isArray(s) && s[0] === a[0] && s[1]);\n\n        if (u) {\n          const s = this.quoteIdentifier(t.name);\n          a[0] = new d.Col(this._getAliasForField(s, u[1], e) || u[1]);\n        }\n      }\n\n      r.push(this.quote(a, t, \"->\"));\n    } else if (e.order instanceof d.SequelizeMethod) {\n      const a = this.quote(e.order, t, \"->\");\n      i && n.push(a), r.push(a);\n    } else throw new Error(\"Order must be type of array or instance of a valid sequelize method.\");\n    return {\n      mainQueryOrder: r,\n      subQueryOrder: n\n    };\n  }\n\n  _throwOnEmptyAttributes(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (e.length > 0) return;\n    const i = t.as && `as ${t.as}` || \"\",\n          n = `Attempted a SELECT query ${t.modelName && `for model '${t.modelName}'` || \"\"} ${i} without selecting any columns`;\n    throw new U.QueryError(n.replace(/ +/g, \" \"));\n  }\n\n  selectFromTableFragment(e, t, i, r, n) {\n    this._throwOnEmptyAttributes(i, {\n      modelName: t && t.name,\n      as: n\n    });\n\n    let a = `SELECT ${i.join(\", \")} FROM ${r}`;\n    if (n && (a += ` AS ${n}`), e.indexHints && this._dialect.supports.indexHints) for (const u of e.indexHints) B[u.type] && (a += ` ${B[u.type]} INDEX (${u.values.map(s => this.quoteIdentifiers(s)).join(\",\")})`);\n    return a;\n  }\n\n  addLimitAndOffset(e) {\n    let t = \"\";\n    return e.offset != null && e.limit == null ? t += \" LIMIT \" + this.escape(e.offset) + \", \" + 1e13 : e.limit != null && (e.offset != null ? t += \" LIMIT \" + this.escape(e.offset) + \", \" + this.escape(e.limit) : t += \" LIMIT \" + this.escape(e.limit)), t;\n  }\n\n  handleSequelizeMethod(e, t, i, r, n) {\n    let a;\n\n    if (Object.prototype.hasOwnProperty.call(this.OperatorMap, e.comparator) && (e.comparator = this.OperatorMap[e.comparator]), e instanceof d.Where) {\n      let u = e.logic,\n          s;\n      return e.attribute instanceof d.SequelizeMethod ? s = this.getWhereConditions(e.attribute, t, i, r, n) : s = `${this.quoteTable(e.attribute.Model.name)}.${this.quoteIdentifier(e.attribute.field || e.attribute.fieldName)}`, u && u instanceof d.SequelizeMethod ? (u = this.getWhereConditions(u, t, i, r, n), u === \"NULL\" && (e.comparator === \"=\" && (e.comparator = \"IS\"), e.comparator === \"!=\" && (e.comparator = \"IS NOT\")), [s, u].join(` ${e.comparator} `)) : $.isPlainObject(u) ? this.whereItemQuery(e.attribute, u, {\n        model: i\n      }) : ([this.OperatorMap[c.between], this.OperatorMap[c.notBetween]].includes(e.comparator) ? u = `${this.escape(u[0])} AND ${this.escape(u[1])}` : typeof u == \"boolean\" ? u = this.booleanValue(u) : u = this.escape(u), u === \"NULL\" && (e.comparator === \"=\" && (e.comparator = \"IS\"), e.comparator === \"!=\" && (e.comparator = \"IS NOT\")), [s, u].join(` ${e.comparator} `));\n    }\n\n    if (e instanceof d.Literal) return e.val;\n    if (e instanceof d.Cast) return e.val instanceof d.SequelizeMethod ? a = this.handleSequelizeMethod(e.val, t, i, r, n) : $.isPlainObject(e.val) ? a = this.whereItemsQuery(e.val) : a = this.escape(e.val), `CAST(${a} AS ${e.type.toUpperCase()})`;\n    if (e instanceof d.Fn) return `${e.fn}(${e.args.map(u => u instanceof d.SequelizeMethod ? this.handleSequelizeMethod(u, t, i, r, n) : $.isPlainObject(u) ? this.whereItemsQuery(u) : this.escape(typeof u == \"string\" ? u.replace(\"$\", \"$$$\") : u)).join(\", \")})`;\n\n    if (e instanceof d.Col) {\n      if (Array.isArray(e.col) && !i) throw new Error(\"Cannot call Sequelize.col() with array outside of order / group clause\");\n      return e.col.startsWith(\"*\") ? \"*\" : this.quote(e.col, i);\n    }\n\n    return e.toString(this, i);\n  }\n\n  whereQuery(e, t) {\n    const i = this.whereItemsQuery(e, t);\n    return i && i.length ? `WHERE ${i}` : \"\";\n  }\n\n  whereItemsQuery(e, t, i) {\n    if (e == null || d.getComplexSize(e) === 0) return \"\";\n    if (typeof e == \"string\") throw new Error(\"Support for `{where: 'raw query'}` has been removed.\");\n    const r = [];\n    return i = i || \"AND\", i[0] !== \" \" && (i = ` ${i} `), $.isPlainObject(e) ? d.getComplexKeys(e).forEach(n => {\n      const a = e[n];\n      r.push(this.whereItemQuery(n, a, t));\n    }) : r.push(this.whereItemQuery(void 0, e, t)), r.length && r.filter(n => n && n.length).join(i) || \"\";\n  }\n\n  whereItemQuery(e, t) {\n    let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (t === void 0) throw new Error(`WHERE parameter \"${e}\" has invalid \"undefined\" value`);\n\n    if (typeof e == \"string\" && e.includes(\".\") && i.model) {\n      const o = e.split(\".\");\n\n      if (i.model.rawAttributes[o[0]] && i.model.rawAttributes[o[0]].type instanceof C.JSON) {\n        const g = {},\n              f = i.model.rawAttributes[o[0]];\n        return $.set(g, o.slice(1), t), this.whereItemQuery(f.field || o[0], g, N({\n          field: f\n        }, i));\n      }\n    }\n\n    const r = this._findField(e, i),\n          n = r && r.type || i.type,\n          a = $.isPlainObject(t),\n          u = !a && Array.isArray(t);\n\n    e = this.OperatorsAliasMap && this.OperatorsAliasMap[e] || e, a && (t = this._replaceAliases(t));\n    const s = a && d.getComplexKeys(t);\n\n    if (e === void 0) {\n      if (typeof t == \"string\") return t;\n      if (a && s.length === 1) return this.whereItemQuery(s[0], t[s[0]], i);\n    }\n\n    if (t === null) {\n      const o = i.bindParam ? \"NULL\" : this.escape(t, r);\n      return this._joinKeyValue(e, o, this.OperatorMap[c.is], i.prefix);\n    }\n\n    if (!t) {\n      const o = i.bindParam ? this.format(t, r, i, i.bindParam) : this.escape(t, r);\n      return this._joinKeyValue(e, o, this.OperatorMap[c.eq], i.prefix);\n    }\n\n    if (t instanceof d.SequelizeMethod && !(e !== void 0 && t instanceof d.Fn)) return this.handleSequelizeMethod(t);\n    if (e === void 0 && u) if (d.canTreatArrayAsAnd(t)) e = c.and;else throw new Error(\"Support for literal replacements in the `where` object has been removed.\");\n    if (e === c.or || e === c.and || e === c.not) return this._whereGroupBind(e, t, i);\n    if (t[c.or]) return this._whereBind(this.OperatorMap[c.or], e, t[c.or], i);\n    if (t[c.and]) return this._whereBind(this.OperatorMap[c.and], e, t[c.and], i);\n\n    if (u && n instanceof C.ARRAY) {\n      const o = i.bindParam ? this.format(t, r, i, i.bindParam) : this.escape(t, r);\n      return this._joinKeyValue(e, o, this.OperatorMap[c.eq], i.prefix);\n    }\n\n    if (a && n instanceof C.JSON && i.json !== !1) return this._whereJSON(e, t, i);\n    if (a && s.length > 1) return this._whereBind(this.OperatorMap[c.and], e, t, i);\n    if (u) return this._whereParseSingleValueObject(e, r, c.in, t, i);\n    if (a) return this.OperatorMap[s[0]] ? this._whereParseSingleValueObject(e, r, s[0], t[s[0]], i) : this._whereParseSingleValueObject(e, r, this.OperatorMap[c.eq], t, i);\n\n    if (e === c.placeholder) {\n      const o = i.bindParam ? this.format(t, r, i, i.bindParam) : this.escape(t, r);\n      return this._joinKeyValue(this.OperatorMap[e], o, this.OperatorMap[c.eq], i.prefix);\n    }\n\n    const l = i.bindParam ? this.format(t, r, i, i.bindParam) : this.escape(t, r);\n    return this._joinKeyValue(e, l, this.OperatorMap[c.eq], i.prefix);\n  }\n\n  _findField(e, t) {\n    if (t.field) return t.field;\n    if (t.model && t.model.rawAttributes && t.model.rawAttributes[e]) return t.model.rawAttributes[e];\n    if (t.model && t.model.fieldRawAttributesMap && t.model.fieldRawAttributesMap[e]) return t.model.fieldRawAttributesMap[e];\n  }\n\n  _whereGroupBind(e, t, i) {\n    const r = e === c.or ? this.OperatorMap[c.or] : this.OperatorMap[c.and],\n          n = e === c.not ? \"NOT \" : \"\";\n    return Array.isArray(t) ? (t = t.map(a => {\n      let u = this.whereItemsQuery(a, i, this.OperatorMap[c.and]);\n      return u && u.length && (Array.isArray(a) || $.isPlainObject(a)) && d.getComplexSize(a) > 1 && (u = `(${u})`), u;\n    }).filter(a => a && a.length), t = t.length && t.join(r)) : t = this.whereItemsQuery(t, i, r), (e === c.or || e === c.not) && !t ? \"0 = 1\" : t ? `${n}(${t})` : void 0;\n  }\n\n  _whereBind(e, t, i, r) {\n    return $.isPlainObject(i) ? i = d.getComplexKeys(i).map(n => {\n      const a = i[n];\n      return this.whereItemQuery(t, {\n        [n]: a\n      }, r);\n    }) : i = i.map(n => this.whereItemQuery(t, n, r)), i = i.filter(n => n && n.length), i.length ? `(${i.join(e)})` : void 0;\n  }\n\n  _whereJSON(e, t, i) {\n    const r = [];\n    let n = this.quoteIdentifier(e);\n    i.prefix && (i.prefix instanceof d.Literal ? n = `${this.handleSequelizeMethod(i.prefix)}.${n}` : n = `${this.quoteTable(i.prefix)}.${n}`), d.getOperators(t).forEach(u => {\n      const s = {\n        [u]: t[u]\n      };\n      r.push(this.whereItemQuery(e, s, M(N({}, i), {\n        json: !1\n      })));\n    }), $.forOwn(t, (u, s) => {\n      this._traverseJSON(r, n, s, u, [s]);\n    });\n    const a = r.join(this.OperatorMap[c.and]);\n    return r.length > 1 ? `(${a})` : a;\n  }\n\n  _traverseJSON(e, t, i, r, n) {\n    let a;\n\n    if (n[n.length - 1].includes(\"::\")) {\n      const s = n[n.length - 1].split(\"::\");\n      a = s[1], n[n.length - 1] = s[0];\n    }\n\n    const u = this.jsonPathExtractionQuery(t, n);\n\n    if ($.isPlainObject(r)) {\n      d.getOperators(r).forEach(s => {\n        const l = this._toJSONValue(r[s]);\n\n        e.push(this.whereItemQuery(this._castKey(u, l, a), {\n          [s]: l\n        }));\n      }), $.forOwn(r, (s, l) => {\n        this._traverseJSON(e, t, l, s, n.concat([l]));\n      });\n      return;\n    }\n\n    r = this._toJSONValue(r), e.push(this.whereItemQuery(this._castKey(u, r, a), {\n      [c.eq]: r\n    }));\n  }\n\n  _toJSONValue(e) {\n    return e;\n  }\n\n  _castKey(e, t, i, r) {\n    return i = i || this._getJsonCast(Array.isArray(t) ? t[0] : t), i ? new d.Literal(this.handleSequelizeMethod(new d.Cast(new d.Literal(e), i, r))) : new d.Literal(e);\n  }\n\n  _getJsonCast(e) {\n    if (typeof e == \"number\") return \"double precision\";\n    if (e instanceof Date) return \"timestamptz\";\n    if (typeof e == \"boolean\") return \"boolean\";\n  }\n\n  _joinKeyValue(e, t, i, r) {\n    if (!e) return t;\n    if (i === void 0) throw new Error(`${e} and ${t} has no comparator`);\n    return e = this._getSafeKey(e, r), [e, t].join(` ${i} `);\n  }\n\n  _getSafeKey(e, t) {\n    return e instanceof d.SequelizeMethod ? (e = this.handleSequelizeMethod(e), this._prefixKey(this.handleSequelizeMethod(e), t)) : d.isColString(e) ? (e = e.substr(1, e.length - 2).split(\".\"), e.length > 2 && (e = [e.slice(0, -1).join(\"->\"), e[e.length - 1]]), e.map(i => this.quoteIdentifier(i)).join(\".\")) : this._prefixKey(this.quoteIdentifier(e), t);\n  }\n\n  _prefixKey(e, t) {\n    return t ? t instanceof d.Literal ? [this.handleSequelizeMethod(t), e].join(\".\") : [this.quoteTable(t), e].join(\".\") : e;\n  }\n\n  _whereParseSingleValueObject(e, t, i, r, n) {\n    i === c.not && (Array.isArray(r) ? i = c.notIn : r !== null && r !== !0 && r !== !1 && (i = c.ne));\n    let a = this.OperatorMap[i] || this.OperatorMap[c.eq];\n\n    switch (i) {\n      case c.in:\n      case c.notIn:\n        return r instanceof d.Literal ? this._joinKeyValue(e, r.val, a, n.prefix) : r.length ? this._joinKeyValue(e, `(${r.map(l => this.escape(l, t)).join(\", \")})`, a, n.prefix) : a === this.OperatorMap[c.in] ? this._joinKeyValue(e, \"(NULL)\", a, n.prefix) : \"\";\n\n      case c.any:\n      case c.all:\n        return a = `${this.OperatorMap[c.eq]} ${a}`, r[c.values] ? this._joinKeyValue(e, `(VALUES ${r[c.values].map(l => `(${this.escape(l)})`).join(\", \")})`, a, n.prefix) : this._joinKeyValue(e, `(${this.escape(r, t)})`, a, n.prefix);\n\n      case c.between:\n      case c.notBetween:\n        return this._joinKeyValue(e, `${this.escape(r[0], t)} AND ${this.escape(r[1], t)}`, a, n.prefix);\n\n      case c.raw:\n        throw new Error(\"The `$raw` where property is no longer supported.  Use `sequelize.literal` instead.\");\n\n      case c.col:\n        return a = this.OperatorMap[c.eq], r = r.split(\".\"), r.length > 2 && (r = [r.slice(0, -1).join(\"->\"), r[r.length - 1]]), this._joinKeyValue(e, r.map(l => this.quoteIdentifier(l)).join(\".\"), a, n.prefix);\n\n      case c.startsWith:\n      case c.endsWith:\n      case c.substring:\n        a = this.OperatorMap[c.like], r instanceof d.Literal && (r = r.val);\n        let s = `${r}%`;\n        return i === c.endsWith && (s = `%${r}`), i === c.substring && (s = `%${r}%`), this._joinKeyValue(e, this.escape(s), a, n.prefix);\n    }\n\n    const u = {\n      acceptStrings: a.includes(this.OperatorMap[c.like])\n    };\n\n    if ($.isPlainObject(r)) {\n      if (r[c.col]) return this._joinKeyValue(e, this.whereItemQuery(null, r), a, n.prefix);\n      if (r[c.any]) return u.isList = !0, this._joinKeyValue(e, `(${this.escape(r[c.any], t, u)})`, `${a} ${this.OperatorMap[c.any]}`, n.prefix);\n      if (r[c.all]) return u.isList = !0, this._joinKeyValue(e, `(${this.escape(r[c.all], t, u)})`, `${a} ${this.OperatorMap[c.all]}`, n.prefix);\n    }\n\n    return r === null && a === this.OperatorMap[c.eq] ? this._joinKeyValue(e, this.escape(r, t, u), this.OperatorMap[c.is], n.prefix) : r === null && a === this.OperatorMap[c.ne] ? this._joinKeyValue(e, this.escape(r, t, u), this.OperatorMap[c.not], n.prefix) : this._joinKeyValue(e, this.escape(r, t, u), a, n.prefix);\n  }\n\n  getWhereConditions(e, t, i, r, n) {\n    const a = {};\n    if (Array.isArray(t) && (t = t[0], Array.isArray(t) && (t = t[1])), r = r || {}, n === void 0 && (n = !0), e && e instanceof d.SequelizeMethod) return this.handleSequelizeMethod(e, t, i, r, n);\n    if ($.isPlainObject(e)) return this.whereItemsQuery(e, {\n      model: i,\n      prefix: n && t,\n      type: r.type\n    });\n\n    if (typeof e == \"number\") {\n      let u = i ? Object.keys(i.primaryKeys) : [];\n      return u.length > 0 ? u = u[0] : u = \"id\", a[u] = e, this.whereItemsQuery(a, {\n        model: i,\n        prefix: n && t\n      });\n    }\n\n    if (typeof e == \"string\") return this.whereItemsQuery(e, {\n      model: i,\n      prefix: n && t\n    });\n    if (Buffer.isBuffer(e)) return this.escape(e);\n\n    if (Array.isArray(e)) {\n      if (e.length === 0 || e.length > 0 && e[0].length === 0) return \"1=1\";\n\n      if (d.canTreatArrayAsAnd(e)) {\n        const u = {\n          [c.and]: e\n        };\n        return this.getWhereConditions(u, t, i, r, n);\n      }\n\n      throw new Error(\"Support for literal replacements in the `where` object has been removed.\");\n    }\n\n    return e === null ? this.whereItemsQuery(e, {\n      model: i,\n      prefix: n && t\n    }) : \"1=1\";\n  }\n\n  parseConditionObject(e, t) {\n    return t = t || [], $.reduce(e, (i, r, n) => $.isObject(r) ? i.concat(this.parseConditionObject(r, t.concat(n))) : (i.push({\n      path: t.concat(n),\n      value: r\n    }), i), []);\n  }\n\n  booleanValue(e) {\n    return e;\n  }\n\n}\n\nL(R, \"QueryGenerator\"), Object.assign(R.prototype, require(\"./query-generator/operators\")), Object.assign(R.prototype, require(\"./query-generator/transaction\")), module.exports = R;","map":{"version":3,"sources":["../../../../lib/dialects/abstract/query-generator.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst util = require('util');\nconst _ = require('lodash');\nconst uuidv4 = require('uuid').v4;\n\nconst Utils = require('../../utils');\nconst deprecations = require('../../utils/deprecations');\nconst SqlString = require('../../sql-string');\nconst DataTypes = require('../../data-types');\nconst Model = require('../../model');\nconst Association = require('../../associations/base');\nconst BelongsTo = require('../../associations/belongs-to');\nconst BelongsToMany = require('../../associations/belongs-to-many');\nconst HasMany = require('../../associations/has-many');\nconst Op = require('../../operators');\nconst sequelizeError = require('../../errors');\nconst IndexHints = require('../../index-hints');\n\nconst QuoteHelper = require('./query-generator/helpers/quote');\n\n/**\n * Abstract Query Generator\n *\n * @private\n */\nclass QueryGenerator {\n  constructor(options) {\n    if (!options.sequelize) throw new Error('QueryGenerator initialized without options.sequelize');\n    if (!options._dialect) throw new Error('QueryGenerator initialized without options._dialect');\n\n    this.sequelize = options.sequelize;\n    this.options = options.sequelize.options;\n\n    // dialect name\n    this.dialect = options._dialect.name;\n    this._dialect = options._dialect;\n  }\n\n  extractTableDetails(tableName, options) {\n    options = options || {};\n    tableName = tableName || {};\n    return {\n      schema: tableName.schema || options.schema || 'public',\n      tableName: _.isPlainObject(tableName) ? tableName.tableName : tableName,\n      delimiter: tableName.delimiter || options.delimiter || '.'\n    };\n  }\n\n  addSchema(param) {\n    if (!param._schema) return param.tableName || param;\n    const self = this;\n    return {\n      tableName: param.tableName || param,\n      table: param.tableName || param,\n      name: param.name || param,\n      schema: param._schema,\n      delimiter: param._schemaDelimiter || '.',\n      toString() {\n        return self.quoteTable(this);\n      }\n    };\n  }\n\n  dropSchema(tableName, options) {\n    return this.dropTableQuery(tableName, options);\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(\n      this.addSchema({\n        tableName,\n        _schema: schema,\n        _schemaDelimiter: schemaDelimiter\n      })\n    );\n\n    return `DESCRIBE ${table};`;\n  }\n\n  dropTableQuery(tableName) {\n    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)};`;\n  }\n\n  renameTableQuery(before, after) {\n    return `ALTER TABLE ${this.quoteTable(before)} RENAME TO ${this.quoteTable(after)};`;\n  }\n\n  /**\n   * Returns an insert into command\n   *\n   * @param {string} table\n   * @param {object} valueHash       attribute value pairs\n   * @param {object} modelAttributes\n   * @param {object} [options]\n   *\n   * @private\n   */\n  insertQuery(table, valueHash, modelAttributes, options) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    const modelAttributeMap = {};\n    const bind = [];\n    const fields = [];\n    const returningModelAttributes = [];\n    const values = [];\n    const quotedTable = this.quoteTable(table);\n    const bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;\n    let query;\n    let valueQuery = '';\n    let emptyQuery = '';\n    let outputFragment = '';\n    let returningFragment = '';\n    let identityWrapperRequired = false;\n    let tmpTable = ''; //tmpTable declaration for trigger\n\n    if (modelAttributes) {\n      _.each(modelAttributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    if (this._dialect.supports['DEFAULT VALUES']) {\n      emptyQuery += ' DEFAULT VALUES';\n    } else if (this._dialect.supports['VALUES ()']) {\n      emptyQuery += ' VALUES ()';\n    }\n\n    if (this._dialect.supports.returnValues && options.returning) {\n      const returnValues = this.generateReturnValues(modelAttributes, options);\n\n      returningModelAttributes.push(...returnValues.returnFields);\n      returningFragment = returnValues.returningFragment;\n      tmpTable = returnValues.tmpTable || '';\n      outputFragment = returnValues.outputFragment || '';\n    }\n\n    if (_.get(this, ['sequelize', 'options', 'dialectOptions', 'prependSearchPath']) || options.searchPath) {\n      // Not currently supported with search path (requires output of multiple queries)\n      options.bindParam = false;\n    }\n\n    if (this._dialect.supports.EXCEPTION && options.exception) {\n      // Not currently supported with bind parameters (requires output of multiple queries)\n      options.bindParam = false;\n    }\n\n    valueHash = Utils.removeNullValuesFromHash(valueHash, this.options.omitNull);\n    for (const key in valueHash) {\n      if (Object.prototype.hasOwnProperty.call(valueHash, key)) {\n        const value = valueHash[key];\n        fields.push(this.quoteIdentifier(key));\n\n        // SERIALS' can't be NULL in postgresql, use DEFAULT where supported\n        if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && value == null) {\n          if (!this._dialect.supports.autoIncrement.defaultValue) {\n            fields.splice(-1, 1);\n          } else if (this._dialect.supports.DEFAULT) {\n            values.push('DEFAULT');\n          } else {\n            values.push(this.escape(null));\n          }\n        } else {\n          if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true) {\n            identityWrapperRequired = true;\n          }\n\n          if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n            values.push(this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'INSERT' }));\n          } else {\n            values.push(this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'INSERT' }, bindParam));\n          }\n        }\n      }\n    }\n\n    let onDuplicateKeyUpdate = '';\n\n    if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {\n      if (this._dialect.supports.inserts.updateOnDuplicate == ' ON CONFLICT DO UPDATE SET') { // postgres / sqlite\n        // If no conflict target columns were specified, use the primary key names from options.upsertKeys\n        const conflictKeys = options.upsertKeys.map(attr => this.quoteIdentifier(attr));\n        const updateKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);\n        onDuplicateKeyUpdate = ` ON CONFLICT (${conflictKeys.join(',')}) DO UPDATE SET ${updateKeys.join(',')}`;\n      } else {\n        const valueKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=VALUES(${this.quoteIdentifier(attr)})`);\n        onDuplicateKeyUpdate += `${this._dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(',')}`;\n      }\n    }\n\n    const replacements = {\n      ignoreDuplicates: options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : '',\n      onConflictDoNothing: options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : '',\n      attributes: fields.join(','),\n      output: outputFragment,\n      values: values.join(','),\n      tmpTable\n    };\n\n    valueQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable} (${replacements.attributes})${replacements.output} VALUES (${replacements.values})${onDuplicateKeyUpdate}${replacements.onConflictDoNothing}${valueQuery}`;\n    emptyQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable}${replacements.output}${onDuplicateKeyUpdate}${replacements.onConflictDoNothing}${emptyQuery}`;\n\n    // Mostly for internal use, so we expect the user to know what he's doing!\n    // pg_temp functions are private per connection, so we never risk this function interfering with another one.\n    if (this._dialect.supports.EXCEPTION && options.exception) {\n      const dropFunction = 'DROP FUNCTION IF EXISTS pg_temp.testfunc()';\n\n      if (returningModelAttributes.length === 0) {\n        returningModelAttributes.push('*');\n      }\n\n      const delimiter = `$func_${uuidv4().replace(/-/g, '')}$`;\n      const selectQuery = `SELECT (testfunc.response).${returningModelAttributes.join(', (testfunc.response).')}, testfunc.sequelize_caught_exception FROM pg_temp.testfunc();`;\n\n      options.exception = 'WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL;';\n      valueQuery = `CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response ${quotedTable}, OUT sequelize_caught_exception text) RETURNS RECORD AS ${delimiter} BEGIN ${valueQuery} RETURNING * INTO response; EXCEPTION ${options.exception} END ${delimiter} LANGUAGE plpgsql; ${selectQuery} ${dropFunction}`;\n    } else {\n      valueQuery += returningFragment;\n      emptyQuery += returningFragment;\n    }\n\n    query = `${replacements.attributes.length ? valueQuery : emptyQuery};`;\n    if (identityWrapperRequired && this._dialect.supports.autoIncrement.identityInsert) {\n      query = `SET IDENTITY_INSERT ${quotedTable} ON; ${query} SET IDENTITY_INSERT ${quotedTable} OFF;`;\n    }\n\n    // Used by Postgres upsertQuery and calls to here with options.exception set to true\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = bind;\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns an insert into command for multiple values.\n   *\n   * @param {string} tableName\n   * @param {object} fieldValueHashes\n   * @param {object} options\n   * @param {object} fieldMappedAttributes\n   *\n   * @private\n   */\n  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n    options = options || {};\n    fieldMappedAttributes = fieldMappedAttributes || {};\n\n    const tuples = [];\n    const serials = {};\n    const allAttributes = [];\n    let onDuplicateKeyUpdate = '';\n\n    for (const fieldValueHash of fieldValueHashes) {\n      _.forOwn(fieldValueHash, (value, key) => {\n        if (!allAttributes.includes(key)) {\n          allAttributes.push(key);\n        }\n        if (\n          fieldMappedAttributes[key]\n          && fieldMappedAttributes[key].autoIncrement === true\n        ) {\n          serials[key] = true;\n        }\n      });\n    }\n\n    for (const fieldValueHash of fieldValueHashes) {\n      const values = allAttributes.map(key => {\n        if (\n          this._dialect.supports.bulkDefault\n          && serials[key] === true\n        ) {\n          // fieldValueHashes[key] ?? 'DEFAULT'\n          return fieldValueHash[key] != null ? fieldValueHash[key] : 'DEFAULT';\n        }\n\n        return this.escape(fieldValueHash[key], fieldMappedAttributes[key], { context: 'INSERT' });\n      });\n\n      tuples.push(`(${values.join(',')})`);\n    }\n\n    if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {\n      if (this._dialect.supports.inserts.updateOnDuplicate == ' ON CONFLICT DO UPDATE SET') { // postgres / sqlite\n        // If no conflict target columns were specified, use the primary key names from options.upsertKeys\n        const conflictKeys = options.upsertKeys.map(attr => this.quoteIdentifier(attr));\n        const updateKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);\n        onDuplicateKeyUpdate = ` ON CONFLICT (${conflictKeys.join(',')}) DO UPDATE SET ${updateKeys.join(',')}`;\n      } else { // mysql / maria\n        const valueKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=VALUES(${this.quoteIdentifier(attr)})`);\n        onDuplicateKeyUpdate = `${this._dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(',')}`;\n      }\n    }\n\n    const ignoreDuplicates = options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : '';\n    const attributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(',');\n    const onConflictDoNothing = options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : '';\n    let returning = '';\n\n    if (this._dialect.supports.returnValues && options.returning) {\n      const returnValues = this.generateReturnValues(fieldMappedAttributes, options);\n\n      returning += returnValues.returningFragment;\n    }\n\n    return Utils.joinSQLFragments([\n      'INSERT',\n      ignoreDuplicates,\n      'INTO',\n      this.quoteTable(tableName),\n      `(${attributes})`,\n      'VALUES',\n      tuples.join(','),\n      onDuplicateKeyUpdate,\n      onConflictDoNothing,\n      returning,\n      ';'\n    ]);\n  }\n\n  /**\n   * Returns an update query\n   *\n   * @param {string} tableName\n   * @param {object} attrValueHash\n   * @param {object} where A hash with conditions (e.g. {name: 'foo'}) OR an ID as integer\n   * @param {object} options\n   * @param {object} attributes\n   *\n   * @private\n   */\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n\n    const values = [];\n    const bind = [];\n    const modelAttributeMap = {};\n    let outputFragment = '';\n    let tmpTable = ''; // tmpTable declaration for trigger\n    let suffix = '';\n\n    if (_.get(this, ['sequelize', 'options', 'dialectOptions', 'prependSearchPath']) || options.searchPath) {\n      // Not currently supported with search path (requires output of multiple queries)\n      options.bindParam = false;\n    }\n\n    const bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;\n\n    if (this._dialect.supports['LIMIT ON UPDATE'] && options.limit) {\n      if (this.dialect !== 'mssql') {\n        suffix = ` LIMIT ${this.escape(options.limit)} `;\n      }\n    }\n\n    if (this._dialect.supports.returnValues && options.returning) {\n      const returnValues = this.generateReturnValues(attributes, options);\n\n      suffix += returnValues.returningFragment;\n      tmpTable = returnValues.tmpTable || '';\n      outputFragment = returnValues.outputFragment || '';\n\n      // ensure that the return output is properly mapped to model fields.\n      if (!this._dialect.supports.returnValues.output && options.returning) {\n        options.mapToModel = true;\n      }\n    }\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      if (modelAttributeMap && modelAttributeMap[key] &&\n        modelAttributeMap[key].autoIncrement === true &&\n        !this._dialect.supports.autoIncrement.update) {\n        // not allowed to update identity column\n        continue;\n      }\n\n      const value = attrValueHash[key];\n\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }, bindParam)}`);\n      }\n    }\n\n    const whereOptions = { ...options, bindParam };\n\n    if (values.length === 0) {\n      return '';\n    }\n\n    const query = `${tmpTable}UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')}${outputFragment} ${this.whereQuery(where, whereOptions)}${suffix}`.trim();\n    // Used by Postgres upsertQuery and calls to here with options.exception set to true\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = bind;\n    }\n    return result;\n  }\n\n  /**\n   * Returns an update query using arithmetic operator\n   *\n   * @param {string} operator                    String with the arithmetic operator (e.g. '+' or '-')\n   * @param {string} tableName                   Name of the table\n   * @param {object} where                       A plain-object with conditions (e.g. {name: 'foo'}) OR an ID as integer\n   * @param {object} incrementAmountsByField     A plain-object with attribute-value-pairs\n   * @param {object} extraAttributesToBeUpdated  A plain-object with attribute-value-pairs\n   * @param {object} options\n   *\n   * @private\n   */\n  arithmeticQuery(operator, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = options || {};\n    _.defaults(options, { returning: true });\n\n    extraAttributesToBeUpdated = Utils.removeNullValuesFromHash(extraAttributesToBeUpdated, this.options.omitNull);\n\n    let outputFragment = '';\n    let returningFragment = '';\n\n    if (this._dialect.supports.returnValues && options.returning) {\n      const returnValues = this.generateReturnValues(null, options);\n\n      outputFragment = returnValues.outputFragment;\n      returningFragment = returnValues.returningFragment;\n    }\n\n    const updateSetSqlFragments = [];\n    for (const field in incrementAmountsByField) {\n      const incrementAmount = incrementAmountsByField[field];\n      const quotedField = this.quoteIdentifier(field);\n      const escapedAmount = this.escape(incrementAmount);\n      updateSetSqlFragments.push(`${quotedField}=${quotedField}${operator} ${escapedAmount}`);\n    }\n    for (const field in extraAttributesToBeUpdated) {\n      const newValue = extraAttributesToBeUpdated[field];\n      const quotedField = this.quoteIdentifier(field);\n      const escapedValue = this.escape(newValue);\n      updateSetSqlFragments.push(`${quotedField}=${escapedValue}`);\n    }\n\n    return Utils.joinSQLFragments([\n      'UPDATE',\n      this.quoteTable(tableName),\n      'SET',\n      updateSetSqlFragments.join(','),\n      outputFragment,\n      this.whereQuery(where),\n      returningFragment\n    ]);\n  }\n\n  /*\n    Returns an add index query.\n    Parameters:\n      - tableName -> Name of an existing table, possibly with schema.\n      - options:\n        - type: UNIQUE|FULLTEXT|SPATIAL\n        - name: The name of the index. Default is <table>_<attr1>_<attr2>\n        - fields: An array of attributes as string or as hash.\n                  If the attribute is a hash, it must have the following content:\n                  - name: The name of the attribute/column\n                  - length: An integer. Optional\n                  - order: 'ASC' or 'DESC'. Optional\n        - parser\n        - using\n        - operator\n        - concurrently: Pass CONCURRENT so other operations run while the index is created\n      - rawTablename, the name of the table, without schema. Used to create the name of the index\n   @private\n  */\n  addIndexQuery(tableName, attributes, options, rawTablename) {\n    options = options || {};\n\n    if (!Array.isArray(attributes)) {\n      options = attributes;\n      attributes = undefined;\n    } else {\n      options.fields = attributes;\n    }\n\n    options.prefix = options.prefix || rawTablename || tableName;\n    if (options.prefix && typeof options.prefix === 'string') {\n      options.prefix = options.prefix.replace(/\\./g, '_');\n      options.prefix = options.prefix.replace(/(\"|')/g, '');\n    }\n\n    const fieldsSql = options.fields.map(field => {\n      if (field instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(field);\n      }\n      if (typeof field === 'string') {\n        field = {\n          name: field\n        };\n      }\n      let result = '';\n\n      if (field.attribute) {\n        field.name = field.attribute;\n      }\n\n      if (!field.name) {\n        throw new Error(`The following index field has no name: ${util.inspect(field)}`);\n      }\n\n      result += this.quoteIdentifier(field.name);\n\n      if (this._dialect.supports.index.collate && field.collate) {\n        result += ` COLLATE ${this.quoteIdentifier(field.collate)}`;\n      }\n\n      if (this._dialect.supports.index.operator) {\n        const operator = field.operator || options.operator;\n        if (operator) {\n          result += ` ${operator}`;\n        }\n      }\n\n      if (this._dialect.supports.index.length && field.length) {\n        result += `(${field.length})`;\n      }\n\n      if (field.order) {\n        result += ` ${field.order}`;\n      }\n\n      return result;\n    });\n\n    if (!options.name) {\n      // Mostly for cases where addIndex is called directly by the user without an options object (for example in migrations)\n      // All calls that go through sequelize should already have a name\n      options = Utils.nameIndex(options, options.prefix);\n    }\n\n    options = Model._conformIndex(options);\n\n    if (!this._dialect.supports.index.type) {\n      delete options.type;\n    }\n\n    if (options.where) {\n      options.where = this.whereQuery(options.where);\n    }\n\n    if (typeof tableName === 'string') {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n\n    const concurrently = this._dialect.supports.index.concurrently && options.concurrently ? 'CONCURRENTLY' : undefined;\n    let ind;\n    if (this._dialect.supports.indexViaAlter) {\n      ind = [\n        'ALTER TABLE',\n        tableName,\n        concurrently,\n        'ADD'\n      ];\n    } else {\n      ind = ['CREATE'];\n    }\n\n    ind = ind.concat(\n      options.unique ? 'UNIQUE' : '',\n      options.type, 'INDEX',\n      !this._dialect.supports.indexViaAlter ? concurrently : undefined,\n      this.quoteIdentifiers(options.name),\n      this._dialect.supports.index.using === 1 && options.using ? `USING ${options.using}` : '',\n      !this._dialect.supports.indexViaAlter ? `ON ${tableName}` : undefined,\n      this._dialect.supports.index.using === 2 && options.using ? `USING ${options.using}` : '',\n      `(${fieldsSql.join(', ')})`,\n      this._dialect.supports.index.parser && options.parser ? `WITH PARSER ${options.parser}` : undefined,\n      this._dialect.supports.index.where && options.where ? options.where : undefined\n    );\n\n    return _.compact(ind).join(' ');\n  }\n\n  addConstraintQuery(tableName, options) {\n    if (typeof tableName === 'string') {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      tableName,\n      'ADD',\n      this.getConstraintSnippet(tableName, options || {}),\n      ';'\n    ]);\n  }\n\n  getConstraintSnippet(tableName, options) {\n    let constraintSnippet, constraintName;\n\n    const fieldsSql = options.fields.map(field => {\n      if (typeof field === 'string') {\n        return this.quoteIdentifier(field);\n      }\n      if (field instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(field);\n      }\n      if (field.attribute) {\n        field.name = field.attribute;\n      }\n\n      if (!field.name) {\n        throw new Error(`The following index field has no name: ${field}`);\n      }\n\n      return this.quoteIdentifier(field.name);\n    });\n\n    const fieldsSqlQuotedString = fieldsSql.join(', ');\n    const fieldsSqlString = fieldsSql.join('_');\n\n    switch (options.type.toUpperCase()) {\n      case 'UNIQUE':\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_uk`);\n        constraintSnippet = `CONSTRAINT ${constraintName} UNIQUE (${fieldsSqlQuotedString})`;\n        break;\n      case 'CHECK':\n        options.where = this.whereItemsQuery(options.where);\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_ck`);\n        constraintSnippet = `CONSTRAINT ${constraintName} CHECK (${options.where})`;\n        break;\n      case 'DEFAULT':\n        if (options.defaultValue === undefined) {\n          throw new Error('Default value must be specifed for DEFAULT CONSTRAINT');\n        }\n\n        if (this._dialect.name !== 'mssql') {\n          throw new Error('Default constraints are supported only for MSSQL dialect.');\n        }\n\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_df`);\n        constraintSnippet = `CONSTRAINT ${constraintName} DEFAULT (${this.escape(options.defaultValue)}) FOR ${fieldsSql[0]}`;\n        break;\n      case 'PRIMARY KEY':\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_pk`);\n        constraintSnippet = `CONSTRAINT ${constraintName} PRIMARY KEY (${fieldsSqlQuotedString})`;\n        break;\n      case 'FOREIGN KEY':\n        const references = options.references;\n        if (!references || !references.table || !(references.field || references.fields)) {\n          throw new Error('references object with table and field must be specified');\n        }\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_${references.table}_fk`);\n        const quotedReferences =\n          typeof references.field !== 'undefined'\n            ? this.quoteIdentifier(references.field)\n            : references.fields.map(f => this.quoteIdentifier(f)).join(', ');\n        const referencesSnippet = `${this.quoteTable(references.table)} (${quotedReferences})`;\n        constraintSnippet = `CONSTRAINT ${constraintName} `;\n        constraintSnippet += `FOREIGN KEY (${fieldsSqlQuotedString}) REFERENCES ${referencesSnippet}`;\n        if (options.onUpdate) {\n          constraintSnippet += ` ON UPDATE ${options.onUpdate.toUpperCase()}`;\n        }\n        if (options.onDelete) {\n          constraintSnippet += ` ON DELETE ${options.onDelete.toUpperCase()}`;\n        }\n        break;\n      default: throw new Error(`${options.type} is invalid.`);\n    }\n\n    if (options.deferrable && ['UNIQUE', 'PRIMARY KEY', 'FOREIGN KEY'].includes(options.type.toUpperCase())) {\n      constraintSnippet += ` ${this.deferConstraintsQuery(options)}`;\n    }\n\n    return constraintSnippet;\n  }\n\n  removeConstraintQuery(tableName, constraintName) {\n    if (typeof tableName === 'string') {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      tableName,\n      'DROP CONSTRAINT',\n      this.quoteIdentifiers(constraintName)\n    ]);\n  }\n\n  /*\n    Quote an object based on its type. This is a more general version of quoteIdentifiers\n    Strings: should proxy to quoteIdentifiers\n    Arrays:\n      * Expects array in the form: [<model> (optional), <model> (optional),... String, String (optional)]\n        Each <model> can be a model, or an object {model: Model, as: String}, matching include, or an\n        association object, or the name of an association.\n      * Zero or more models can be included in the array and are used to trace a path through the tree of\n        included nested associations. This produces the correct table name for the ORDER BY/GROUP BY SQL\n        and quotes it.\n      * If a single string is appended to end of array, it is quoted.\n        If two strings appended, the 1st string is quoted, the 2nd string unquoted.\n    Objects:\n      * If raw is set, that value should be returned verbatim, without quoting\n      * If fn is set, the string should start with the value of fn, starting paren, followed by\n        the values of cols (which is assumed to be an array), quoted and joined with ', ',\n        unless they are themselves objects\n      * If direction is set, should be prepended\n\n    Currently this function is only used for ordering / grouping columns and Sequelize.col(), but it could\n    potentially also be used for other places where we want to be able to call SQL functions (e.g. as default values)\n   @private\n  */\n  quote(collection, parent, connector) {\n    // init\n    const validOrderOptions = [\n      'ASC',\n      'DESC',\n      'ASC NULLS LAST',\n      'DESC NULLS LAST',\n      'ASC NULLS FIRST',\n      'DESC NULLS FIRST',\n      'NULLS FIRST',\n      'NULLS LAST'\n    ];\n\n    // default\n    connector = connector || '.';\n\n    // just quote as identifiers if string\n    if (typeof collection === 'string') {\n      return this.quoteIdentifiers(collection);\n    }\n    if (Array.isArray(collection)) {\n      // iterate through the collection and mutate objects into associations\n      collection.forEach((item, index) => {\n        const previous = collection[index - 1];\n        let previousAssociation;\n        let previousModel;\n\n        // set the previous as the parent when previous is undefined or the target of the association\n        if (!previous && parent !== undefined) {\n          previousModel = parent;\n        } else if (previous && previous instanceof Association) {\n          previousAssociation = previous;\n          previousModel = previous.target;\n        }\n\n        // if the previous item is a model, then attempt getting an association\n        if (previousModel && previousModel.prototype instanceof Model) {\n          let model;\n          let as;\n\n          if (typeof item === 'function' && item.prototype instanceof Model) {\n            // set\n            model = item;\n          } else if (_.isPlainObject(item) && item.model && item.model.prototype instanceof Model) {\n            // set\n            model = item.model;\n            as = item.as;\n          }\n\n          if (model) {\n            // set the as to either the through name or the model name\n            if (!as && previousAssociation && previousAssociation instanceof Association && previousAssociation.through && previousAssociation.through.model === model) {\n              // get from previous association\n              item = new Association(previousModel, model, {\n                as: model.name\n              });\n            } else {\n              // get association from previous model\n              item = previousModel.getAssociationForAlias(model, as);\n\n              // attempt to use the model name if the item is still null\n              if (!item) {\n                item = previousModel.getAssociationForAlias(model, model.name);\n              }\n            }\n\n            // make sure we have an association\n            if (!(item instanceof Association)) {\n              throw new Error(util.format('Unable to find a valid association for model, \\'%s\\'', model.name));\n            }\n          }\n        }\n\n        if (typeof item === 'string') {\n          // get order index\n          const orderIndex = validOrderOptions.indexOf(item.toUpperCase());\n\n          // see if this is an order\n          if (index > 0 && orderIndex !== -1) {\n            item = this.sequelize.literal(` ${validOrderOptions[orderIndex]}`);\n          } else if (previousModel && previousModel.prototype instanceof Model) {\n            // only go down this path if we have preivous model and check only once\n            if (previousModel.associations !== undefined && previousModel.associations[item]) {\n              // convert the item to an association\n              item = previousModel.associations[item];\n            } else if (previousModel.rawAttributes !== undefined && previousModel.rawAttributes[item] && item !== previousModel.rawAttributes[item].field) {\n              // convert the item attribute from its alias\n              item = previousModel.rawAttributes[item].field;\n            } else if (\n              item.includes('.')\n              && previousModel.rawAttributes !== undefined\n            ) {\n              const itemSplit = item.split('.');\n\n              if (previousModel.rawAttributes[itemSplit[0]].type instanceof DataTypes.JSON) {\n                // just quote identifiers for now\n                const identifier = this.quoteIdentifiers(`${previousModel.name}.${previousModel.rawAttributes[itemSplit[0]].field}`);\n\n                // get path\n                const path = itemSplit.slice(1);\n\n                // extract path\n                item = this.jsonPathExtractionQuery(identifier, path);\n\n                // literal because we don't want to append the model name when string\n                item = this.sequelize.literal(item);\n              }\n            }\n          }\n        }\n\n        collection[index] = item;\n      }, this);\n\n      // loop through array, adding table names of models to quoted\n      const collectionLength = collection.length;\n      const tableNames = [];\n      let item;\n      let i = 0;\n\n      for (i = 0; i < collectionLength - 1; i++) {\n        item = collection[i];\n        if (typeof item === 'string' || item._modelAttribute || item instanceof Utils.SequelizeMethod) {\n          break;\n        } else if (item instanceof Association) {\n          tableNames[i] = item.as;\n        }\n      }\n\n      // start building sql\n      let sql = '';\n\n      if (i > 0) {\n        sql += `${this.quoteIdentifier(tableNames.join(connector))}.`;\n      } else if (typeof collection[0] === 'string' && parent) {\n        sql += `${this.quoteIdentifier(parent.name)}.`;\n      }\n\n      // loop through everything past i and append to the sql\n      collection.slice(i).forEach(collectionItem => {\n        sql += this.quote(collectionItem, parent, connector);\n      }, this);\n\n      return sql;\n    }\n    if (collection._modelAttribute) {\n      return `${this.quoteTable(collection.Model.name)}.${this.quoteIdentifier(collection.fieldName)}`;\n    }\n    if (collection instanceof Utils.SequelizeMethod) {\n      return this.handleSequelizeMethod(collection);\n    }\n    if (_.isPlainObject(collection) && collection.raw) {\n      // simple objects with raw is no longer supported\n      throw new Error('The `{raw: \"...\"}` syntax is no longer supported.  Use `sequelize.literal` instead.');\n    }\n    throw new Error(`Unknown structure passed to order / group: ${util.inspect(collection)}`);\n  }\n\n  /**\n   * Split a list of identifiers by \".\" and quote each part\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    return QuoteHelper.quoteIdentifier(this.dialect, identifier, {\n      force,\n      quoteIdentifiers: this.options.quoteIdentifiers\n    });\n  }\n\n  quoteIdentifiers(identifiers) {\n    if (identifiers.includes('.')) {\n      identifiers = identifiers.split('.');\n\n      const head = identifiers.slice(0, identifiers.length - 1).join('->');\n      const tail = identifiers[identifiers.length - 1];\n\n      return `${this.quoteIdentifier(head)}.${this.quoteIdentifier(tail)}`;\n    }\n\n    return this.quoteIdentifier(identifiers);\n  }\n\n  quoteAttribute(attribute, model) {\n    if (model && attribute in model.rawAttributes) {\n      return this.quoteIdentifier(attribute);\n    }\n    return this.quoteIdentifiers(attribute);\n  }\n\n  /**\n   * Quote table name with optional alias and schema attribution\n   *\n   * @param {string|object}  param table string or object\n   * @param {string|boolean} alias alias name\n   *\n   * @returns {string}\n   */\n  quoteTable(param, alias) {\n    let table = '';\n\n    if (alias === true) {\n      alias = param.as || param.name || param;\n    }\n\n    if (_.isObject(param)) {\n      if (this._dialect.supports.schemas) {\n        if (param.schema) {\n          table += `${this.quoteIdentifier(param.schema)}.`;\n        }\n\n        table += this.quoteIdentifier(param.tableName);\n      } else {\n        if (param.schema) {\n          table += param.schema + (param.delimiter || '.');\n        }\n\n        table += param.tableName;\n        table = this.quoteIdentifier(table);\n      }\n    } else {\n      table = this.quoteIdentifier(param);\n    }\n\n    if (alias) {\n      table += ` AS ${this.quoteIdentifier(alias)}`;\n    }\n\n    return table;\n  }\n\n  /*\n    Escape a value (e.g. a string, number or date)\n    @private\n  */\n  escape(value, field, options) {\n    options = options || {};\n\n    if (value !== null && value !== undefined) {\n      if (value instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(value);\n      }\n      if (field && field.type) {\n        this.validate(value, field, options);\n\n        if (field.type.stringify) {\n          // Users shouldn't have to worry about these args - just give them a function that takes a single arg\n          const simpleEscape = escVal => SqlString.escape(escVal, this.options.timezone, this.dialect);\n\n          value = field.type.stringify(value, { escape: simpleEscape, field, timezone: this.options.timezone, operation: options.operation });\n\n          if (field.type.escape === false) {\n            // The data-type already did the required escaping\n            return value;\n          }\n        }\n      }\n    }\n    return SqlString.escape(value, this.options.timezone, this.dialect);\n  }\n\n  bindParam(bind) {\n    return value => {\n      bind.push(value);\n      return `$${bind.length}`;\n    };\n  }\n\n  /*\n    Returns a bind parameter representation of a value (e.g. a string, number or date)\n    @private\n  */\n  format(value, field, options, bindParam) {\n    options = options || {};\n\n    if (value !== null && value !== undefined) {\n      if (value instanceof Utils.SequelizeMethod) {\n        throw new Error('Cannot pass SequelizeMethod as a bind parameter - use escape instead');\n      }\n      if (field && field.type) {\n        this.validate(value, field, options);\n\n        if (field.type.bindParam) {\n          return field.type.bindParam(value, { escape: _.identity, field, timezone: this.options.timezone, operation: options.operation, bindParam });\n        }\n      }\n    }\n\n    return bindParam(value);\n  }\n\n  /*\n    Validate a value against a field specification\n    @private\n  */\n  validate(value, field, options) {\n    if (this.typeValidation && field.type.validate && value) {\n      try {\n        if (options.isList && Array.isArray(value)) {\n          for (const item of value) {\n            field.type.validate(item, options);\n          }\n        } else {\n          field.type.validate(value, options);\n        }\n      } catch (error) {\n        if (error instanceof sequelizeError.ValidationError) {\n          error.errors.push(new sequelizeError.ValidationErrorItem(\n            error.message,\n            'Validation error',\n            field.fieldName,\n            value,\n            null,\n            `${field.type.key} validator`\n          ));\n        }\n\n        throw error;\n      }\n    }\n  }\n\n  isIdentifierQuoted(identifier) {\n    return QuoteHelper.isIdentifierQuoted(identifier);\n  }\n\n  /**\n   * Generates an SQL query that extract JSON property of given path.\n   *\n   * @param   {string}               column  The JSON column\n   * @param   {string|Array<string>} [path]  The path to extract (optional)\n   * @returns {string}                       The generated sql query\n   * @private\n   */\n  jsonPathExtractionQuery(column, path) {\n    let paths = _.toPath(path);\n    let pathStr;\n    const quotedColumn = this.isIdentifierQuoted(column)\n      ? column\n      : this.quoteIdentifier(column);\n\n    switch (this.dialect) {\n      case 'mysql':\n      case 'mariadb':\n      case 'sqlite':\n        /**\n         * Non digit sub paths need to be quoted as ECMAScript identifiers\n         * https://bugs.mysql.com/bug.php?id=81896\n         */\n        if (this.dialect === 'mysql') {\n          paths = paths.map(subPath => {\n            return /\\D/.test(subPath)\n              ? Utils.addTicks(subPath, '\"')\n              : subPath;\n          });\n        }\n\n        pathStr = this.escape(['$']\n          .concat(paths)\n          .join('.')\n          .replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (__, digit) => `[${digit}]`));\n\n        if (this.dialect === 'sqlite') {\n          return `json_extract(${quotedColumn},${pathStr})`;\n        }\n\n        return `json_unquote(json_extract(${quotedColumn},${pathStr}))`;\n\n      case 'postgres':\n        pathStr = this.escape(`{${paths.join(',')}}`);\n        return `(${quotedColumn}#>>${pathStr})`;\n\n      default:\n        throw new Error(`Unsupported ${this.dialect} for JSON operations`);\n    }\n  }\n\n  /*\n    Returns a query for selecting elements in the table <tableName>.\n    Options:\n      - attributes -> An array of attributes (e.g. ['name', 'birthday']). Default: *\n      - where -> A hash with conditions (e.g. {name: 'foo'})\n                 OR an ID as integer\n      - order -> e.g. 'id DESC'\n      - group\n      - limit -> The maximum count you want to get.\n      - offset -> An offset value to start from. Only useable with limit!\n   @private\n  */\n  selectQuery(tableName, options, model) {\n    options = options || {};\n    const limit = options.limit;\n    const mainQueryItems = [];\n    const subQueryItems = [];\n    const subQuery = options.subQuery === undefined ? limit && options.hasMultiAssociation : options.subQuery;\n    const attributes = {\n      main: options.attributes && options.attributes.slice(),\n      subQuery: null\n    };\n    const mainTable = {\n      name: tableName,\n      quotedName: null,\n      as: null,\n      model\n    };\n    const topLevelInfo = {\n      names: mainTable,\n      options,\n      subQuery\n    };\n    let mainJoinQueries = [];\n    let subJoinQueries = [];\n    let query;\n\n    // Aliases can be passed through subqueries and we don't want to reset them\n    if (this.options.minifyAliases && !options.aliasesMapping) {\n      options.aliasesMapping = new Map();\n      options.aliasesByTable = {};\n      options.includeAliases = new Map();\n    }\n\n    // resolve table name options\n    if (options.tableAs) {\n      mainTable.as = this.quoteIdentifier(options.tableAs);\n    } else if (!Array.isArray(mainTable.name) && mainTable.model) {\n      mainTable.as = this.quoteIdentifier(mainTable.model.name);\n    }\n\n    mainTable.quotedName = !Array.isArray(mainTable.name) ? this.quoteTable(mainTable.name) : tableName.map(t => {\n      return Array.isArray(t) ? this.quoteTable(t[0], t[1]) : this.quoteTable(t, true);\n    }).join(', ');\n\n    if (subQuery && attributes.main) {\n      for (const keyAtt of mainTable.model.primaryKeyAttributes) {\n        // Check if mainAttributes contain the primary key of the model either as a field or an aliased field\n        if (!attributes.main.some(attr => keyAtt === attr || keyAtt === attr[0] || keyAtt === attr[1])) {\n          attributes.main.push(mainTable.model.rawAttributes[keyAtt].field ? [keyAtt, mainTable.model.rawAttributes[keyAtt].field] : keyAtt);\n        }\n      }\n    }\n\n    attributes.main = this.escapeAttributes(attributes.main, options, mainTable.as);\n    attributes.main = attributes.main || (options.include ? [`${mainTable.as}.*`] : ['*']);\n\n    // If subquery, we add the mainAttributes to the subQuery and set the mainAttributes to select * from subquery\n    if (subQuery || options.groupedLimit) {\n      // We need primary keys\n      attributes.subQuery = attributes.main;\n      attributes.main = [`${mainTable.as || mainTable.quotedName}.*`];\n    }\n\n    if (options.include) {\n      for (const include of options.include) {\n        if (include.separate) {\n          continue;\n        }\n        const joinQueries = this.generateInclude(include, { externalAs: mainTable.as, internalAs: mainTable.as }, topLevelInfo);\n\n        subJoinQueries = subJoinQueries.concat(joinQueries.subQuery);\n        mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n\n        if (joinQueries.attributes.main.length > 0) {\n          attributes.main = _.uniq(attributes.main.concat(joinQueries.attributes.main));\n        }\n        if (joinQueries.attributes.subQuery.length > 0) {\n          attributes.subQuery = _.uniq(attributes.subQuery.concat(joinQueries.attributes.subQuery));\n        }\n      }\n    }\n\n    if (subQuery) {\n      subQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.subQuery, mainTable.quotedName, mainTable.as));\n      subQueryItems.push(subJoinQueries.join(''));\n    } else {\n      if (options.groupedLimit) {\n        if (!mainTable.as) {\n          mainTable.as = mainTable.quotedName;\n        }\n        const where = { ...options.where };\n        let groupedLimitOrder,\n          whereKey,\n          include,\n          groupedTableName = mainTable.as;\n\n        if (typeof options.groupedLimit.on === 'string') {\n          whereKey = options.groupedLimit.on;\n        } else if (options.groupedLimit.on instanceof HasMany) {\n          whereKey = options.groupedLimit.on.foreignKeyField;\n        }\n\n        if (options.groupedLimit.on instanceof BelongsToMany) {\n          // BTM includes needs to join the through table on to check ID\n          groupedTableName = options.groupedLimit.on.manyFromSource.as;\n          const groupedLimitOptions = Model._validateIncludedElements({\n            include: [{\n              association: options.groupedLimit.on.manyFromSource,\n              duplicating: false, // The UNION'ed query may contain duplicates, but each sub-query cannot\n              required: true,\n              where: {\n                [Op.placeholder]: true,\n                ...options.groupedLimit.through && options.groupedLimit.through.where\n              }\n            }],\n            model\n          });\n\n          // Make sure attributes from the join table are mapped back to models\n          options.hasJoin = true;\n          options.hasMultiAssociation = true;\n          options.includeMap = Object.assign(groupedLimitOptions.includeMap, options.includeMap);\n          options.includeNames = groupedLimitOptions.includeNames.concat(options.includeNames || []);\n          include = groupedLimitOptions.include;\n\n          if (Array.isArray(options.order)) {\n            // We need to make sure the order by attributes are available to the parent query\n            options.order.forEach((order, i) => {\n              if (Array.isArray(order)) {\n                order = order[0];\n              }\n\n              let alias = `subquery_order_${i}`;\n              options.attributes.push([order, alias]);\n\n              // We don't want to prepend model name when we alias the attributes, so quote them here\n              alias = this.sequelize.literal(this.quote(alias));\n\n              if (Array.isArray(options.order[i])) {\n                options.order[i][0] = alias;\n              } else {\n                options.order[i] = alias;\n              }\n            });\n            groupedLimitOrder = options.order;\n          }\n        } else {\n          // Ordering is handled by the subqueries, so ordering the UNION'ed result is not needed\n          groupedLimitOrder = options.order;\n          delete options.order;\n          where[Op.placeholder] = true;\n        }\n\n        // Caching the base query and splicing the where part into it is consistently > twice\n        // as fast than generating from scratch each time for values.length >= 5\n        const baseQuery = `SELECT * FROM (${this.selectQuery(\n          tableName,\n          {\n            attributes: options.attributes,\n            offset: options.offset,\n            limit: options.groupedLimit.limit,\n            order: groupedLimitOrder,\n            aliasesMapping: options.aliasesMapping,\n            aliasesByTable: options.aliasesByTable,\n            where,\n            include,\n            model\n          },\n          model\n        ).replace(/;$/, '')}) AS sub`; // Every derived table must have its own alias\n        const placeHolder = this.whereItemQuery(Op.placeholder, true, { model });\n        const splicePos = baseQuery.indexOf(placeHolder);\n\n        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, `(${\n          options.groupedLimit.values.map(value => {\n            let groupWhere;\n            if (whereKey) {\n              groupWhere = {\n                [whereKey]: value\n              };\n            }\n            if (include) {\n              groupWhere = {\n                [options.groupedLimit.on.foreignIdentifierField]: value\n              };\n            }\n\n            return Utils.spliceStr(baseQuery, splicePos, placeHolder.length, this.getWhereConditions(groupWhere, groupedTableName));\n          }).join(\n            this._dialect.supports['UNION ALL'] ? ' UNION ALL ' : ' UNION '\n          )\n        })`, mainTable.as));\n      } else {\n        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, mainTable.quotedName, mainTable.as));\n      }\n\n      mainQueryItems.push(mainJoinQueries.join(''));\n    }\n\n    // Add WHERE to sub or main query\n    if (Object.prototype.hasOwnProperty.call(options, 'where') && !options.groupedLimit) {\n      options.where = this.getWhereConditions(options.where, mainTable.as || tableName, model, options);\n      if (options.where) {\n        if (subQuery) {\n          subQueryItems.push(` WHERE ${options.where}`);\n        } else {\n          mainQueryItems.push(` WHERE ${options.where}`);\n          // Walk the main query to update all selects\n          mainQueryItems.forEach((value, key) => {\n            if (value.startsWith('SELECT')) {\n              mainQueryItems[key] = this.selectFromTableFragment(options, model, attributes.main, mainTable.quotedName, mainTable.as, options.where);\n            }\n          });\n        }\n      }\n    }\n\n    // Add GROUP BY to sub or main query\n    if (options.group) {\n      options.group = Array.isArray(options.group) ? options.group.map(t => this.aliasGrouping(t, model, mainTable.as, options)).join(', ') : this.aliasGrouping(options.group, model, mainTable.as, options);\n\n      if (subQuery && options.group) {\n        subQueryItems.push(` GROUP BY ${options.group}`);\n      } else if (options.group) {\n        mainQueryItems.push(` GROUP BY ${options.group}`);\n      }\n    }\n\n    // Add HAVING to sub or main query\n    if (Object.prototype.hasOwnProperty.call(options, 'having')) {\n      options.having = this.getWhereConditions(options.having, tableName, model, options, false);\n      if (options.having) {\n        if (subQuery) {\n          subQueryItems.push(` HAVING ${options.having}`);\n        } else {\n          mainQueryItems.push(` HAVING ${options.having}`);\n        }\n      }\n    }\n\n    // Add ORDER to sub or main query\n    if (options.order) {\n      const orders = this.getQueryOrders(options, model, subQuery);\n      if (orders.mainQueryOrder.length) {\n        mainQueryItems.push(` ORDER BY ${orders.mainQueryOrder.join(', ')}`);\n      }\n      if (orders.subQueryOrder.length) {\n        subQueryItems.push(` ORDER BY ${orders.subQueryOrder.join(', ')}`);\n      }\n    }\n\n    // Add LIMIT, OFFSET to sub or main query\n    const limitOrder = this.addLimitAndOffset(options, mainTable.model);\n    if (limitOrder && !options.groupedLimit) {\n      if (subQuery) {\n        subQueryItems.push(limitOrder);\n      } else {\n        mainQueryItems.push(limitOrder);\n      }\n    }\n\n    if (subQuery) {\n      this._throwOnEmptyAttributes(attributes.main, { modelName: model && model.name, as: mainTable.as });\n      query = `SELECT ${attributes.main.join(', ')} FROM (${subQueryItems.join('')}) AS ${mainTable.as}${mainJoinQueries.join('')}${mainQueryItems.join('')}`;\n    } else {\n      query = mainQueryItems.join('');\n    }\n\n    if (options.lock && this._dialect.supports.lock) {\n      let lock = options.lock;\n      if (typeof options.lock === 'object') {\n        lock = options.lock.level;\n      }\n      if (this._dialect.supports.lockKey && (lock === 'KEY SHARE' || lock === 'NO KEY UPDATE')) {\n        query += ` FOR ${lock}`;\n      } else if (lock === 'SHARE') {\n        query += ` ${this._dialect.supports.forShare}`;\n      } else {\n        query += ' FOR UPDATE';\n      }\n      if (this._dialect.supports.lockOf && options.lock.of && options.lock.of.prototype instanceof Model) {\n        query += ` OF ${this.quoteTable(options.lock.of.name)}`;\n      }\n      if (this._dialect.supports.skipLocked && options.skipLocked) {\n        query += ' SKIP LOCKED';\n      }\n    }\n\n    return `${query};`;\n  }\n\n  aliasGrouping(field, model, tableName, options) {\n    const src = Array.isArray(field) ? field[0] : field;\n\n    return this.quote(this._getAliasForField(tableName, src, options) || src, model);\n  }\n\n  escapeAttributes(attributes, options, mainTableAs) {\n    return attributes && attributes.map(attr => {\n      let addTable = true;\n\n      if (attr instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(attr);\n      }\n      if (Array.isArray(attr)) {\n        if (attr.length !== 2) {\n          throw new Error(`${JSON.stringify(attr)} is not a valid attribute definition. Please use the following format: ['attribute definition', 'alias']`);\n        }\n        attr = attr.slice();\n\n        if (attr[0] instanceof Utils.SequelizeMethod) {\n          attr[0] = this.handleSequelizeMethod(attr[0]);\n          addTable = false;\n        } else if (!attr[0].includes('(') && !attr[0].includes(')')) {\n          attr[0] = this.quoteIdentifier(attr[0]);\n        } else {\n          deprecations.noRawAttributes();\n        }\n        let alias = attr[1];\n\n        if (this.options.minifyAliases) {\n          alias = this._getMinifiedAlias(alias, mainTableAs, options);\n        }\n\n        attr = [attr[0], this.quoteIdentifier(alias)].join(' AS ');\n      } else {\n        attr = !attr.includes(Utils.TICK_CHAR) && !attr.includes('\"')\n          ? this.quoteAttribute(attr, options.model)\n          : this.escape(attr);\n      }\n      if (!_.isEmpty(options.include) && (!attr.includes('.') || options.dotNotation) && addTable) {\n        attr = `${mainTableAs}.${attr}`;\n      }\n\n      return attr;\n    });\n  }\n\n  generateInclude(include, parentTableName, topLevelInfo) {\n    const joinQueries = {\n      mainQuery: [],\n      subQuery: []\n    };\n    const mainChildIncludes = [];\n    const subChildIncludes = [];\n    let requiredMismatch = false;\n    const includeAs = {\n      internalAs: include.as,\n      externalAs: include.as\n    };\n    const attributes = {\n      main: [],\n      subQuery: []\n    };\n    let joinQuery;\n\n    topLevelInfo.options.keysEscaped = true;\n\n    if (topLevelInfo.names.name !== parentTableName.externalAs && topLevelInfo.names.as !== parentTableName.externalAs) {\n      includeAs.internalAs = `${parentTableName.internalAs}->${include.as}`;\n      includeAs.externalAs = `${parentTableName.externalAs}.${include.as}`;\n    }\n\n    // includeIgnoreAttributes is used by aggregate functions\n    if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n      include.model._expandAttributes(include);\n      Utils.mapFinderOptions(include, include.model);\n\n      const includeAttributes = include.attributes.map(attr => {\n        let attrAs = attr;\n        let verbatim = false;\n\n        if (Array.isArray(attr) && attr.length === 2) {\n          if (attr[0] instanceof Utils.SequelizeMethod && (\n            attr[0] instanceof Utils.Literal ||\n            attr[0] instanceof Utils.Cast ||\n            attr[0] instanceof Utils.Fn\n          )) {\n            verbatim = true;\n          }\n\n          attr = attr.map(attr => attr instanceof Utils.SequelizeMethod ? this.handleSequelizeMethod(attr) : attr);\n\n          attrAs = attr[1];\n          attr = attr[0];\n        }\n        if (attr instanceof Utils.Literal) {\n          return attr.val; // We trust the user to rename the field correctly\n        }\n        if (attr instanceof Utils.Cast || attr instanceof Utils.Fn) {\n          throw new Error(\n            'Tried to select attributes using Sequelize.cast or Sequelize.fn without specifying an alias for the result, during eager loading. ' +\n            'This means the attribute will not be added to the returned instance'\n          );\n        }\n\n        let prefix;\n        if (verbatim === true) {\n          prefix = attr;\n        } else if (/#>>|->>/.test(attr)) {\n          prefix = `(${this.quoteIdentifier(includeAs.internalAs)}.${attr.replace(/\\(|\\)/g, '')})`;\n        } else if (/json_extract\\(/.test(attr)) {\n          prefix = attr.replace(/json_extract\\(/i, `json_extract(${this.quoteIdentifier(includeAs.internalAs)}.`);\n        } else {\n          prefix = `${this.quoteIdentifier(includeAs.internalAs)}.${this.quoteIdentifier(attr)}`;\n        }\n        let alias = `${includeAs.externalAs}.${attrAs}`;\n\n        if (this.options.minifyAliases) {\n          alias = this._getMinifiedAlias(alias, includeAs.internalAs, topLevelInfo.options);\n        }\n\n        return Utils.joinSQLFragments([\n          prefix,\n          'AS',\n          this.quoteIdentifier(alias, true)\n        ]);\n      });\n      if (include.subQuery && topLevelInfo.subQuery) {\n        for (const attr of includeAttributes) {\n          attributes.subQuery.push(attr);\n        }\n      } else {\n        for (const attr of includeAttributes) {\n          attributes.main.push(attr);\n        }\n      }\n    }\n\n    //through\n    if (include.through) {\n      joinQuery = this.generateThroughJoin(include, includeAs, parentTableName.internalAs, topLevelInfo);\n    } else {\n      this._generateSubQueryFilter(include, includeAs, topLevelInfo);\n      joinQuery = this.generateJoin(include, topLevelInfo);\n    }\n\n    // handle possible new attributes created in join\n    if (joinQuery.attributes.main.length > 0) {\n      attributes.main = attributes.main.concat(joinQuery.attributes.main);\n    }\n\n    if (joinQuery.attributes.subQuery.length > 0) {\n      attributes.subQuery = attributes.subQuery.concat(joinQuery.attributes.subQuery);\n    }\n\n    if (include.include) {\n      for (const childInclude of include.include) {\n        if (childInclude.separate || childInclude._pseudo) {\n          continue;\n        }\n\n        const childJoinQueries = this.generateInclude(childInclude, includeAs, topLevelInfo);\n\n        if (include.required === false && childInclude.required === true) {\n          requiredMismatch = true;\n        }\n        // if the child is a sub query we just give it to the\n        if (childInclude.subQuery && topLevelInfo.subQuery) {\n          subChildIncludes.push(childJoinQueries.subQuery);\n        }\n        if (childJoinQueries.mainQuery) {\n          mainChildIncludes.push(childJoinQueries.mainQuery);\n        }\n        if (childJoinQueries.attributes.main.length > 0) {\n          attributes.main = attributes.main.concat(childJoinQueries.attributes.main);\n        }\n        if (childJoinQueries.attributes.subQuery.length > 0) {\n          attributes.subQuery = attributes.subQuery.concat(childJoinQueries.attributes.subQuery);\n        }\n      }\n    }\n\n    if (include.subQuery && topLevelInfo.subQuery) {\n      if (requiredMismatch && subChildIncludes.length > 0) {\n        joinQueries.subQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${subChildIncludes.join('')} ) ON ${joinQuery.condition}`);\n      } else {\n        joinQueries.subQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);\n        if (subChildIncludes.length > 0) {\n          joinQueries.subQuery.push(subChildIncludes.join(''));\n        }\n      }\n      joinQueries.mainQuery.push(mainChildIncludes.join(''));\n    } else {\n      if (requiredMismatch && mainChildIncludes.length > 0) {\n        joinQueries.mainQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${mainChildIncludes.join('')} ) ON ${joinQuery.condition}`);\n      } else {\n        joinQueries.mainQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);\n        if (mainChildIncludes.length > 0) {\n          joinQueries.mainQuery.push(mainChildIncludes.join(''));\n        }\n      }\n      joinQueries.subQuery.push(subChildIncludes.join(''));\n    }\n\n    return {\n      mainQuery: joinQueries.mainQuery.join(''),\n      subQuery: joinQueries.subQuery.join(''),\n      attributes\n    };\n  }\n\n  _getMinifiedAlias(alias, tableName, options) {\n    // We do not want to re-alias in case of a subquery\n    if (options.aliasesByTable[`${tableName}${alias}`]) {\n      return options.aliasesByTable[`${tableName}${alias}`];\n    }\n\n    // Do not alias custom suquery_orders\n    if (alias.match(/subquery_order_[0-9]/)) {\n      return alias;\n    }\n\n    const minifiedAlias = `_${options.aliasesMapping.size}`;\n\n    options.aliasesMapping.set(minifiedAlias, alias);\n    options.aliasesByTable[`${tableName}${alias}`] = minifiedAlias;\n\n    return minifiedAlias;\n  }\n\n  _getAliasForField(tableName, field, options) {\n    if (this.options.minifyAliases) {\n      if (options.aliasesByTable[`${tableName}${field}`]) {\n        return options.aliasesByTable[`${tableName}${field}`];\n      }\n    }\n    return null;\n  }\n\n  generateJoin(include, topLevelInfo) {\n    const association = include.association;\n    const parent = include.parent;\n    const parentIsTop = !!parent && !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n    let $parent;\n    let joinWhere;\n    /* Attributes for the left side */\n    const left = association.source;\n    const attrLeft = association instanceof BelongsTo ?\n      association.identifier :\n      association.sourceKeyAttribute || left.primaryKeyAttribute;\n    const fieldLeft = association instanceof BelongsTo ?\n      association.identifierField :\n      left.rawAttributes[association.sourceKeyAttribute || left.primaryKeyAttribute].field;\n    let asLeft;\n    /* Attributes for the right side */\n    const right = include.model;\n    const tableRight = right.getTableName();\n    const fieldRight = association instanceof BelongsTo ?\n      right.rawAttributes[association.targetIdentifier || right.primaryKeyAttribute].field :\n      association.identifierField;\n    let asRight = include.as;\n\n    while (($parent = $parent && $parent.parent || include.parent) && $parent.association) {\n      if (asLeft) {\n        asLeft = `${$parent.as}->${asLeft}`;\n      } else {\n        asLeft = $parent.as;\n      }\n    }\n\n    if (!asLeft) asLeft = parent.as || parent.model.name;\n    else asRight = `${asLeft}->${asRight}`;\n\n    let joinOn = `${this.quoteTable(asLeft)}.${this.quoteIdentifier(fieldLeft)}`;\n    const subqueryAttributes = [];\n\n    if (topLevelInfo.options.groupedLimit && parentIsTop || topLevelInfo.subQuery && include.parent.subQuery && !include.subQuery) {\n      if (parentIsTop) {\n        // The main model attributes is not aliased to a prefix\n        const tableName = this.quoteTable(parent.as || parent.model.name);\n\n        // Check for potential aliased JOIN condition\n        joinOn = this._getAliasForField(tableName, attrLeft, topLevelInfo.options) || `${tableName}.${this.quoteIdentifier(attrLeft)}`;\n\n        if (topLevelInfo.subQuery) {\n          const dbIdentifier = `${tableName}.${this.quoteIdentifier(fieldLeft)}`;\n          subqueryAttributes.push(dbIdentifier !== joinOn ? `${dbIdentifier} AS ${this.quoteIdentifier(attrLeft)}` : dbIdentifier);\n        }\n      } else {\n        const joinSource = `${asLeft.replace(/->/g, '.')}.${attrLeft}`;\n\n        // Check for potential aliased JOIN condition\n        joinOn = this._getAliasForField(asLeft, joinSource, topLevelInfo.options) || this.quoteIdentifier(joinSource);\n      }\n    }\n\n    joinOn += ` = ${this.quoteIdentifier(asRight)}.${this.quoteIdentifier(fieldRight)}`;\n\n    if (include.on) {\n      joinOn = this.whereItemsQuery(include.on, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model\n      });\n    }\n\n    if (include.where) {\n      joinWhere = this.whereItemsQuery(include.where, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model\n      });\n      if (joinWhere) {\n        if (include.or) {\n          joinOn += ` OR ${joinWhere}`;\n        } else {\n          joinOn += ` AND ${joinWhere}`;\n        }\n      }\n    }\n\n    if (this.options.minifyAliases && asRight.length > 63) {\n      const alias = `%${topLevelInfo.options.includeAliases.size}`;\n\n      topLevelInfo.options.includeAliases.set(alias, asRight);\n    }\n\n    return {\n      join: include.required ? 'INNER JOIN' : include.right && this._dialect.supports['RIGHT JOIN'] ? 'RIGHT OUTER JOIN' : 'LEFT OUTER JOIN',\n      body: this.quoteTable(tableRight, asRight),\n      condition: joinOn,\n      attributes: {\n        main: [],\n        subQuery: subqueryAttributes\n      }\n    };\n  }\n\n  /**\n   * Returns the SQL fragments to handle returning the attributes from an insert/update query.\n   *\n   * @param  {object} modelAttributes An object with the model attributes.\n   * @param  {object} options         An object with options.\n   *\n   * @private\n   */\n  generateReturnValues(modelAttributes, options) {\n    const returnFields = [];\n    const returnTypes = [];\n    let outputFragment = '';\n    let returningFragment = '';\n    let tmpTable = '';\n\n    if (Array.isArray(options.returning)) {\n      returnFields.push(...options.returning.map(field => this.quoteIdentifier(field)));\n    } else if (modelAttributes) {\n      _.each(modelAttributes, attribute => {\n        if (!(attribute.type instanceof DataTypes.VIRTUAL)) {\n          returnFields.push(this.quoteIdentifier(attribute.field));\n          returnTypes.push(attribute.type);\n        }\n      });\n    }\n\n    if (_.isEmpty(returnFields)) {\n      returnFields.push('*');\n    }\n\n    if (this._dialect.supports.returnValues.returning) {\n      returningFragment = ` RETURNING ${returnFields.join(',')}`;\n    } else if (this._dialect.supports.returnValues.output) {\n      outputFragment = ` OUTPUT ${returnFields.map(field => `INSERTED.${field}`).join(',')}`;\n\n      //To capture output rows when there is a trigger on MSSQL DB\n      if (options.hasTrigger && this._dialect.supports.tmpTableTrigger) {\n        const tmpColumns = returnFields.map((field, i) => `${field} ${returnTypes[i].toSql()}`);\n\n        tmpTable = `DECLARE @tmp TABLE (${tmpColumns.join(',')}); `;\n        outputFragment += ' INTO @tmp';\n        returningFragment = '; SELECT * FROM @tmp';\n      }\n    }\n\n    return { outputFragment, returnFields, returningFragment, tmpTable };\n  }\n\n  generateThroughJoin(include, includeAs, parentTableName, topLevelInfo) {\n    const through = include.through;\n    const throughTable = through.model.getTableName();\n    const throughAs = `${includeAs.internalAs}->${through.as}`;\n    const externalThroughAs = `${includeAs.externalAs}.${through.as}`;\n    const throughAttributes = through.attributes.map(attr => {\n      let alias = `${externalThroughAs}.${Array.isArray(attr) ? attr[1] : attr}`;\n\n      if (this.options.minifyAliases) {\n        alias = this._getMinifiedAlias(alias, throughAs, topLevelInfo.options);\n      }\n\n      return Utils.joinSQLFragments([\n        `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(Array.isArray(attr) ? attr[0] : attr)}`,\n        'AS',\n        this.quoteIdentifier(alias)\n      ]);\n    });\n    const association = include.association;\n    const parentIsTop = !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n    const tableSource = parentTableName;\n    const identSource = association.identifierField;\n    const tableTarget = includeAs.internalAs;\n    const identTarget = association.foreignIdentifierField;\n    const attrTarget = association.targetKeyField;\n\n    const joinType = include.required ? 'INNER JOIN' : include.right && this._dialect.supports['RIGHT JOIN'] ? 'RIGHT OUTER JOIN' : 'LEFT OUTER JOIN';\n    let joinBody;\n    let joinCondition;\n    const attributes = {\n      main: [],\n      subQuery: []\n    };\n    let attrSource = association.sourceKey;\n    let sourceJoinOn;\n    let targetJoinOn;\n    let throughWhere;\n    let targetWhere;\n\n    if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n      // Through includes are always hasMany, so we need to add the attributes to the mainAttributes no matter what (Real join will never be executed in subquery)\n      for (const attr of throughAttributes) {\n        attributes.main.push(attr);\n      }\n    }\n\n    // Figure out if we need to use field or attribute\n    if (!topLevelInfo.subQuery) {\n      attrSource = association.sourceKeyField;\n    }\n    if (topLevelInfo.subQuery && !include.subQuery && !include.parent.subQuery && include.parent.model !== topLevelInfo.options.mainModel) {\n      attrSource = association.sourceKeyField;\n    }\n\n    // Filter statement for left side of through\n    // Used by both join and subquery where\n    // If parent include was in a subquery need to join on the aliased attribute\n    if (topLevelInfo.subQuery && !include.subQuery && include.parent.subQuery && !parentIsTop) {\n      // If we are minifying aliases and our JOIN target has been minified, we need to use the alias instead of the original column name\n      const joinSource = this._getAliasForField(tableSource, `${tableSource}.${attrSource}`, topLevelInfo.options) || `${tableSource}.${attrSource}`;\n\n      sourceJoinOn = `${this.quoteIdentifier(joinSource)} = `;\n    } else {\n      // If we are minifying aliases and our JOIN target has been minified, we need to use the alias instead of the original column name\n      const aliasedSource = this._getAliasForField(tableSource, attrSource, topLevelInfo.options) || attrSource;\n\n      sourceJoinOn = `${this.quoteTable(tableSource)}.${this.quoteIdentifier(aliasedSource)} = `;\n    }\n    sourceJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identSource)}`;\n\n    // Filter statement for right side of through\n    // Used by both join and subquery where\n    targetJoinOn = `${this.quoteIdentifier(tableTarget)}.${this.quoteIdentifier(attrTarget)} = `;\n    targetJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identTarget)}`;\n\n    if (through.where) {\n      throughWhere = this.getWhereConditions(through.where, this.sequelize.literal(this.quoteIdentifier(throughAs)), through.model);\n    }\n\n    // Generate a wrapped join so that the through table join can be dependent on the target join\n    joinBody = `( ${this.quoteTable(throughTable, throughAs)} INNER JOIN ${this.quoteTable(include.model.getTableName(), includeAs.internalAs)} ON ${targetJoinOn}`;\n    if (throughWhere) {\n      joinBody += ` AND ${throughWhere}`;\n    }\n    joinBody += ')';\n    joinCondition = sourceJoinOn;\n\n    if (include.where || include.through.where) {\n      if (include.where) {\n        targetWhere = this.getWhereConditions(include.where, this.sequelize.literal(this.quoteIdentifier(includeAs.internalAs)), include.model, topLevelInfo.options);\n        if (targetWhere) {\n          joinCondition += ` AND ${targetWhere}`;\n        }\n      }\n    }\n\n    this._generateSubQueryFilter(include, includeAs, topLevelInfo);\n\n    return {\n      join: joinType,\n      body: joinBody,\n      condition: joinCondition,\n      attributes\n    };\n  }\n\n  /*\n   * Generates subQueryFilter - a select nested in the where clause of the subQuery.\n   * For a given include a query is generated that contains all the way from the subQuery\n   * table to the include table plus everything that's in required transitive closure of the\n   * given include.\n   */\n  _generateSubQueryFilter(include, includeAs, topLevelInfo) {\n    if (!topLevelInfo.subQuery || !include.subQueryFilter) {\n      return;\n    }\n\n    if (!topLevelInfo.options.where) {\n      topLevelInfo.options.where = {};\n    }\n    let parent = include;\n    let child = include;\n    let nestedIncludes = this._getRequiredClosure(include).include;\n    let query;\n\n    while ((parent = parent.parent)) { // eslint-disable-line\n      if (parent.parent && !parent.required) {\n        return; // only generate subQueryFilter if all the parents of this include are required\n      }\n\n      if (parent.subQueryFilter) {\n        // the include is already handled as this parent has the include on its required closure\n        // skip to prevent duplicate subQueryFilter\n        return;\n      }\n\n      nestedIncludes = [{ ...child, include: nestedIncludes, attributes: [] }];\n      child = parent;\n    }\n\n    const topInclude = nestedIncludes[0];\n    const topParent = topInclude.parent;\n    const topAssociation = topInclude.association;\n    topInclude.association = undefined;\n\n    if (topInclude.through && Object(topInclude.through.model) === topInclude.through.model) {\n      query = this.selectQuery(topInclude.through.model.getTableName(), {\n        attributes: [topInclude.through.model.primaryKeyField],\n        include: Model._validateIncludedElements({\n          model: topInclude.through.model,\n          include: [{\n            association: topAssociation.toTarget,\n            required: true,\n            where: topInclude.where,\n            include: topInclude.include\n          }]\n        }).include,\n        model: topInclude.through.model,\n        where: {\n          [Op.and]: [\n            this.sequelize.literal([\n              `${this.quoteTable(topParent.model.name)}.${this.quoteIdentifier(topParent.model.primaryKeyField)}`,\n              `${this.quoteIdentifier(topInclude.through.model.name)}.${this.quoteIdentifier(topAssociation.identifierField)}`\n            ].join(' = ')),\n            topInclude.through.where\n          ]\n        },\n        limit: 1,\n        includeIgnoreAttributes: false\n      }, topInclude.through.model);\n    } else {\n      const isBelongsTo = topAssociation.associationType === 'BelongsTo';\n      const sourceField = isBelongsTo ? topAssociation.identifierField : topAssociation.sourceKeyField || topParent.model.primaryKeyField;\n      const targetField = isBelongsTo ? topAssociation.sourceKeyField || topInclude.model.primaryKeyField : topAssociation.identifierField;\n\n      const join = [\n        `${this.quoteIdentifier(topInclude.as)}.${this.quoteIdentifier(targetField)}`,\n        `${this.quoteTable(topParent.as || topParent.model.name)}.${this.quoteIdentifier(sourceField)}`\n      ].join(' = ');\n\n      query = this.selectQuery(topInclude.model.getTableName(), {\n        attributes: [targetField],\n        include: Model._validateIncludedElements(topInclude).include,\n        model: topInclude.model,\n        where: {\n          [Op.and]: [\n            topInclude.where,\n            { [Op.join]: this.sequelize.literal(join) }\n          ]\n        },\n        limit: 1,\n        tableAs: topInclude.as,\n        includeIgnoreAttributes: false\n      }, topInclude.model);\n    }\n\n    if (!topLevelInfo.options.where[Op.and]) {\n      topLevelInfo.options.where[Op.and] = [];\n    }\n\n    topLevelInfo.options.where[`__${includeAs.internalAs}`] = this.sequelize.literal([\n      '(',\n      query.replace(/;$/, ''),\n      ')',\n      'IS NOT NULL'\n    ].join(' '));\n  }\n\n  /*\n   * For a given include hierarchy creates a copy of it where only the required includes\n   * are preserved.\n   */\n  _getRequiredClosure(include) {\n    const copy = { ...include, attributes: [], include: [] };\n\n    if (Array.isArray(include.include)) {\n      copy.include = include.include\n        .filter(i => i.required)\n        .map(inc => this._getRequiredClosure(inc));\n    }\n\n    return copy;\n  }\n\n  getQueryOrders(options, model, subQuery) {\n    const mainQueryOrder = [];\n    const subQueryOrder = [];\n\n    if (Array.isArray(options.order)) {\n      for (let order of options.order) {\n\n        // wrap if not array\n        if (!Array.isArray(order)) {\n          order = [order];\n        }\n\n        if (\n          subQuery\n          && Array.isArray(order)\n          && order[0]\n          && !(order[0] instanceof Association)\n          && !(typeof order[0] === 'function' && order[0].prototype instanceof Model)\n          && !(typeof order[0].model === 'function' && order[0].model.prototype instanceof Model)\n          && !(typeof order[0] === 'string' && model && model.associations !== undefined && model.associations[order[0]])\n        ) {\n          subQueryOrder.push(this.quote(order, model, '->'));\n        }\n\n        if (subQuery) {\n          // Handle case where sub-query renames attribute we want to order by,\n          // see https://github.com/sequelize/sequelize/issues/8739\n          const subQueryAttribute = options.attributes.find(a => Array.isArray(a) && a[0] === order[0] && a[1]);\n          if (subQueryAttribute) {\n            const modelName = this.quoteIdentifier(model.name);\n\n            order[0] = new Utils.Col(this._getAliasForField(modelName, subQueryAttribute[1], options) || subQueryAttribute[1]);\n          }\n        }\n\n        mainQueryOrder.push(this.quote(order, model, '->'));\n      }\n    } else if (options.order instanceof Utils.SequelizeMethod) {\n      const sql = this.quote(options.order, model, '->');\n      if (subQuery) {\n        subQueryOrder.push(sql);\n      }\n      mainQueryOrder.push(sql);\n    } else {\n      throw new Error('Order must be type of array or instance of a valid sequelize method.');\n    }\n\n    return { mainQueryOrder, subQueryOrder };\n  }\n\n  _throwOnEmptyAttributes(attributes, extraInfo = {}) {\n    if (attributes.length > 0) return;\n    const asPart = extraInfo.as && `as ${extraInfo.as}` || '';\n    const namePart = extraInfo.modelName && `for model '${extraInfo.modelName}'` || '';\n    const message = `Attempted a SELECT query ${namePart} ${asPart} without selecting any columns`;\n    throw new sequelizeError.QueryError(message.replace(/ +/g, ' '));\n  }\n\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs) {\n    this._throwOnEmptyAttributes(attributes, { modelName: model && model.name, as: mainTableAs });\n\n    let fragment = `SELECT ${attributes.join(', ')} FROM ${tables}`;\n\n    if (mainTableAs) {\n      fragment += ` AS ${mainTableAs}`;\n    }\n\n    if (options.indexHints && this._dialect.supports.indexHints) {\n      for (const hint of options.indexHints) {\n        if (IndexHints[hint.type]) {\n          fragment += ` ${IndexHints[hint.type]} INDEX (${hint.values.map(indexName => this.quoteIdentifiers(indexName)).join(',')})`;\n        }\n      }\n    }\n\n    return fragment;\n  }\n\n  /**\n   * Returns an SQL fragment for adding result constraints.\n   *\n   * @param  {object} options An object with selectQuery options.\n   * @returns {string}         The generated sql query.\n   * @private\n   */\n  addLimitAndOffset(options) {\n    let fragment = '';\n\n    /* eslint-disable */\n    if (options.offset != null && options.limit == null) {\n      fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + 10000000000000;\n    } else if (options.limit != null) {\n      if (options.offset != null) {\n        fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + this.escape(options.limit);\n      } else {\n        fragment += ' LIMIT ' + this.escape(options.limit);\n      }\n    }\n    /* eslint-enable */\n\n    return fragment;\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    let result;\n\n    if (Object.prototype.hasOwnProperty.call(this.OperatorMap, smth.comparator)) {\n      smth.comparator = this.OperatorMap[smth.comparator];\n    }\n\n    if (smth instanceof Utils.Where) {\n      let value = smth.logic;\n      let key;\n\n      if (smth.attribute instanceof Utils.SequelizeMethod) {\n        key = this.getWhereConditions(smth.attribute, tableName, factory, options, prepend);\n      } else {\n        key = `${this.quoteTable(smth.attribute.Model.name)}.${this.quoteIdentifier(smth.attribute.field || smth.attribute.fieldName)}`;\n      }\n\n      if (value && value instanceof Utils.SequelizeMethod) {\n        value = this.getWhereConditions(value, tableName, factory, options, prepend);\n\n        if (value === 'NULL') {\n          if (smth.comparator === '=') {\n            smth.comparator = 'IS';\n          }\n          if (smth.comparator === '!=') {\n            smth.comparator = 'IS NOT';\n          }\n        }\n\n        return [key, value].join(` ${smth.comparator} `);\n      }\n      if (_.isPlainObject(value)) {\n        return this.whereItemQuery(smth.attribute, value, {\n          model: factory\n        });\n      }\n      if ([this.OperatorMap[Op.between], this.OperatorMap[Op.notBetween]].includes(smth.comparator)) {\n        value = `${this.escape(value[0])} AND ${this.escape(value[1])}`;\n      } else if (typeof value === 'boolean') {\n        value = this.booleanValue(value);\n      } else {\n        value = this.escape(value);\n      }\n\n      if (value === 'NULL') {\n        if (smth.comparator === '=') {\n          smth.comparator = 'IS';\n        }\n        if (smth.comparator === '!=') {\n          smth.comparator = 'IS NOT';\n        }\n      }\n\n      return [key, value].join(` ${smth.comparator} `);\n    }\n    if (smth instanceof Utils.Literal) {\n      return smth.val;\n    }\n    if (smth instanceof Utils.Cast) {\n      if (smth.val instanceof Utils.SequelizeMethod) {\n        result = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n      } else if (_.isPlainObject(smth.val)) {\n        result = this.whereItemsQuery(smth.val);\n      } else {\n        result = this.escape(smth.val);\n      }\n\n      return `CAST(${result} AS ${smth.type.toUpperCase()})`;\n    }\n    if (smth instanceof Utils.Fn) {\n      return `${smth.fn}(${\n        smth.args.map(arg => {\n          if (arg instanceof Utils.SequelizeMethod) {\n            return this.handleSequelizeMethod(arg, tableName, factory, options, prepend);\n          }\n          if (_.isPlainObject(arg)) {\n            return this.whereItemsQuery(arg);\n          }\n          return this.escape(typeof arg === 'string' ? arg.replace('$', '$$$') : arg);\n        }).join(', ')\n      })`;\n    }\n    if (smth instanceof Utils.Col) {\n      if (Array.isArray(smth.col) && !factory) {\n        throw new Error('Cannot call Sequelize.col() with array outside of order / group clause');\n      }\n      if (smth.col.startsWith('*')) {\n        return '*';\n      }\n      return this.quote(smth.col, factory);\n    }\n    return smth.toString(this, factory);\n  }\n\n  whereQuery(where, options) {\n    const query = this.whereItemsQuery(where, options);\n    if (query && query.length) {\n      return `WHERE ${query}`;\n    }\n    return '';\n  }\n\n  whereItemsQuery(where, options, binding) {\n    if (\n      where === null ||\n      where === undefined ||\n      Utils.getComplexSize(where) === 0\n    ) {\n      // NO OP\n      return '';\n    }\n\n    if (typeof where === 'string') {\n      throw new Error('Support for `{where: \\'raw query\\'}` has been removed.');\n    }\n\n    const items = [];\n\n    binding = binding || 'AND';\n    if (binding[0] !== ' ') binding = ` ${binding} `;\n\n    if (_.isPlainObject(where)) {\n      Utils.getComplexKeys(where).forEach(prop => {\n        const item = where[prop];\n        items.push(this.whereItemQuery(prop, item, options));\n      });\n    } else {\n      items.push(this.whereItemQuery(undefined, where, options));\n    }\n\n    return items.length && items.filter(item => item && item.length).join(binding) || '';\n  }\n\n  whereItemQuery(key, value, options = {}) {\n    if (value === undefined) {\n      throw new Error(`WHERE parameter \"${key}\" has invalid \"undefined\" value`);\n    }\n\n    if (typeof key === 'string' && key.includes('.') && options.model) {\n      const keyParts = key.split('.');\n      if (options.model.rawAttributes[keyParts[0]] && options.model.rawAttributes[keyParts[0]].type instanceof DataTypes.JSON) {\n        const tmp = {};\n        const field = options.model.rawAttributes[keyParts[0]];\n        _.set(tmp, keyParts.slice(1), value);\n        return this.whereItemQuery(field.field || keyParts[0], tmp, { field, ...options });\n      }\n    }\n\n    const field = this._findField(key, options);\n    const fieldType = field && field.type || options.type;\n\n    const isPlainObject = _.isPlainObject(value);\n    const isArray = !isPlainObject && Array.isArray(value);\n    key = this.OperatorsAliasMap && this.OperatorsAliasMap[key] || key;\n    if (isPlainObject) {\n      value = this._replaceAliases(value);\n    }\n    const valueKeys = isPlainObject && Utils.getComplexKeys(value);\n\n    if (key === undefined) {\n      if (typeof value === 'string') {\n        return value;\n      }\n\n      if (isPlainObject && valueKeys.length === 1) {\n        return this.whereItemQuery(valueKeys[0], value[valueKeys[0]], options);\n      }\n    }\n\n    if (value === null) {\n      const opValue = options.bindParam ? 'NULL' : this.escape(value, field);\n      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.is], options.prefix);\n    }\n\n    if (!value) {\n      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n    }\n\n    if (value instanceof Utils.SequelizeMethod && !(key !== undefined && value instanceof Utils.Fn)) {\n      return this.handleSequelizeMethod(value);\n    }\n\n    // Convert where: [] to Op.and if possible, else treat as literal/replacements\n    if (key === undefined && isArray) {\n      if (Utils.canTreatArrayAsAnd(value)) {\n        key = Op.and;\n      } else {\n        throw new Error('Support for literal replacements in the `where` object has been removed.');\n      }\n    }\n\n    if (key === Op.or || key === Op.and || key === Op.not) {\n      return this._whereGroupBind(key, value, options);\n    }\n\n\n    if (value[Op.or]) {\n      return this._whereBind(this.OperatorMap[Op.or], key, value[Op.or], options);\n    }\n\n    if (value[Op.and]) {\n      return this._whereBind(this.OperatorMap[Op.and], key, value[Op.and], options);\n    }\n\n    if (isArray && fieldType instanceof DataTypes.ARRAY) {\n      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n    }\n\n    if (isPlainObject && fieldType instanceof DataTypes.JSON && options.json !== false) {\n      return this._whereJSON(key, value, options);\n    }\n    // If multiple keys we combine the different logic conditions\n    if (isPlainObject && valueKeys.length > 1) {\n      return this._whereBind(this.OperatorMap[Op.and], key, value, options);\n    }\n\n    if (isArray) {\n      return this._whereParseSingleValueObject(key, field, Op.in, value, options);\n    }\n    if (isPlainObject) {\n      if (this.OperatorMap[valueKeys[0]]) {\n        return this._whereParseSingleValueObject(key, field, valueKeys[0], value[valueKeys[0]], options);\n      }\n      return this._whereParseSingleValueObject(key, field, this.OperatorMap[Op.eq], value, options);\n    }\n\n    if (key === Op.placeholder) {\n      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(this.OperatorMap[key], opValue, this.OperatorMap[Op.eq], options.prefix);\n    }\n\n    const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n    return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n  }\n\n  _findField(key, options) {\n    if (options.field) {\n      return options.field;\n    }\n\n    if (options.model && options.model.rawAttributes && options.model.rawAttributes[key]) {\n      return options.model.rawAttributes[key];\n    }\n\n    if (options.model && options.model.fieldRawAttributesMap && options.model.fieldRawAttributesMap[key]) {\n      return options.model.fieldRawAttributesMap[key];\n    }\n  }\n\n  // OR/AND/NOT grouping logic\n  _whereGroupBind(key, value, options) {\n    const binding = key === Op.or ? this.OperatorMap[Op.or] : this.OperatorMap[Op.and];\n    const outerBinding = key === Op.not ? 'NOT ' : '';\n\n    if (Array.isArray(value)) {\n      value = value.map(item => {\n        let itemQuery = this.whereItemsQuery(item, options, this.OperatorMap[Op.and]);\n        if (itemQuery && itemQuery.length && (Array.isArray(item) || _.isPlainObject(item)) && Utils.getComplexSize(item) > 1) {\n          itemQuery = `(${itemQuery})`;\n        }\n        return itemQuery;\n      }).filter(item => item && item.length);\n\n      value = value.length && value.join(binding);\n    } else {\n      value = this.whereItemsQuery(value, options, binding);\n    }\n    // Op.or: [] should return no data.\n    // Op.not of no restriction should also return no data\n    if ((key === Op.or || key === Op.not) && !value) {\n      return '0 = 1';\n    }\n\n    return value ? `${outerBinding}(${value})` : undefined;\n  }\n\n  _whereBind(binding, key, value, options) {\n    if (_.isPlainObject(value)) {\n      value = Utils.getComplexKeys(value).map(prop => {\n        const item = value[prop];\n        return this.whereItemQuery(key, { [prop]: item }, options);\n      });\n    } else {\n      value = value.map(item => this.whereItemQuery(key, item, options));\n    }\n\n    value = value.filter(item => item && item.length);\n\n    return value.length ? `(${value.join(binding)})` : undefined;\n  }\n\n  _whereJSON(key, value, options) {\n    const items = [];\n    let baseKey = this.quoteIdentifier(key);\n    if (options.prefix) {\n      if (options.prefix instanceof Utils.Literal) {\n        baseKey = `${this.handleSequelizeMethod(options.prefix)}.${baseKey}`;\n      } else {\n        baseKey = `${this.quoteTable(options.prefix)}.${baseKey}`;\n      }\n    }\n\n    Utils.getOperators(value).forEach(op => {\n      const where = {\n        [op]: value[op]\n      };\n      items.push(this.whereItemQuery(key, where, { ...options, json: false }));\n    });\n\n    _.forOwn(value, (item, prop) => {\n      this._traverseJSON(items, baseKey, prop, item, [prop]);\n    });\n\n    const result = items.join(this.OperatorMap[Op.and]);\n    return items.length > 1 ? `(${result})` : result;\n  }\n\n  _traverseJSON(items, baseKey, prop, item, path) {\n    let cast;\n\n    if (path[path.length - 1].includes('::')) {\n      const tmp = path[path.length - 1].split('::');\n      cast = tmp[1];\n      path[path.length - 1] = tmp[0];\n    }\n\n    const pathKey = this.jsonPathExtractionQuery(baseKey, path);\n\n    if (_.isPlainObject(item)) {\n      Utils.getOperators(item).forEach(op => {\n        const value = this._toJSONValue(item[op]);\n        items.push(this.whereItemQuery(this._castKey(pathKey, value, cast), { [op]: value }));\n      });\n      _.forOwn(item, (value, itemProp) => {\n        this._traverseJSON(items, baseKey, itemProp, value, path.concat([itemProp]));\n      });\n\n      return;\n    }\n\n    item = this._toJSONValue(item);\n    items.push(this.whereItemQuery(this._castKey(pathKey, item, cast), { [Op.eq]: item }));\n  }\n\n  _toJSONValue(value) {\n    return value;\n  }\n\n  _castKey(key, value, cast, json) {\n    cast = cast || this._getJsonCast(Array.isArray(value) ? value[0] : value);\n    if (cast) {\n      return new Utils.Literal(this.handleSequelizeMethod(new Utils.Cast(new Utils.Literal(key), cast, json)));\n    }\n\n    return new Utils.Literal(key);\n  }\n\n  _getJsonCast(value) {\n    if (typeof value === 'number') {\n      return 'double precision';\n    }\n    if (value instanceof Date) {\n      return 'timestamptz';\n    }\n    if (typeof value === 'boolean') {\n      return 'boolean';\n    }\n    return;\n  }\n\n  _joinKeyValue(key, value, comparator, prefix) {\n    if (!key) {\n      return value;\n    }\n    if (comparator === undefined) {\n      throw new Error(`${key} and ${value} has no comparator`);\n    }\n    key = this._getSafeKey(key, prefix);\n    return [key, value].join(` ${comparator} `);\n  }\n\n  _getSafeKey(key, prefix) {\n    if (key instanceof Utils.SequelizeMethod) {\n      key = this.handleSequelizeMethod(key);\n      return this._prefixKey(this.handleSequelizeMethod(key), prefix);\n    }\n\n    if (Utils.isColString(key)) {\n      key = key.substr(1, key.length - 2).split('.');\n\n      if (key.length > 2) {\n        key = [\n          // join the tables by -> to match out internal namings\n          key.slice(0, -1).join('->'),\n          key[key.length - 1]\n        ];\n      }\n\n      return key.map(identifier => this.quoteIdentifier(identifier)).join('.');\n    }\n\n    return this._prefixKey(this.quoteIdentifier(key), prefix);\n  }\n\n  _prefixKey(key, prefix) {\n    if (prefix) {\n      if (prefix instanceof Utils.Literal) {\n        return [this.handleSequelizeMethod(prefix), key].join('.');\n      }\n\n      return [this.quoteTable(prefix), key].join('.');\n    }\n\n    return key;\n  }\n\n  _whereParseSingleValueObject(key, field, prop, value, options) {\n    if (prop === Op.not) {\n      if (Array.isArray(value)) {\n        prop = Op.notIn;\n      } else if (value !== null && value !== true && value !== false) {\n        prop = Op.ne;\n      }\n    }\n\n    let comparator = this.OperatorMap[prop] || this.OperatorMap[Op.eq];\n\n    switch (prop) {\n      case Op.in:\n      case Op.notIn:\n        if (value instanceof Utils.Literal) {\n          return this._joinKeyValue(key, value.val, comparator, options.prefix);\n        }\n\n        if (value.length) {\n          return this._joinKeyValue(key, `(${value.map(item => this.escape(item, field)).join(', ')})`, comparator, options.prefix);\n        }\n\n        if (comparator === this.OperatorMap[Op.in]) {\n          return this._joinKeyValue(key, '(NULL)', comparator, options.prefix);\n        }\n\n        return '';\n      case Op.any:\n      case Op.all:\n        comparator = `${this.OperatorMap[Op.eq]} ${comparator}`;\n        if (value[Op.values]) {\n          return this._joinKeyValue(key, `(VALUES ${value[Op.values].map(item => `(${this.escape(item)})`).join(', ')})`, comparator, options.prefix);\n        }\n\n        return this._joinKeyValue(key, `(${this.escape(value, field)})`, comparator, options.prefix);\n      case Op.between:\n      case Op.notBetween:\n        return this._joinKeyValue(key, `${this.escape(value[0], field)} AND ${this.escape(value[1], field)}`, comparator, options.prefix);\n      case Op.raw:\n        throw new Error('The `$raw` where property is no longer supported.  Use `sequelize.literal` instead.');\n      case Op.col:\n        comparator = this.OperatorMap[Op.eq];\n        value = value.split('.');\n\n        if (value.length > 2) {\n          value = [\n            // join the tables by -> to match out internal namings\n            value.slice(0, -1).join('->'),\n            value[value.length - 1]\n          ];\n        }\n\n        return this._joinKeyValue(key, value.map(identifier => this.quoteIdentifier(identifier)).join('.'), comparator, options.prefix);\n      case Op.startsWith:\n      case Op.endsWith:\n      case Op.substring:\n        comparator = this.OperatorMap[Op.like];\n\n        if (value instanceof Utils.Literal) {\n          value = value.val;\n        }\n\n        let pattern = `${value}%`;\n\n        if (prop === Op.endsWith) pattern = `%${value}`;\n        if (prop === Op.substring) pattern = `%${value}%`;\n\n        return this._joinKeyValue(key, this.escape(pattern), comparator, options.prefix);\n    }\n\n    const escapeOptions = {\n      acceptStrings: comparator.includes(this.OperatorMap[Op.like])\n    };\n\n    if (_.isPlainObject(value)) {\n      if (value[Op.col]) {\n        return this._joinKeyValue(key, this.whereItemQuery(null, value), comparator, options.prefix);\n      }\n      if (value[Op.any]) {\n        escapeOptions.isList = true;\n        return this._joinKeyValue(key, `(${this.escape(value[Op.any], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.any]}`, options.prefix);\n      }\n      if (value[Op.all]) {\n        escapeOptions.isList = true;\n        return this._joinKeyValue(key, `(${this.escape(value[Op.all], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.all]}`, options.prefix);\n      }\n    }\n\n    if (value === null && comparator === this.OperatorMap[Op.eq]) {\n      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.is], options.prefix);\n    }\n    if (value === null && comparator === this.OperatorMap[Op.ne]) {\n      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.not], options.prefix);\n    }\n\n    return this._joinKeyValue(key, this.escape(value, field, escapeOptions), comparator, options.prefix);\n  }\n\n  /*\n    Takes something and transforms it into values of a where condition.\n   @private\n  */\n  getWhereConditions(smth, tableName, factory, options, prepend) {\n    const where = {};\n\n    if (Array.isArray(tableName)) {\n      tableName = tableName[0];\n      if (Array.isArray(tableName)) {\n        tableName = tableName[1];\n      }\n    }\n\n    options = options || {};\n\n    if (prepend === undefined) {\n      prepend = true;\n    }\n\n    if (smth && smth instanceof Utils.SequelizeMethod) { // Checking a property is cheaper than a lot of instanceof calls\n      return this.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n    if (_.isPlainObject(smth)) {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName,\n        type: options.type\n      });\n    }\n    if (typeof smth === 'number') {\n      let primaryKeys = factory ? Object.keys(factory.primaryKeys) : [];\n\n      if (primaryKeys.length > 0) {\n        // Since we're just a number, assume only the first key\n        primaryKeys = primaryKeys[0];\n      } else {\n        primaryKeys = 'id';\n      }\n\n      where[primaryKeys] = smth;\n\n      return this.whereItemsQuery(where, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n    if (typeof smth === 'string') {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n    if (Buffer.isBuffer(smth)) {\n      return this.escape(smth);\n    }\n    if (Array.isArray(smth)) {\n      if (smth.length === 0 || smth.length > 0 && smth[0].length === 0) return '1=1';\n      if (Utils.canTreatArrayAsAnd(smth)) {\n        const _smth = { [Op.and]: smth };\n        return this.getWhereConditions(_smth, tableName, factory, options, prepend);\n      }\n      throw new Error('Support for literal replacements in the `where` object has been removed.');\n    }\n    if (smth === null) {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n\n    return '1=1';\n  }\n\n  // A recursive parser for nested where conditions\n  parseConditionObject(conditions, path) {\n    path = path || [];\n    return _.reduce(conditions, (result, value, key) => {\n      if (_.isObject(value)) {\n        return result.concat(this.parseConditionObject(value, path.concat(key))); // Recursively parse objects\n      }\n      result.push({ path: path.concat(key), value });\n      return result;\n    }, []);\n  }\n\n  booleanValue(value) {\n    return value;\n  }\n}\n\nObject.assign(QueryGenerator.prototype, require('./query-generator/operators'));\nObject.assign(QueryGenerator.prototype, require('./query-generator/transaction'));\n\nmodule.exports = QueryGenerator;\n"]},"metadata":{},"sourceType":"script"}