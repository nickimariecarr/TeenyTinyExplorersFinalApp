{"ast":null,"code":"\"use strict\";\n\nvar _ = Object.defineProperty;\nvar V = Object.getOwnPropertySymbols;\nvar E = Object.prototype.hasOwnProperty,\n    b = Object.prototype.propertyIsEnumerable;\n\nvar p = (o, t, s) => t in o ? _(o, t, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: s\n}) : o[t] = s,\n    w = (o, t) => {\n  for (var s in t || (t = {})) E.call(t, s) && p(o, s, t[s]);\n\n  if (V) for (var s of V(t)) b.call(t, s) && p(o, s, t[s]);\n  return o;\n};\n\nvar y = (o, t) => _(o, \"name\", {\n  value: t,\n  configurable: !0\n});\n\nconst c = require(\"lodash\"),\n      A = require(\"./utils\"),\n      u = require(\"./errors\"),\n      g = require(\"./data-types\"),\n      P = require(\"./associations/belongs-to\"),\n      I = require(\"./utils/validator-extras\").validator,\n      {\n  promisify: k\n} = require(\"util\");\n\nclass l {\n  constructor(t, s) {\n    s = w({\n      hooks: !0\n    }, s), s.fields && !s.skip ? s.skip = c.difference(Object.keys(t.constructor.rawAttributes), s.fields) : s.skip = s.skip || [], this.options = s, this.modelInstance = t, this.validator = I, this.errors = [], this.inProgress = !1;\n  }\n\n  async _validate() {\n    if (this.inProgress) throw new Error(\"Validations already in progress.\");\n    if (this.inProgress = !0, await Promise.all([this._perAttributeValidators(), this._customValidators()]), this.errors.length) throw new u.ValidationError(null, this.errors);\n  }\n\n  async validate() {\n    return await (this.options.hooks ? this._validateAndRunHooks() : this._validate());\n  }\n\n  async _validateAndRunHooks() {\n    const t = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);\n    await t(\"beforeValidate\", this.modelInstance, this.options);\n\n    try {\n      await this._validate();\n    } catch (s) {\n      throw (await t(\"validationFailed\", this.modelInstance, this.options, s)) || s;\n    }\n\n    return await t(\"afterValidate\", this.modelInstance, this.options), this.modelInstance;\n  }\n\n  async _perAttributeValidators() {\n    const t = [];\n    return c.forIn(this.modelInstance.rawAttributes, (s, i) => {\n      if (this.options.skip.includes(i)) return;\n      const r = this.modelInstance.dataValues[i];\n      r instanceof A.SequelizeMethod || (!s._autoGenerated && !s.autoIncrement && this._validateSchema(s, i, r), Object.prototype.hasOwnProperty.call(this.modelInstance.validators, i) && t.push(this._singleAttrValidate(r, i, s.allowNull)));\n    }), await Promise.all(t);\n  }\n\n  async _customValidators() {\n    const t = [];\n    return c.each(this.modelInstance.constructor.options.validate, (s, i) => {\n      if (this.options.skip.includes(i)) return;\n\n      const r = this._invokeCustomValidator(s, i).catch(() => {});\n\n      t.push(r);\n    }), await Promise.all(t);\n  }\n\n  async _singleAttrValidate(t, s, i) {\n    if (t == null && !i) return;\n    const r = [];\n    return c.forIn(this.modelInstance.validators[s], (n, e) => {\n      if ((e === \"isUrl\" || e === \"isURL\" || e === \"isEmail\") && (typeof n == \"object\" && n !== null && n.msg ? n = {\n        msg: n.msg\n      } : n === !0 && (n = {})), typeof n == \"function\") {\n        r.push(this._invokeCustomValidator(n, e, !0, t, s));\n        return;\n      }\n\n      if (t == null) return;\n\n      const a = this._invokeBuiltinValidator(t, n, e, s);\n\n      a.catch(() => {}), r.push(a);\n    }), Promise.all(r.map(n => n.catch(e => {\n      const a = !!e.validatorName;\n\n      this._pushError(a, s, e, t, e.validatorName, e.validatorArgs);\n    })));\n  }\n\n  async _invokeCustomValidator(t, s, i, r, n) {\n    let e = !1;\n    const a = t.length;\n    let h = 1,\n        d = s,\n        m;\n    if (i && (h = 2, m = r, d = n), a === h && (e = !0), e) try {\n      return i ? await k(t.bind(this.modelInstance, m))() : await k(t.bind(this.modelInstance))();\n    } catch (f) {\n      return this._pushError(!1, d, f, r, s);\n    }\n\n    try {\n      return await t.call(this.modelInstance, m);\n    } catch (f) {\n      return this._pushError(!1, d, f, r, s);\n    }\n  }\n\n  async _invokeBuiltinValidator(t, s, i, r) {\n    const n = String(t);\n    if (typeof I[i] != \"function\") throw new Error(`Invalid validator function: ${i}`);\n\n    const e = this._extractValidatorArgs(s, i, r);\n\n    if (!I[i](n, ...e)) throw Object.assign(new Error(s.msg || `Validation ${i} on ${r} failed`), {\n      validatorName: i,\n      validatorArgs: e\n    });\n  }\n\n  _extractValidatorArgs(t, s, i) {\n    let r = t.args || t;\n    const n = typeof r != \"string\" && (s === \"isAlpha\" || s === \"isAlphanumeric\" || s === \"isMobilePhone\");\n    return Array.isArray(r) ? r = r.slice(0) : s === \"isImmutable\" ? r = [r, i, this.modelInstance] : n || s === \"isIP\" ? r = [] : r = [r], r;\n  }\n\n  _validateSchema(t, s, i) {\n    if (t.allowNull === !1 && i == null) {\n      const r = Object.values(this.modelInstance.constructor.associations).find(n => n instanceof P && n.foreignKey === t.fieldName);\n\n      if (!r || !this.modelInstance.get(r.associationAccessor)) {\n        const n = this.modelInstance.validators[s],\n              e = c.get(n, \"notNull.msg\", `${this.modelInstance.constructor.name}.${s} cannot be null`);\n        this.errors.push(new u.ValidationErrorItem(e, \"notNull Violation\", s, i, this.modelInstance, \"is_null\"));\n      }\n    }\n\n    (t.type instanceof g.STRING || t.type instanceof g.TEXT || t.type instanceof g.CITEXT) && (Array.isArray(i) || c.isObject(i) && !(i instanceof A.SequelizeMethod) && !Buffer.isBuffer(i)) && this.errors.push(new u.ValidationErrorItem(`${s} cannot be an array or an object`, \"string violation\", s, i, this.modelInstance, \"not_a_string\"));\n  }\n\n  _pushError(t, s, i, r, n, e) {\n    const a = i.message || i || \"Validation error\",\n          h = new u.ValidationErrorItem(a, \"Validation error\", s, r, this.modelInstance, n, t ? n : void 0, t ? e : void 0);\n    h[l.RAW_KEY_NAME] = i, this.errors.push(h);\n  }\n\n}\n\ny(l, \"InstanceValidator\"), l.RAW_KEY_NAME = \"original\", module.exports = l, module.exports.InstanceValidator = l, module.exports.default = l;","map":{"version":3,"sources":["../../lib/instance-validator.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('./utils');\nconst sequelizeError = require('./errors');\nconst DataTypes = require('./data-types');\nconst BelongsTo = require('./associations/belongs-to');\nconst validator = require('./utils/validator-extras').validator;\nconst { promisify } = require('util');\n\n/**\n * Instance Validator.\n *\n * @param {Instance} modelInstance The model instance.\n * @param {object} options A dictionary with options.\n *\n * @private\n */\nclass InstanceValidator {\n  constructor(modelInstance, options) {\n    options = {\n      // assign defined and default options\n      hooks: true,\n      ...options\n    };\n\n    if (options.fields && !options.skip) {\n      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);\n    } else {\n      options.skip = options.skip || [];\n    }\n\n    this.options = options;\n\n    this.modelInstance = modelInstance;\n\n    /**\n     * Exposes a reference to validator.js. This allows you to add custom validations using `validator.extend`\n     *\n     * @name validator\n     * @private\n     */\n    this.validator = validator;\n\n    /**\n     *  All errors will be stored here from the validations.\n     *\n     * @type {Array} Will contain keys that correspond to attributes which will\n     *   be Arrays of Errors.\n     * @private\n     */\n    this.errors = [];\n\n    /**\n     * @type {boolean} Indicates if validations are in progress\n     * @private\n     */\n    this.inProgress = false;\n  }\n\n  /**\n   * The main entry point for the Validation module, invoke to start the dance.\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async _validate() {\n    if (this.inProgress) throw new Error('Validations already in progress.');\n\n    this.inProgress = true;\n\n    await Promise.all([\n      this._perAttributeValidators(),\n      this._customValidators()\n    ]);\n\n    if (this.errors.length) {\n      throw new sequelizeError.ValidationError(null, this.errors);\n    }\n  }\n\n  /**\n   * Invoke the Validation sequence and run validation hooks if defined\n   *   - Before Validation Model Hooks\n   *   - Validation\n   *   - On validation success: After Validation Model Hooks\n   *   - On validation failure: Validation Failed Model Hooks\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async validate() {\n    return await (this.options.hooks ? this._validateAndRunHooks() : this._validate());\n  }\n\n  /**\n   * Invoke the Validation sequence and run hooks\n   *   - Before Validation Model Hooks\n   *   - Validation\n   *   - On validation success: After Validation Model Hooks\n   *   - On validation failure: Validation Failed Model Hooks\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async _validateAndRunHooks() {\n    const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);\n    await runHooks('beforeValidate', this.modelInstance, this.options);\n\n    try {\n      await this._validate();\n    } catch (error) {\n      const newError = await runHooks('validationFailed', this.modelInstance, this.options, error);\n      throw newError || error;\n    }\n\n    await runHooks('afterValidate', this.modelInstance, this.options);\n    return this.modelInstance;\n  }\n\n  /**\n   * Will run all the validators defined per attribute (built-in validators and custom validators)\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  async _perAttributeValidators() {\n    // promisify all attribute invocations\n    const validators = [];\n\n    _.forIn(this.modelInstance.rawAttributes, (rawAttribute, field) => {\n      if (this.options.skip.includes(field)) {\n        return;\n      }\n\n      const value = this.modelInstance.dataValues[field];\n\n      if (value instanceof Utils.SequelizeMethod) {\n        return;\n      }\n\n      if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {\n        // perform validations based on schema\n        this._validateSchema(rawAttribute, field, value);\n      }\n\n      if (Object.prototype.hasOwnProperty.call(this.modelInstance.validators, field)) {\n        validators.push(this._singleAttrValidate(value, field, rawAttribute.allowNull));\n      }\n    });\n\n    return await Promise.all(validators);\n  }\n\n  /**\n   * Will run all the custom validators defined in the model's options.\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  async _customValidators() {\n    const validators = [];\n    _.each(this.modelInstance.constructor.options.validate, (validator, validatorType) => {\n      if (this.options.skip.includes(validatorType)) {\n        return;\n      }\n\n      const valprom = this._invokeCustomValidator(validator, validatorType)\n        // errors are handled in settling, stub this\n        .catch(() => {});\n\n      validators.push(valprom);\n    });\n\n    return await Promise.all(validators);\n  }\n\n  /**\n   * Validate a single attribute with all the defined built-in validators and custom validators.\n   *\n   * @private\n   *\n   * @param {*} value Anything.\n   * @param {string} field The field name.\n   * @param {boolean} allowNull Whether or not the schema allows null values\n   *\n   * @returns {Promise} A promise, will always resolve, auto populates error on this.error local object.\n   */\n  async _singleAttrValidate(value, field, allowNull) {\n    // If value is null and allowNull is false, no validators should run (see #9143)\n    if ((value === null || value === undefined) && !allowNull) {\n      // The schema validator (_validateSchema) has already generated the validation error. Nothing to do here.\n      return;\n    }\n\n    // Promisify each validator\n    const validators = [];\n    _.forIn(this.modelInstance.validators[field], (test, validatorType) => {\n\n      if (validatorType === 'isUrl' || validatorType === 'isURL' || validatorType === 'isEmail') {\n        // Preserve backwards compat. Validator.js now expects the second param to isURL and isEmail to be an object\n        if (typeof test === 'object' && test !== null && test.msg) {\n          test = {\n            msg: test.msg\n          };\n        } else if (test === true) {\n          test = {};\n        }\n      }\n\n      // Custom validators should always run, except if value is null and allowNull is false (see #9143)\n      if (typeof test === 'function') {\n        validators.push(this._invokeCustomValidator(test, validatorType, true, value, field));\n        return;\n      }\n\n      // If value is null, built-in validators should not run (only custom validators have to run) (see #9134).\n      if (value === null || value === undefined) {\n        return;\n      }\n\n      const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field);\n      // errors are handled in settling, stub this\n      validatorPromise.catch(() => {});\n      validators.push(validatorPromise);\n    });\n\n    return Promise\n      .all(validators.map(validator => validator.catch(rejection => {\n        const isBuiltIn = !!rejection.validatorName;\n        this._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);\n      })));\n  }\n\n  /**\n   * Prepare and invoke a custom validator.\n   *\n   * @private\n   *\n   * @param {Function} validator The custom validator.\n   * @param {string} validatorType the custom validator type (name).\n   * @param {boolean} optAttrDefined Set to true if custom validator was defined from the attribute\n   * @param {*} optValue value for attribute\n   * @param {string} optField field for attribute\n   *\n   * @returns {Promise} A promise.\n   */\n  async _invokeCustomValidator(validator, validatorType, optAttrDefined, optValue, optField) {\n    let isAsync = false;\n\n    const validatorArity = validator.length;\n    // check if validator is async and requires a callback\n    let asyncArity = 1;\n    let errorKey = validatorType;\n    let invokeArgs;\n    if (optAttrDefined) {\n      asyncArity = 2;\n      invokeArgs = optValue;\n      errorKey = optField;\n    }\n    if (validatorArity === asyncArity) {\n      isAsync = true;\n    }\n\n    if (isAsync) {\n      try {\n        if (optAttrDefined) {\n          return await promisify(validator.bind(this.modelInstance, invokeArgs))();\n        }\n        return await promisify(validator.bind(this.modelInstance))();\n      } catch (e) {\n        return this._pushError(false, errorKey, e, optValue, validatorType);\n      }\n    }\n\n    try {\n      return await validator.call(this.modelInstance, invokeArgs);\n    } catch (e) {\n      return this._pushError(false, errorKey, e, optValue, validatorType);\n    }\n  }\n\n  /**\n   * Prepare and invoke a build-in validator.\n   *\n   * @private\n   *\n   * @param {*} value Anything.\n   * @param {*} test The test case.\n   * @param {string} validatorType One of known to Sequelize validators.\n   * @param {string} field The field that is being validated\n   *\n   * @returns {object} An object with specific keys to invoke the validator.\n   */\n  async _invokeBuiltinValidator(value, test, validatorType, field) {\n    // Cast value as string to pass new Validator.js string requirement\n    const valueString = String(value);\n    // check if Validator knows that kind of validation test\n    if (typeof validator[validatorType] !== 'function') {\n      throw new Error(`Invalid validator function: ${validatorType}`);\n    }\n\n    const validatorArgs = this._extractValidatorArgs(test, validatorType, field);\n\n    if (!validator[validatorType](valueString, ...validatorArgs)) {\n      throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), { validatorName: validatorType, validatorArgs });\n    }\n  }\n\n  /**\n   * Will extract arguments for the validator.\n   *\n   * @param {*} test The test case.\n   * @param {string} validatorType One of known to Sequelize validators.\n   * @param {string} field The field that is being validated.\n   *\n   * @private\n   */\n  _extractValidatorArgs(test, validatorType, field) {\n    let validatorArgs = test.args || test;\n    const isLocalizedValidator = typeof validatorArgs !== 'string' && (validatorType === 'isAlpha' || validatorType === 'isAlphanumeric' || validatorType === 'isMobilePhone');\n\n    if (!Array.isArray(validatorArgs)) {\n      if (validatorType === 'isImmutable') {\n        validatorArgs = [validatorArgs, field, this.modelInstance];\n      } else if (isLocalizedValidator || validatorType === 'isIP') {\n        validatorArgs = [];\n      } else {\n        validatorArgs = [validatorArgs];\n      }\n    } else {\n      validatorArgs = validatorArgs.slice(0);\n    }\n    return validatorArgs;\n  }\n\n  /**\n   * Will validate a single field against its schema definition (isnull).\n   *\n   * @param {object} rawAttribute As defined in the Schema.\n   * @param {string} field The field name.\n   * @param {*} value anything.\n   *\n   * @private\n   */\n  _validateSchema(rawAttribute, field, value) {\n    if (rawAttribute.allowNull === false && (value === null || value === undefined)) {\n      const association = Object.values(this.modelInstance.constructor.associations).find(association => association instanceof BelongsTo && association.foreignKey === rawAttribute.fieldName);\n      if (!association || !this.modelInstance.get(association.associationAccessor)) {\n        const validators = this.modelInstance.validators[field];\n        const errMsg = _.get(validators, 'notNull.msg', `${this.modelInstance.constructor.name}.${field} cannot be null`);\n\n        this.errors.push(new sequelizeError.ValidationErrorItem(\n          errMsg,\n          'notNull Violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\n          field,\n          value,\n          this.modelInstance,\n          'is_null'\n        ));\n      }\n    }\n\n    if (rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type instanceof DataTypes.TEXT || rawAttribute.type instanceof DataTypes.CITEXT) {\n      if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {\n        this.errors.push(new sequelizeError.ValidationErrorItem(\n          `${field} cannot be an array or an object`,\n          'string violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\n          field,\n          value,\n          this.modelInstance,\n          'not_a_string'\n        ));\n      }\n    }\n  }\n\n  /**\n   * Signs all errors retaining the original.\n   *\n   * @param {boolean}       isBuiltin   - Determines if error is from builtin validator.\n   * @param {string}        errorKey    - name of invalid attribute.\n   * @param {Error|string}  rawError    - The original error.\n   * @param {string|number} value       - The data that triggered the error.\n   * @param {string}        fnName      - Name of the validator, if any\n   * @param {Array}         fnArgs      - Arguments for the validator [function], if any\n   *\n   * @private\n   */\n  _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {\n    const message = rawError.message || rawError || 'Validation error';\n    const error = new sequelizeError.ValidationErrorItem(\n      message,\n      'Validation error', // sequelizeError.ValidationErrorItem.Origins.FUNCTION,\n      errorKey,\n      value,\n      this.modelInstance,\n      fnName,\n      isBuiltin ? fnName : undefined,\n      isBuiltin ? fnArgs : undefined\n    );\n\n    error[InstanceValidator.RAW_KEY_NAME] = rawError;\n\n    this.errors.push(error);\n  }\n}\n/**\n * The error key for arguments as passed by custom validators\n *\n * @type {string}\n * @private\n */\nInstanceValidator.RAW_KEY_NAME = 'original';\n\nmodule.exports = InstanceValidator;\nmodule.exports.InstanceValidator = InstanceValidator;\nmodule.exports.default = InstanceValidator;\n"]},"metadata":{},"sourceType":"script"}