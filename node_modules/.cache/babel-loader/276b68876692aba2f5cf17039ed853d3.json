{"ast":null,"code":"\"use strict\";\n\nvar f = Object.defineProperty;\nvar d = Object.getOwnPropertySymbols;\nvar S = Object.prototype.hasOwnProperty,\n    z = Object.prototype.propertyIsEnumerable;\n\nvar g = (n, e, r) => e in n ? f(n, e, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: r\n}) : n[e] = r,\n    l = (n, e) => {\n  for (var r in e || (e = {})) S.call(e, r) && g(n, r, e[r]);\n\n  if (d) for (var r of d(e)) z.call(e, r) && g(n, r, e[r]);\n  return n;\n};\n\nvar Q = (n, e) => f(n, \"name\", {\n  value: e,\n  configurable: !0\n});\n\nconst G = require(\"lodash\"),\n      K = require(\"../../utils\"),\n      m = require(\"../../query-types\"),\n      p = require(\"../../operators\"),\n      {\n  QueryInterface: v\n} = require(\"../abstract/query-interface\");\n\nclass C extends v {\n  async removeColumn(e, r, s) {\n    s = l({\n      raw: !0\n    }, s || {});\n    const i = this.queryGenerator.getDefaultConstraintQuery(e, r),\n          [u] = await this.sequelize.query(i, s);\n\n    if (u.length) {\n      const t = this.queryGenerator.dropConstraintQuery(e, u[0].name);\n      await this.sequelize.query(t, s);\n    }\n\n    const q = this.queryGenerator.getForeignKeyQuery(e, r),\n          [y] = await this.sequelize.query(q, s);\n\n    if (y.length) {\n      const t = this.queryGenerator.dropForeignKeyQuery(e, y[0].constraint_name);\n      await this.sequelize.query(t, s);\n    }\n\n    const o = this.queryGenerator.getPrimaryKeyConstraintQuery(e, r),\n          [c] = await this.sequelize.query(o, s);\n\n    if (c.length) {\n      const t = this.queryGenerator.dropConstraintQuery(e, c[0].constraintName);\n      await this.sequelize.query(t, s);\n    }\n\n    const a = this.queryGenerator.removeColumnQuery(e, r);\n    return this.sequelize.query(a, s);\n  }\n\n  async upsert(e, r, s, i, u) {\n    const q = u.model,\n          y = [];\n    u = l({}, u), K.isWhereEmpty(i) || y.push(i);\n    let o = Object.values(q.uniqueKeys).map(t => t.fields);\n    o = o.concat(Object.values(q._indexes).filter(t => t.unique).map(t => t.fields));\n    const c = Object.keys(r);\n\n    for (const t of o) if (G.intersection(c, t).length === t.length) {\n      i = {};\n\n      for (const h of t) i[h] = r[h];\n\n      y.push(i);\n    }\n\n    i = {\n      [p.or]: y\n    }, u.type = m.UPSERT, u.raw = !0;\n    const a = this.queryGenerator.upsertQuery(e, r, s, i, q, u);\n    return await this.sequelize.query(a, u);\n  }\n\n}\n\nQ(C, \"MSSqlQueryInterface\"), exports.MSSqlQueryInterface = C;","map":{"version":3,"sources":["../../../../lib/dialects/mssql/query-interface.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\n\nconst Utils = require('../../utils');\nconst QueryTypes = require('../../query-types');\nconst Op = require('../../operators');\nconst { QueryInterface } = require('../abstract/query-interface');\n\n/**\n * The interface that Sequelize uses to talk with MSSQL database\n */\nclass MSSqlQueryInterface extends QueryInterface {\n  /**\n  * A wrapper that fixes MSSQL's inability to cleanly remove columns from existing tables if they have a default constraint.\n  *\n  * @override\n  */\n  async removeColumn(tableName, attributeName, options) {\n    options = { raw: true, ...options || {} };\n\n    const findConstraintSql = this.queryGenerator.getDefaultConstraintQuery(tableName, attributeName);\n    const [results0] = await this.sequelize.query(findConstraintSql, options);\n    if (results0.length) {\n      // No default constraint found -- we can cleanly remove the column\n      const dropConstraintSql = this.queryGenerator.dropConstraintQuery(tableName, results0[0].name);\n      await this.sequelize.query(dropConstraintSql, options);\n    }\n    const findForeignKeySql = this.queryGenerator.getForeignKeyQuery(tableName, attributeName);\n    const [results] = await this.sequelize.query(findForeignKeySql, options);\n    if (results.length) {\n      // No foreign key constraints found, so we can remove the column\n      const dropForeignKeySql = this.queryGenerator.dropForeignKeyQuery(tableName, results[0].constraint_name);\n      await this.sequelize.query(dropForeignKeySql, options);\n    }\n    //Check if the current column is a primaryKey\n    const primaryKeyConstraintSql = this.queryGenerator.getPrimaryKeyConstraintQuery(tableName, attributeName);\n    const [result] = await this.sequelize.query(primaryKeyConstraintSql, options);\n    if (result.length) {\n      const dropConstraintSql = this.queryGenerator.dropConstraintQuery(tableName, result[0].constraintName);\n      await this.sequelize.query(dropConstraintSql, options);\n    }\n    const removeSql = this.queryGenerator.removeColumnQuery(tableName, attributeName);\n    return this.sequelize.query(removeSql, options);\n  }\n\n  /**\n   * @override\n   */\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    const model = options.model;\n    const wheres = [];\n\n    options = { ...options };\n\n    if (!Utils.isWhereEmpty(where)) {\n      wheres.push(where);\n    }\n\n    // Lets combine unique keys and indexes into one\n    let indexes = Object.values(model.uniqueKeys).map(item => item.fields);\n    indexes = indexes.concat(Object.values(model._indexes).filter(item => item.unique).map(item => item.fields));\n\n    const attributes = Object.keys(insertValues);\n    for (const index of indexes) {\n      if (_.intersection(attributes, index).length === index.length) {\n        where = {};\n        for (const field of index) {\n          where[field] = insertValues[field];\n        }\n        wheres.push(where);\n      }\n    }\n\n    where = { [Op.or]: wheres };\n\n    options.type = QueryTypes.UPSERT;\n    options.raw = true;\n\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    return await this.sequelize.query(sql, options);\n  }\n}\n\nexports.MSSqlQueryInterface = MSSqlQueryInterface;\n"]},"metadata":{},"sourceType":"script"}