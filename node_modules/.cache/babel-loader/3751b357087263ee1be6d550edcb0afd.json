{"ast":null,"code":"\"use strict\";\n\nvar c = Object.defineProperty;\nvar n = Object.getOwnPropertySymbols;\nvar p = Object.prototype.hasOwnProperty,\n    O = Object.prototype.propertyIsEnumerable;\n\nvar o = (s, a, t) => a in s ? c(s, a, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: t\n}) : s[a] = t,\n    l = (s, a) => {\n  for (var t in a || (a = {})) p.call(a, t) && o(s, t, a[t]);\n\n  if (n) for (var t of n(a)) O.call(a, t) && o(s, t, a[t]);\n  return s;\n};\n\nconst r = require(\"lodash\"),\n      e = require(\"../../../operators\"),\n      E = require(\"../../../utils\"),\n      L = {\n  OperatorMap: {\n    [e.eq]: \"=\",\n    [e.ne]: \"!=\",\n    [e.gte]: \">=\",\n    [e.gt]: \">\",\n    [e.lte]: \"<=\",\n    [e.lt]: \"<\",\n    [e.not]: \"IS NOT\",\n    [e.is]: \"IS\",\n    [e.in]: \"IN\",\n    [e.notIn]: \"NOT IN\",\n    [e.like]: \"LIKE\",\n    [e.notLike]: \"NOT LIKE\",\n    [e.iLike]: \"ILIKE\",\n    [e.notILike]: \"NOT ILIKE\",\n    [e.startsWith]: \"LIKE\",\n    [e.endsWith]: \"LIKE\",\n    [e.substring]: \"LIKE\",\n    [e.regexp]: \"~\",\n    [e.notRegexp]: \"!~\",\n    [e.iRegexp]: \"~*\",\n    [e.notIRegexp]: \"!~*\",\n    [e.between]: \"BETWEEN\",\n    [e.notBetween]: \"NOT BETWEEN\",\n    [e.overlap]: \"&&\",\n    [e.contains]: \"@>\",\n    [e.contained]: \"<@\",\n    [e.adjacent]: \"-|-\",\n    [e.strictLeft]: \"<<\",\n    [e.strictRight]: \">>\",\n    [e.noExtendRight]: \"&<\",\n    [e.noExtendLeft]: \"&>\",\n    [e.any]: \"ANY\",\n    [e.all]: \"ALL\",\n    [e.and]: \" AND \",\n    [e.or]: \" OR \",\n    [e.col]: \"COL\",\n    [e.placeholder]: \"$$PLACEHOLDER$$\",\n    [e.match]: \"@@\"\n  },\n  OperatorsAliasMap: {},\n\n  setOperatorsAliases(s) {\n    !s || r.isEmpty(s) ? this.OperatorsAliasMap = !1 : this.OperatorsAliasMap = l({}, s);\n  },\n\n  _replaceAliases(s) {\n    const a = {};\n    return this.OperatorsAliasMap ? (E.getOperators(s).forEach(t => {\n      const i = s[t];\n      r.isPlainObject(i) ? a[t] = this._replaceAliases(i) : a[t] = i;\n    }), r.forOwn(s, (t, i) => {\n      i = this.OperatorsAliasMap[i] || i, r.isPlainObject(t) && (t = this._replaceAliases(t)), a[i] = t;\n    }), a) : s;\n  }\n\n};\n\nmodule.exports = L;","map":{"version":3,"sources":["../../../../../lib/dialects/abstract/query-generator/operators.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Op = require('../../../operators');\nconst Utils = require('../../../utils');\n\nconst OperatorHelpers = {\n  OperatorMap: {\n    [Op.eq]: '=',\n    [Op.ne]: '!=',\n    [Op.gte]: '>=',\n    [Op.gt]: '>',\n    [Op.lte]: '<=',\n    [Op.lt]: '<',\n    [Op.not]: 'IS NOT',\n    [Op.is]: 'IS',\n    [Op.in]: 'IN',\n    [Op.notIn]: 'NOT IN',\n    [Op.like]: 'LIKE',\n    [Op.notLike]: 'NOT LIKE',\n    [Op.iLike]: 'ILIKE',\n    [Op.notILike]: 'NOT ILIKE',\n    [Op.startsWith]: 'LIKE',\n    [Op.endsWith]: 'LIKE',\n    [Op.substring]: 'LIKE',\n    [Op.regexp]: '~',\n    [Op.notRegexp]: '!~',\n    [Op.iRegexp]: '~*',\n    [Op.notIRegexp]: '!~*',\n    [Op.between]: 'BETWEEN',\n    [Op.notBetween]: 'NOT BETWEEN',\n    [Op.overlap]: '&&',\n    [Op.contains]: '@>',\n    [Op.contained]: '<@',\n    [Op.adjacent]: '-|-',\n    [Op.strictLeft]: '<<',\n    [Op.strictRight]: '>>',\n    [Op.noExtendRight]: '&<',\n    [Op.noExtendLeft]: '&>',\n    [Op.any]: 'ANY',\n    [Op.all]: 'ALL',\n    [Op.and]: ' AND ',\n    [Op.or]: ' OR ',\n    [Op.col]: 'COL',\n    [Op.placeholder]: '$$PLACEHOLDER$$',\n    [Op.match]: '@@'\n  },\n\n  OperatorsAliasMap: {},\n\n  setOperatorsAliases(aliases) {\n    if (!aliases || _.isEmpty(aliases)) {\n      this.OperatorsAliasMap = false;\n    } else {\n      this.OperatorsAliasMap = { ...aliases };\n    }\n  },\n\n  _replaceAliases(orig) {\n    const obj = {};\n    if (!this.OperatorsAliasMap) {\n      return orig;\n    }\n\n    Utils.getOperators(orig).forEach(op => {\n      const item = orig[op];\n      if (_.isPlainObject(item)) {\n        obj[op] = this._replaceAliases(item);\n      } else {\n        obj[op] = item;\n      }\n    });\n\n    _.forOwn(orig, (item, prop) => {\n      prop = this.OperatorsAliasMap[prop] || prop;\n      if (_.isPlainObject(item)) {\n        item = this._replaceAliases(item);\n      }\n      obj[prop] = item;\n    });\n    return obj;\n  }\n};\n\nmodule.exports = OperatorHelpers;\n"]},"metadata":{},"sourceType":"script"}